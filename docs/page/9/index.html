<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/Ashun.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/Ashun.ico">
  <link rel="mask-icon" href="/images/favicons/Ashun.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#34495e","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阿顺特烦恼,希望大家没有烦恼">
<meta property="og:type" content="website">
<meta property="og:title" content="AshunBlog">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="AshunBlog">
<meta property="og:description" content="阿顺特烦恼,希望大家没有烦恼">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="阿顺特烦恼">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>AshunBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AshunBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习,天天Code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">33</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/astfn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise/" class="post-title-link" itemprop="url">Promise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:38:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:38:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:04:45" itemprop="dateModified" datetime="2021-05-17T09:04:45+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>JavaScript</code> 中存在很多异步操作,<code>Promise</code> 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。可以通过链式调用多个 <code>Promise</code> 达到我们的目的。</p>
<p>Promise 在各种开源库中已经实现，现在标准化后被浏览器默认支持。</p>
<blockquote>
<p>promise 是一个拥有 <code>then</code> 方法的对象或函数</p>
</blockquote>
<h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>下面通过多个示例来感受一下不使用 <code>promise</code> 时，处理相应问题的不易，及生成了不便阅读的代码。</p>
<h4 id="定时嵌套"><a href="#定时嵌套" class="headerlink" title="定时嵌套"></a>定时嵌套</h4><p>下面是一个定时器执行结束后，执行另一个定时器，这种嵌套造成代码不易阅读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createInterval(callback, delay &#x3D; 50) &#123;</span><br><span class="line">        let timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          callback(timer);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">      const div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      console.log(parseFloat(window.getComputedStyle(div).left));</span><br><span class="line"></span><br><span class="line">      function run() &#123;</span><br><span class="line">        createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">          div.style.left &#x3D;</span><br><span class="line">            parseFloat(window.getComputedStyle(div).left) + 2 + &quot;px&quot;;</span><br><span class="line">          &#x2F;&#x2F; console.log(&quot;left&quot;);</span><br><span class="line">          if (parseFloat(div.style.left) &gt;&#x3D; 50) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">            createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">              div.style.width &#x3D;</span><br><span class="line">                parseFloat(window.getComputedStyle(div).width) - 2 + &quot;px&quot;;</span><br><span class="line">              &#x2F;&#x2F; console.log(&quot;width&quot;);</span><br><span class="line">              parseFloat(div.style.width) &lt;&#x3D; 0 &amp;&amp; clearInterval(timer);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><p>下面是图片后设置图片边框，也需要使用回调函数处理，代码嵌套较复杂</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createImage(file, resolve, reject) &#123;</span><br><span class="line">  const img = new Image();</span><br><span class="line">  img.src = file;</span><br><span class="line">  img.onload = () =&gt; &#123;</span><br><span class="line">    resolve(img);</span><br><span class="line">    console.log(&quot;image Loading fulfilled&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.onerror = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;image loading fail&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  document.body.append(img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createImage(&quot;./images/img1.jpg&quot;, (img) =&gt; &#123;</span><br><span class="line">  img.style.border = &quot;5px solid pink&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>下面是异步加载外部<code>JS</code>文件，需要使用回调函数执行，并设置的错误处理的回调函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loadJS(file, resolve, reject) &#123;</span><br><span class="line">  let script = document.createElement(&quot;script&quot;);</span><br><span class="line">  script.src = file;</span><br><span class="line">  script.onload = resolve;</span><br><span class="line">  script.onerror = reject;</span><br><span class="line">  document.body.append(script);</span><br><span class="line">&#125;</span><br><span class="line">loadJS(</span><br><span class="line">  &quot;./js/ashun.js&quot;,</span><br><span class="line">  (script) =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">    title();</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; console.log(`$&#123;err.srcElement.src&#125;  load Reject`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实例中用到的 <code>ashun.js</code> 与 <code>SHUN.js</code> 内容如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ashun.js</span><br><span class="line">function title() &#123;</span><br><span class="line">  console.log(&quot;title method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># SHUN.js</span><br><span class="line">function run() &#123;</span><br><span class="line">  title();</span><br><span class="line">  console.log(&quot;run method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加载多个脚本时需要嵌套使用，下面<code>SHUN.js</code> 依赖 <code>ashun.js</code>，需要先加载<code>ashun.js</code> 后加载<code>SHUN.js</code></p>
<blockquote>
<p>不断的回调函数操作将产生回调地狱，使代码很难维护</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function loadJS(file,resolve,reject)&#123;……&#125;</span><br><span class="line"></span><br><span class="line">   loadJS(</span><br><span class="line">        &quot;/js/ashun.js&quot;,</span><br><span class="line">        (script) =&gt; &#123;</span><br><span class="line">          loadJS(</span><br><span class="line">            &quot;/js/SHUN.js&quot;,</span><br><span class="line">            (script) =&gt; &#123;</span><br><span class="line">              run();</span><br><span class="line">              console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">            &#125;,</span><br><span class="line">            (err) =&gt; &#123;</span><br><span class="line">              console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">          console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><p>使用传统的异步请求也会产生回调嵌套的问题。</p>
<p>比如若要获取商品的详情，就要分为两步</p>
<ol>
<li>先请求商品数据，得到商品的id</li>
<li>根据商品id请求获取对应商品的详情数据。</li>
</ol>
<p>以下接口无实际用途，仅作示例，可自己编写</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url, resolve, reject) &#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.open(&quot;GET&quot;, url);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onload = function() &#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      resolve(JSON.parse(this.response));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&quot;http://localhost:8888/goodslist/data, goods =&gt; &#123;</span><br><span class="line">  ajax(</span><br><span class="line">    `http://localhost:8888/category?id=$&#123;goods[&quot;id&quot;]&#125;`,</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      console.log(response[0]);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="肯德基"><a href="#肯德基" class="headerlink" title="肯德基"></a>肯德基</h4><p>下面是模拟肯德基吃饭的事情，使用 <code>promise</code> 操作异步的方式每个阶段会很清楚</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let kfc = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&quot;肯德基正在为您做餐……&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;餐品已经做好，为您上桌&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">let as = kfc.then((result) =&gt; &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">  console.log(&quot;阿顺收到消息&quot;);</span><br><span class="line">  return &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;我吃了2秒，不辣，张三你可以吃了&quot;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let zhangsan = as.then((msg) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&quot;张三收到阿顺消息：&quot; + msg);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      let msg = &quot;我吃了1秒，真好吃， 李四也尝尝吧&quot;;</span><br><span class="line">      console.log(msg);</span><br><span class="line">      resolve(msg);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">let lisi = zhangsan.then((result) =&gt; &#123;</span><br><span class="line">  console.log(&quot;李四收到消息：&quot; + result);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;李四:我吃了1秒，不错不错&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而使用以往的回调方式，就会让人苦不堪言</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function notice(msg, then) &#123;</span><br><span class="line">  then(msg);</span><br><span class="line">&#125;</span><br><span class="line">function meal() &#123;</span><br><span class="line">  notice(&quot;肯德基厨房开始做饭&quot;, (msg) =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">    notice(&quot;我是肯德基，你的餐已经做好&quot;, (msg) =&gt; &#123;</span><br><span class="line">      console.log(`阿顺收到肯德基消息: $&#123;msg&#125;`);</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        notice(&quot;张三，我吃了两秒了，不辣，你可以吃了&quot;, (msg) =&gt; &#123;</span><br><span class="line">          console.log(`张三收到阿顺消息: $&#123;msg&#125;`);</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            notice(&quot;很好吃，李四也尝尝吧&quot;, (msg) =&gt; &#123;</span><br><span class="line">              console.log(msg);</span><br><span class="line">              notice(&quot;李四收到消息&quot;, (msg) =&gt; &#123;</span><br><span class="line">                console.log(msg);</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                  console.log(&quot;李四:不错不错&quot;);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">meal();</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="异步状态"><a href="#异步状态" class="headerlink" title="异步状态"></a>异步状态</h3><p>Promise 意为承诺，就像我们去饭店用餐，点完餐后服务员会给我们一个票号，如果饭菜做好，我们凭借票号去领餐，这就代表成功状态，若由于其它原因饭菜不能够顺利做好，这就代表拒绝状态。在得到这些结果前，我们一直处于等待的状态。</p>
<ul>
<li>一个 <code>promise</code> 必须有一个 <code>then</code> 方法用于处理状态改变</li>
</ul>
<h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>Promise包含<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>三种状态</p>
<ul>
<li><code>pending</code> 指等待状态，初始化 <code>promise</code> 时的状态</li>
<li><code>resolve</code> 指已经解决，将 <code>promise</code> 状态设置为<code>fulfilled</code></li>
<li><code>reject</code> 指拒绝处理，将 <code>promise</code> 状态设置为<code>rejected</code></li>
<li><code>promise</code> 是生产者，通过 <code>resolve</code> 与 <code>reject</code> 函数告知结果</li>
<li><code>promise</code> 非常适合需要一定执行时间的异步任务</li>
<li>同一Promise状态一旦确定(<code>fufilled\rejected</code>),状态将不可再次更改</li>
</ul>
<p>promise 是队列状态，就像体育中的接力赛，或多米诺骨牌游戏，状态一直向后传递，当然 也可更改其中的任何一个promise的状态，来影响后续的promise。</p>
<p>promise 没有使用 <code>resolve</code> 或 <code>reject</code> 更改状态时，默认状态为 <code>pending</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">); //Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>当更改状态后</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;resolved&gt;: &quot;fulfilled&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; //Error</span><br></pre></td></tr></table></figure>

<p>若一个Promise为<code>rejected</code>状态，却没有处理，系统会发出警示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; &#x2F;&#x2F;Error:Uncaught (in promise) rejected</span><br></pre></td></tr></table></figure>

<p>使用<code>then\catch</code>处理后，不会报错，<code>then\catch</code>这些方法默认也会返回一个新的<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">        new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>按理来说上述Promise已经确认为rejected状态，也经过了<code>then\catch</code>的onRejected回调函数处理，应该返回<code>fufilled</code>状态（<code>then\catch</code>默认返回的promise状态为fufilled），但是为什么返回pending状态呢？</p>
<ul>
<li>console.log是同步代码会立即执行，当日志信息被打印时，promise的状态还未被确认，所以返回pending</li>
<li>将打印放在宏任务队列中，可看到正确结果</li>
</ul>
<p>关于<code>任务队列</code>，下一章节会详细讲解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 &#x3D; promise.catch((err) &#x3D;&gt; err);</span><br><span class="line"></span><br><span class="line">console.log(promise)&#x2F;&#x2F;Promise &#123;&lt;rejected&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">console.log(p1);		&#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(p1);	&#x2F;&#x2F;Promise &#123;&lt;fulfilled&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><code>promise</code> 自创建时，立即执行同步任务，<code>then</code> 会放在异步微任务中执行，需要等同步任务执行后才执行。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;fulfilled&quot;);</span><br><span class="line">  console.log(&quot;阿顺&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">// 阿顺 阿顺特烦恼 fulfilled</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">	resolve(&quot;fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(alert);</span><br><span class="line">alert(&quot;阿顺特烦恼&quot;);</span><br><span class="line">promise.then((_) &#x3D;&gt; alert(&quot;ashuntefannao&quot;));</span><br></pre></td></tr></table></figure>

<p>下例在三秒后将 <code>Promise</code> 状态设置为 <code>fulfilled</code> ，然后执行 <code>then</code> 方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>状态被改变后就不能再修改了，下面先通过<code>resolve</code> 改变为成功状态，表示<code>promise</code> 状态已经完成，就不能使用 <code>reject</code> 更改状态了</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;操作成功&quot;);</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="动态改变"><a href="#动态改变" class="headerlink" title="动态改变"></a>动态改变</h4><p>可以在一个<code>promise</code>中，通过处理另一个<code>promise1</code>，来改变<code>promise</code>的状态。</p>
<p>当在一个<code>promise</code>中，告知状态时传入的是另一个<code>promise1</code>，则后续使用<code>then</code>或其它方法对其进行处理时，处理的已经不再是promise的状态，而是promise1。</p>
<ul>
<li>在p2中确认<code>resolve</code>状态，但在后续的<code>then</code>中却执行了<code>rejected</code>回调函数。</li>
<li>在p2中确认状态时，返回的是p1，那么后续处理的promise将是p1，p2的状态已经无意义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject(&quot;p1 reject&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#96;p2发送resolve状态&#96;);</span><br><span class="line">        resolve(p1);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) &#x3D;&gt; console.log(&#96;p2 处理结果:fulfilled--$&#123;result&#125;&#96;),</span><br><span class="line">        (err) &#x3D;&gt; console.log(&#96;p2 处理结果:rejected--$&#123;err&#125;&#96;)</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>一个promise 需要提供一个then方法访问promise 结果，<code>then</code> 用于当 <code>promise</code> 状态发生改变时的处理，即<code>promise</code>处理异步操作过程，<code>then</code> 用于处理结果。</p>
<p><code>promise</code> 就像 <code>饭馆</code> 中的厨房，<code>then</code> 就是我们用户，如果餐做好了即 <code>fulfilled</code> ，做不了拒绝即<code>rejected</code> 状态。那么 then 就要对不同状态处理。</p>
<ul>
<li>then 方法 <strong>必须</strong> 返回 promise，用户返回或系统自动返回</li>
<li>第一个函数在<code>resolved</code> 状态时执行，即使用<code>resolve</code>确认完成状态时，执行<code>then</code>第一个callback处理成功状态</li>
<li>第二个函数在<code>rejected</code>状态时执行，即使用<code>reject</code>确认拒绝状态时，执行第二个callback处理失败状态，该函数是可选的</li>
<li>两个callback都接收 <code>promise</code> 确认状态时传入的值做为参数</li>
<li>也可以使用<code>catch</code> 来处理失败的状态</li>
<li>如果在 <code>then</code> 中手动返回 <code>promise</code> ，下一个<code>then</code> 会在上一个then返回的<code>promise</code> 状态改变后执行</li>
</ul>
<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><p>then的语法如下，onFulfilled 函数处理 <code>fulfilled</code> 状态， onRejected函数处理 <code>rejected</code> 状态</p>
<ul>
<li>onFulfilled 或 onRejected <code>不是函数将被忽略</code></li>
<li>两个函数只会被调用一次</li>
<li>onFulfilled 在 promise 执行成功时调用</li>
<li>onRejected 在 promise 执行拒绝时调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><code>then</code> 会在 <code>promise</code> 确认状态后执行，<code>then</code> 第一个callback在 <code>resolve</code>成功状态执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    console.log(`解决：$&#123;value&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    console.log(`拒绝:$&#123;reason&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 中第二个参数在失败状态执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果只关心成功则不需要传递 <code>then</code> 的第二个参数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果只关心失败时状态，<code>then</code> 的第一个参数传递 <code>null</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>promise 确认状态后转入的参数，会传入到<code>then</code>对应callback的参数中，如果then没有可处理函数，会一直向后传递</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&quot;rejected&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(</span><br><span class="line">  null,</span><br><span class="line">  f =&gt; console.log(f)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;resolve&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then();</span><br><span class="line">p2.then().then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;reject&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then(() &#x3D;&gt; &#123;&#125;);</span><br><span class="line">p2.then(null, null).then(null, reject &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><ul>
<li><code>then\catch</code>等promise的方法，是对上一个promise状态的处理，而使用<code>then/catch</code>后 它们本身又会默认返回一个新的promise，且状态为<code>fulfilled</code>,所以then才可不断地链式调用。</li>
<li>当然，也可以在<code>then\catch</code>中手动返回自定义的promise，可通过这个promise，改变当前then的状态</li>
</ul>
<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>， then 默认返回的 promise 状态是 fulfilled</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       reject(&quot;promise state rejected&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(null, (err) &#x3D;&gt; console.log(err))</span><br><span class="line">       .then((_) &#x3D;&gt; console.log(&quot;then默认状态为fulfilled&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>，不要认为上一个 promise状态会影响以后then返回的状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise(resolve =&gt; &#123;</span><br><span class="line">  rejected(&quot;p1 rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = p1.then(null,rej=&gt;console.log(reg));</span><br><span class="line">p2.then(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">console.log(p2); // Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">  console.log(p2); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 是对上个promise 的处理，每个 <code>then</code> 又会返回一个promise，默认传递 <code>fulfilled</code>状态，所以才可以不断地链式调用then处理promise。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line"># 执行结果如下</span><br><span class="line">  rejected</span><br><span class="line">  fulfilled</span><br><span class="line">  fulfilled</span><br></pre></td></tr></table></figure>

<p>如果内部手动返回 <code>promise</code> 时，后续处理的便是该 <code>promise</code>，即该promise可以改变当前then的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">         reject(&quot;promise state rejected&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">       promise</span><br><span class="line">         .then(</span><br><span class="line">           (result) &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">           (reject) &#x3D;&gt; console.log(reject)</span><br><span class="line">         )</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">         )</span><br><span class="line">         .then((res) &#x3D;&gt; &#123;</span><br><span class="line">           console.log(&quot;fufilled&quot;);</span><br><span class="line">           return Promise.reject(&quot;手动返回的promise，状态为rejected&quot;);</span><br><span class="line">         &#125;)</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">         );</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果如下</span><br><span class="line"> &quot;promise state rejected&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;手动返回的promise，状态为rejected&quot;</span><br></pre></td></tr></table></figure>

<p>若手动返回的不是Promise，则下一个then处理的还是 上一个then默认返回的Promise，状态为fulfilled。</p>
<ul>
<li>但是下一个then对应的处理函数，会接受上一个then返回的参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">        	console.log(rej)</span><br><span class="line">          return &quot;p1 rejected&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; p1.then((res) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#96;p2 fulfilled \n$&#123;res&#125;&#96;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> # 执行结果如下</span><br><span class="line">  &quot;promise state rejected&quot;</span><br><span class="line">  &quot;p2 fulfilled</span><br><span class="line">   p1 rejected&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(v &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个promise&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>then是处理上一个Promise的结果，只有上一个promise确认了状态，then才会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                resolve(&quot;resolved&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; console.log(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>循环调用</strong></p>
<p>如果 <code>then</code> 的返回值与所处理的 <code>promise</code> 相同将禁止执行，（避免陷入死循环）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then(() =&gt; &#123;</span><br><span class="line">  return p2;</span><br><span class="line">&#125;); // TypeError: Chaining cycle detected for promise</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a>其它类型</h4><p><strong>then able</strong>：具有then能力的类型</p>
<p>Promise 解决过程是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<ul>
<li>也就是说，如果<code>x</code>具有<code>then</code>方法，那么将会被系统认为是<code>类promise</code>的结构</li>
<li>若在Promise中返回<code>x</code>,则使用then处理Promise时，系统会尝试让原Promise的then方法接收<code>x</code>中then方法的状态</li>
</ul>
<p>包含then方法的Object可以当作promise使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(result);</span><br><span class="line">          return &#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                reject(&quot; p1 rejected&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">        p1.then(</span><br><span class="line">          (mgs) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(mgs);</span><br><span class="line">          &#125;,</span><br><span class="line">          (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Goods &#123;</span><br><span class="line">  constructor(id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goods?id&#x3D;$&#123;this.id&#125;&#96;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goodsList?type&#x3D;new&#96;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(goods &#x3D;&gt; &#123;</span><br><span class="line">  return new Goods(goods.id);</span><br><span class="line">&#125;)</span><br><span class="line">.then(category &#x3D;&gt; &#123;</span><br><span class="line">  console.log(category);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然也可以是类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(</span><br><span class="line">    class &#123;</span><br><span class="line">      static then(resolve, reject) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          resolve(&quot;解决状态&quot;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;).then(</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`fulfilled: $&#123;v&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`rejected: $&#123;v&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果对象中的 then 不是函数，则将对象做为值传递</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    then: &quot;阿顺特烦恼&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  console.log(v); //&#123;then: &quot;阿顺特烦恼&quot;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>下面使用未定义的变量同样会触发失败状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  as;</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; console.log(value),</span><br><span class="line">  reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果 onFulfilled 或 onRejected 抛出异常，则 p2 拒绝执行并返回拒因</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then();</span><br><span class="line">p2.then().then(null, resolve =&gt; &#123;</span><br><span class="line">  console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>catch(err=&gt;&#123;&#125;)</code>是用来接收Promise拒绝状态的。经catch处理后，默认返回的promise状态也为fulfilled</li>
<li><code>catch</code>相当于<code>then(null,onReject)</code></li>
<li>若某个promise已被<code>then(null,onReject)</code>处理，则<code>catch</code>将不会接收该拒绝状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          console.log(p1);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected,阿顺特烦恼</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err))</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected</span><br></pre></td></tr></table></figure>

<ul>
<li>建议使用 <code>catch</code> 处理错误</li>
<li>将 <code>catch</code> 放在最后面用于统一处理前面发生的错误</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;Notice: Promise Exception&quot;));</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.error(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 可以捕获之前所有 <code>promise</code> 的错误，所以建议将 <code>catch</code> 放在最后。下例中 <code>catch</code> 也可以捕获到了第一个 <code>then</code> 返回 的 <code>promise</code> 的错误。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;err from .then &quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>错误是冒泡的操作的，下面没有任何一个<code>then</code> 定义第二个函数参数<code>onRejected</code>，将一直冒泡到 <code>catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获对 <code>then</code> 抛出的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;这是then 抛出的错误&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;33&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获其他错误，下面在 <code>then</code> 中使用了未定义的变量，将会把错误抛出到 <code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg &#x3D;&gt; &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString()+&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以将上面的理解为如下代码，可以理解为内部自动执行 <code>try...catch</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但像下面的在<code>异步宏任务</code>中 <code>throw new Error</code> 将不会触发 <code>catch</code>，而使用系统错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg + &quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>catch</code> 中发生的错误也会抛给最近的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  ashun();</span><br><span class="line">&#125;)</span><br><span class="line">.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="定制错误"><a href="#定制错误" class="headerlink" title="定制错误"></a>定制错误</h4><p>可以根据不同的错误类型进行定制操作，下面将<code>url格式错误</code>与<code>参数错误</code>分别进行了处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class ParamError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;ParamError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;HttpError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if (!/^http/.test(url)) &#123;</span><br><span class="line">      throw new HttpError(&quot;请求地址格式错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else if (this.status == 404) &#123;</span><br><span class="line">        // throw new ParamError(&quot;用户不存在&quot;);</span><br><span class="line">        reject(new ParamError(&quot;用户不存在&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(&quot;加载失败&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(`http://localhost:8083?name=阿顺特烦恼`)</span><br><span class="line">.then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  if (error instanceof ParamError) &#123;</span><br><span class="line">    console.log(`参数错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  if (error instanceof HttpError) &#123;</span><br><span class="line">    alert(`url格式错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>无论状态是<code>resolve</code> 或 <code>reject</code> 都会执行此动作，<code>finally</code> 与状态无关。</p>
<ul>
<li>根据finally的特性，通常在其中做一些公共的操作，不论状态，都会执行的操作。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;reject&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve/reject状态都会执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>finally</code> 处理加载状态，当图片加载完成时移除加载图标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      .result &#123;</span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;loading&quot;&gt;loading...&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;result&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createImage(file) &#123;</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          let img &#x3D; new Image();</span><br><span class="line">          img.src &#x3D; file;</span><br><span class="line">          img.onload &#x3D; () &#x3D;&gt; resolve(img);</span><br><span class="line">          img.onerror &#x3D; () &#x3D;&gt; reject(&quot;加载失败&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        createImage(&quot;.&#x2F;images&#x2F;img1.jpg&quot;)</span><br><span class="line">          .then((img) &#x3D;&gt; &#123;</span><br><span class="line">            document.body.append(img);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; &quot;加载成功&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; err;</span><br><span class="line">          &#125;)</span><br><span class="line">          .finally(() &#x3D;&gt; &#123;</span><br><span class="line">            document.querySelector(&quot;div&quot;).style.display &#x3D; &quot;none&quot;;</span><br><span class="line">            document.querySelector(&quot;.result&quot;).style.display &#x3D; &quot;block&quot;;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><h5 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h5><p>下面是将 <code>ajax</code> 请求使用 <code>promise</code> 处理，代码结构清晰了很多</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&quot;http://localhost:8083/goodsList?name=new&quot;)</span><br><span class="line">.then(goods =&gt;ajax(`http://localhost:8083/category?id=$&#123;goods[&quot;id&quot;]&#125;`))</span><br><span class="line">.then(data =&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function loadJS(file) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">            script.src &#x3D; file;</span><br><span class="line">            document.body.append(script);</span><br><span class="line">            script.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              resolve(script);</span><br><span class="line">            &#125;;</span><br><span class="line">            script.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              reject(script);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        loadJS(&quot;.&#x2F;js&#x2F;ashun.js&quot;)</span><br><span class="line">          .then((script) &#x3D;&gt; &#123;</span><br><span class="line">            title();</span><br><span class="line">            console.log(&quot;ashun.js finishLaod&quot;);</span><br><span class="line">            return script;</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((ashunjs) &#x3D;&gt; &#123;</span><br><span class="line">            return loadJS(&quot;.&#x2F;js&#x2F;SHUN.js&quot;).then((script) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(&quot;SHUN.js finishLaod&quot;);</span><br><span class="line">              run();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((script) &#x3D;&gt; console.log(&#96;$&#123;script.src&#125;：加载失败&#96;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>下面是封装的<code>timeout</code> 函数，使用定时器操作更加方便</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function timeout(times) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, times);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(3000)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;3秒后执行&quot;);</span><br><span class="line">    return timeout(1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;执行上一步的promise后1秒执行&quot;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>使用Promise封装 <code>setInterval</code> 定时器并实现动画效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background: pink;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        function interval(callback, delay &#x3D; 5) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">              callback(id, resolve);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line"></span><br><span class="line">        function run() &#123;</span><br><span class="line">          const step &#x3D; 2;</span><br><span class="line">          interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">            let left &#x3D; parseFloat(window.getComputedStyle(div).left);</span><br><span class="line">            if (left &gt;&#x3D; 200) &#123;</span><br><span class="line">              clearInterval(timer);</span><br><span class="line">              resolve(&quot;left end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            div.style.left &#x3D; left + step + &quot;px&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(result);</span><br><span class="line">              return interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">                let width &#x3D; parseFloat(window.getComputedStyle(div).width);</span><br><span class="line">                if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">                  clearInterval(timer);</span><br><span class="line">                  resolve(&quot;width end&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                div.style.width &#x3D; width - step + &quot;px&quot;;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><ul>
<li>每个 <code>then</code> 都是一个promise，<code>then</code>会默认返回一个promise，且状态为fulfilled。</li>
<li>如果在 <code>then</code> 中手动返回一个新<code>promsie</code>，只当这个新的<code>promise</code> 确认状态后，才会继承执行下一个 <code>then</code></li>
</ul>
<h5 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h5><p>下面是对同一个 <code>promise</code> 分别使用不同的 <code>then</code> 进行操作 ，每个<code>then</code> 都得到了同一个promise 结果，这不是链式操作，实际使用意义不大。</p>
<img src="Promise.assets/Promise_then_1.png" alt="Promise_then_1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashuntefannao</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>promise</code> 中的 <code>then</code> 方法可以链式调用，<code>then</code> 方法的返回值会传递到下一个<code>then</code> 方法对应的处理函数中。</p>
<ul>
<li><code>then</code> 会返回一个<code>promise</code> ，所以如果有多个<code>then</code> 时会连续执行</li>
<li><code>then</code> 返回的值会做为当前<code>promise</code> 的结果</li>
</ul>
<p>下面是链式操作的 <code>then</code>，即始没有 <code>return</code> 也是会执行，因为每个<code>then</code> 默认会返回<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">    return title;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun-Ashuntefannao</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 方法可以返回一个新的<code>promise</code> 对象，等返回的<code>promise</code> 确认状态后，才会执行后面的 <code>then</code>。后面的<code>then</code> 方法就是对新返回的<code>promise</code> 状态的处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;第一个promise&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;第二个promise&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Promise类还提供一些静态方法，能够更好的处理异步操作。</p>
<ul>
<li>这些静态方法参数中若传入<code>非Promise</code>数据类型，则会将其转化为<code>Promise</code>,除了<code>reject</code>静态方法会默认将其转化为<code>Promise.resolve</code>,其余静态方法都会将其转化为<code>Promise.resolve</code>,数据本身作为返回结果。</li>
</ul>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p>使用 <code>promise.resolve(msg)</code> 方法可以快速的返回一个状态为resolve的promise对象。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Promise.resolve(&quot;fulfilled&quot;));	//Promise &#123;&lt;fulfilled&gt;: &quot;fulfilled&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state: rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        promise</span><br><span class="line">          .then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(rej);</span><br><span class="line">            return Promise.resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若传入值为promise，后续then处理的是传入的promsie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(Promise.reject(&quot;阿顺特烦恼&quot;)).catch((rej) &#x3D;&gt;console.log(rej));</span><br></pre></td></tr></table></figure>

<p>下面将请求结果缓存，如果再次请求时直接返回带值的 <code>promise</code></p>
<ul>
<li>为了演示使用了定时器，你也可以在后台设置延迟响应</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function query(name) &#123;</span><br><span class="line">  const cache = query.cache || (query.cache = new Map());</span><br><span class="line">  if (cache.has(name)) &#123;</span><br><span class="line">    console.log(&quot;走缓存了&quot;);</span><br><span class="line">    return Promise.resolve(cache.get(name));</span><br><span class="line">  &#125;</span><br><span class="line">  return ajax(`http://localhost:8083/users?name=$&#123;name&#125;`).then(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      cache.set(name, response);</span><br><span class="line">      console.log(&quot;没走缓存&quot;);</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>如果是 <code>then able</code> (具有then能力，类似promise)对象，会将对象包装成promise处理，这与其他promise处理方式一样的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const as = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.resolve(as).then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.resolve</code>,数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getName() &#123;</span><br><span class="line">  return &quot;ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Promise.resolve(getName).then((result) &#x3D;&gt; console.log(result()));</span><br><span class="line">&#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>



<h4 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h4><p>和 <code>Promise.resolve</code> 类似，<code>reject</code> 生成一个拒绝状态的<code>promise</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&quot;fail&quot;).catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Project.reject</code> 设置状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  if (v != &quot;Ashuntefannao&quot;) return Promise.reject(new Error(&quot;not Ashuntefannao&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.reject</code>数据本身作为<code>Promise.reject</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;name:&quot;Ashun&quot;&#125;;</span><br><span class="line">Promise.reject(obj).catch((reason) &#x3D;&gt; console.log(reason.name));</span><br><span class="line">&#x2F;&#x2F;Ashun</span><br></pre></td></tr></table></figure>



<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>使用<code>Promise.all(promiseArr)</code> 方法可以同时执行多个异步操作，比如页面加载时同进获取课程列表与推荐课程。</p>
<ul>
<li>任何一个 <code>Promise</code> 执行失败就会调用 <code>catch</code>方法</li>
<li>任何一个<code>Promise</code>没有确认状态，则all默认返回的promise状态也为pending，也就不会执行后续的then</li>
<li>适用于一次发送多个异步操作</li>
<li>参数必须是可迭代类型，如Array/Set</li>
<li>成功后返回包含 <code>promise</code> 结果的有序数组</li>
<li>若传入<code>非Promise</code>数据，则将其自动转化为<code>Promise.resolve</code>，数据本身作为返回值</li>
</ul>
<p>下例中当 <code>p1、p2</code> 两个 Promise 状态都为 <code>fulfilled</code> 时，p3状态才为<code>fulfilled</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 = new Promise((resolve) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p2 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p3 = Promise.all([p1, p2]).then(</span><br><span class="line">          (result) =&gt; console.log(result),</span><br><span class="line">          (err) =&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>若其中有一个promise状态为reject，则将调用<code>Promise.all()</code>后续<code>then</code>中的<code>onReject</code>，或<code>catch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;)</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2]).then(</span><br><span class="line">          (result) &#x3D;&gt; console.log(result),</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">…………</span><br><span class="line">let p3 &#x3D; Promise.all([p1, p2]).catch(</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>若某个状态为<code>rejected</code>的Promise已经被自身的<code>then</code>处理 , 那么该Promise最后返回的状态是<code>fulfilled</code>,(<strong>then默认返回状态为fulfilled的Promise</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;).then(null, (err) &#x3D;&gt; err);</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2])</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(&quot;有promise状态为rejected&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F; [&quot;p1 state: fulfilled&quot;, &quot;p2 state: reject&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据用户名获取用户，有任何一个用户获取不到时 <code>promise.all</code> 状态失败，执行 <code>catch</code> 方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [&quot;阿顺&quot;, &quot;张三&quot;].map(name =&gt; &#123;</span><br><span class="line">  return ajax(`$&#123;api&#125;/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>可以将其他<code>非promise</code> 数据添加到 <code>all</code> 中，它将被处理成 <code>Promise.resolve</code>，数据本身会被当做<code>Promise.resolve</code>的返回值</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let getName = () =&gt; &quot;Ashun&quot;;</span><br><span class="line">        let Age = 18;</span><br><span class="line">        let promise = new Promise((resolve) =&gt; resolve(&quot;阿顺特烦恼&quot;));</span><br><span class="line">        Promise.all([getName, Age, promise]).then((result) =&gt;</span><br><span class="line">          console.log(result)</span><br><span class="line">        );</span><br><span class="line">        // [ƒ, 18, &quot;阿顺特烦恼&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h4><p><code>Promise.allSettled(PromsieArr)</code>，<strong>会将所有的Promsie视为已解决状态</strong>，会<code>忽略拒绝状态</code>的Promise，</p>
<p>拒绝状态的Promise信息，也会返回到最终的结果中。</p>
<ul>
<li>返回包含Promise状态和结果的有序数组</li>
<li><code>[&#123;status:resolve/reject,value/reason&#125;,&#123;…&#125;]</code></li>
</ul>
<p>下面的p2 返回状态为 <code>rejected</code> ，但<code>promise.allSettled</code> 不关心，<code>promise.allSettled</code>始终将自身状态设置为 <code>fulfilled</code> 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          resolve(&quot;p1 resolved&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          reject(&quot;p2 rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Promise.allSettled([p1, p2]).then((msg) =&gt; &#123;</span><br><span class="line">          console.log(msg);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line"> [</span><br><span class="line">	 &#123;status: &quot;fulfilled&quot;, value: &quot;p1 resolve&quot;&#125;,</span><br><span class="line">	 &#123;status: &quot;rejected&quot;, reason: &quot;p2 rejected&quot;&#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<p>下面是获取用户信息，但不关注某个用户是否获取不成功</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=阿顺`),</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=张三`)</span><br><span class="line">];</span><br><span class="line">Promise.allSettled(promises).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中若传入非promise数据类型，内部会转化为<code>Promise.resolve</code>,数据本身作为返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">				];</span><br><span class="line">Promise.allSettled(arr).then((result) &#x3D;&gt; console.log(result));</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">[</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: ƒ&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: 18&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>使用<code>Promise.race(promiseArr)</code> 能够处理容错异步，且返回最快确定状态的Promise结果，和<code>race</code>单词一样哪个Promise快用哪个，哪个先返回用哪个。</p>
<ul>
<li>以最快返回的promise为准</li>
<li>如果最快返加的状态为<code>rejected</code> 那整个<code>Promise.rece</code>状态为<code>rejected</code>执行cache</li>
<li>如果参数不是promise，内部将自动转为<code>Promise.resolve</code></li>
</ul>
<p>下例体现<code>Promise.rece</code>的特性，哪个Promise最先确定状态，就返回谁的处理结果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第一个Promise&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个异步&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([p1, p2])</span><br><span class="line">.then(results =&gt; &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// &quot;第二个异步&quot;</span><br></pre></td></tr></table></figure>

<p>可用其设置请求最长相应时间，下例：若请求在2秒内没有返回结果，则<code>promise.race</code> 状态失败,将会执行<code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const api &#x3D; &quot;http:&#x2F;&#x2F;localhost:8083&quot;;</span><br><span class="line">const promises &#x3D; [</span><br><span class="line">  ajax(&#96;$&#123;api&#125;&#x2F;users.php?name&#x3D;阿顺&#96;),</span><br><span class="line">  new Promise((a, b) &#x3D;&gt;</span><br><span class="line">    setTimeout(() &#x3D;&gt; b(new Error(&quot;request fail&quot;)), 2000)</span><br><span class="line">  )</span><br><span class="line">];</span><br><span class="line">Promise.race(promises)</span><br><span class="line">.then(response &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promises &#x3D; [</span><br><span class="line">          new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              resolve(&quot;请求成功&quot;);</span><br><span class="line">            &#125;, 1200);</span><br><span class="line">          &#125;),</span><br><span class="line">          new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              reject(&quot;请求超时&quot;);</span><br><span class="line">            &#125;, 1100);</span><br><span class="line">          &#125;),</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(promises)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((reason) &#x3D;&gt; console.log(reason));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数不是promise，内部将自动转为<code>Promise.resolve</code>,且数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(arr).then((result) &#x3D;&gt; console.log(result())); &#x2F;&#x2F;ashun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>如果在<code>then</code>中手动返回<code>promise</code> 时，后面的<code>then</code> 就是对返回的 <code>promise</code> 的处理</li>
<li>通过链式调用then，不断处理返回的Promsie，解决任务队列中的任务。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let promise = Promise.resolve();</span><br><span class="line">let p1 = promise.then(() =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p1`);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((a, b) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p2`);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; Promise.resolve();</span><br><span class="line">        promise &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;第一个then&quot;);</span><br><span class="line">            resolve(2);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(3);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(4);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Array.map</code> 构建的队列，有以下几点需要说明</p>
<ul>
<li><code>then</code> 内部返回的 <code>Promise</code> 更改外部的 <code>promise</code> 变量</li>
<li>为了让任务继续下去，执行完任务需要将 <code>promise</code> 状态修改为 <code>fulfilled</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          let promise = Promise.resolve();</span><br><span class="line">          tasks.map((val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line">shun-1</span><br><span class="line">第1个任务执行完毕，第2个任务开始执行</span><br><span class="line">Ashun-2</span><br><span class="line">第2个任务执行完毕，第3个任务开始执行</span><br><span class="line">Ashuntefannao-3</span><br></pre></td></tr></table></figure>

<p>下面再来通过 <code>reduce</code> 来实现队列</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          tasks.reduce((promise, val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">          &#125;, Promise.resolve());</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="高可用封装"><a href="#高可用封装" class="headerlink" title="高可用封装"></a>高可用封装</h4><p>上例中处理是在队列中完成，不方便业务定制，下面将Promise处理在剥离到外部</p>
<p><strong>后台请求处理类</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default function(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列处理类</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function(promises) &#123;</span><br><span class="line">  promises.reduce((promise, next) =&gt; promise.then(next), Promise.resolve())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后台脚本</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$users = [</span><br><span class="line">    1 =&gt; &quot;小明&quot;,</span><br><span class="line">    2 =&gt; &quot;李四&quot;,</span><br><span class="line">    3 =&gt; &quot;张三&quot;</span><br><span class="line">];</span><br><span class="line">sleep(1);</span><br><span class="line">echo $users[$_GET[&#x27;id&#x27;]];</span><br></pre></td></tr></table></figure>

<p><strong>使用队列</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import queue from &#x27;./queue.js&#x27;</span><br><span class="line">  import axios from &#x27;./axios.js&#x27;</span><br><span class="line">  queue(</span><br><span class="line">    [1, 2, 3].map(v =&gt; () =&gt;</span><br><span class="line">      axios(`user.php?id=$&#123;v&#125;`).then(user =&gt; console.log(user))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p> <code>async/await</code> 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。</p>
<ul>
<li><code>async/await</code> 本质还是promise，只是更简洁的语法糖书写</li>
<li><code>async/await</code> 使用更清晰的结构来替换 promise.then/catch 的方式</li>
<li><code>async/await</code>能够让异步代码，以<strong>同步的形式</strong>按顺序执行</li>
<li><code>async</code>声明的函数，会自动返回一个Promise。</li>
<li><code>await</code>必须在<code>async</code>声明的函数中使用。</li>
</ul>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>下面在 <code>fun</code> 函数前加上async，函数将默认返回一个状态为fulfilled的promise，函数体中使用return返回的数据，可以在后续的then中接收到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">				return &quot;阿顺特烦恼&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">fun().then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>

<p>若要按顺序处理多个异步代码块，使用传统的<code>promise.then/catch</code>在整个代码结构上，不如使用<code>async/await</code>清晰。</p>
<p>下例通过处理相同的问题，进行对比</p>
<p>使用传统<code>Promise</code>处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function promise(text) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(text || &quot;第一个then&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        promise()</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第二个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第三个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>async/await</code>处理可观察到，代码是按照同步形式执行的，结构更加清晰，代码量也减少了许多。</p>
<ul>
<li><code>await</code>相当于<code>then</code>，能够传递Promise的返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        async function promise(text) &#123;</span><br><span class="line">          return text || &quot;第一个then&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result1 &#x3D; await promise();</span><br><span class="line">          console.log(result1);</span><br><span class="line">          let result2 &#x3D; await promise(&quot;第二个then&quot;);</span><br><span class="line">          console.log(result2);</span><br><span class="line">          let result3 &#x3D; await promise(&quot;第三个then&quot;);</span><br><span class="line">          console.log(result3);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code>关键词后面紧跟Promise，使用 <code>await</code> 关键词，可以接收所处理的Promise的返回值，并且等待该Promise确定状态后，才可执行后面的代码。</p>
<ul>
<li><code>await</code> 后面一般是promise，如果不是直接返回</li>
<li><code>await</code> 必须放在 async 定义的函数中使用</li>
<li><code>await</code> 用于替代 <code>then</code> 使编码更优雅</li>
</ul>
<p>下例会在 await 这行等待promise执行，直到 promise 确认状态后才执行后续代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">  const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;Ashuntefannao&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">  let result = await promise;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>我们知道：在then中不能够返回所处理的Promise本身，会产生死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; Promise.resolve().then((_) &#x3D;&gt; p1);</span><br></pre></td></tr></table></figure>

<p>同理在<code>async</code>声明的函数中，也不能使用<code>await</code>处理函数本身。</p>
<ul>
<li>等待fun返回的promise确认状态，而fun在调用时，又会等待自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">	await fun();</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>下面是请求后台获取用户课程成绩的示例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function user() &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将操作放在立即执行函数中完成</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>下面是使用async 设置定时器，并间隔时间来输出内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function sleep(ms = 2000) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function run() &#123;</span><br><span class="line">  for (const value of [&quot;阿顺特烦恼&quot;, &quot;Ashun&quot;]) &#123;</span><br><span class="line">    await sleep();</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>



<h4 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h4><p>下面是模拟请求后台查看进度，进度条展示的效果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 0px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">        color: white;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#123;			</span><br><span class="line"> 				//随机产生小于3秒的请求时间。</span><br><span class="line">        function randomTime() &#123;</span><br><span class="line">          let max = 3;</span><br><span class="line">          let min = 1;</span><br><span class="line">          let multiple = Math.floor(Math.random() * (1000 - 100 + 1) + 100);</span><br><span class="line">          return Math.floor(Math.random() * (max - min + 1) + min) * multiple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">				//模拟请求延时。</span><br><span class="line">        async function request() &#123;</span><br><span class="line">          return new Promise((resolve) =&gt; setTimeout(resolve, randomTime()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div = document.querySelector(&quot;.loading&quot;);</span><br><span class="line">        //请求任务队列</span><br><span class="line">        let requsets = [request, request, request, request, request];</span><br><span class="line">        let sum = 0;</span><br><span class="line">        requsets.map(async (req) =&gt; &#123;</span><br><span class="line">          await req();</span><br><span class="line">          let percent = ++sum / requsets.length;</span><br><span class="line">          div.style.width = percent * 200 + &quot;px&quot;;</span><br><span class="line">          if (percent == 1) &#123;</span><br><span class="line">            div.innerHTML = &quot;加载完毕&quot;;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            div.innerHTML = percent * 100 + &quot;%&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="then-able"><a href="#then-able" class="headerlink" title="then able"></a>then able</h4><p>和 Promise 一样，await 也可以操作<code>then able</code> 对象</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    let user = ajax(`http://localhost:8083/user?name=$&#123;this.name&#125;`);</span><br><span class="line">    resolve(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async function get() &#123;</span><br><span class="line">  let user = await new User(&quot;阿顺&quot;);</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result &#x3D; await user;</span><br><span class="line">          console.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象、类中的方法，也可以用<code>async/await</code>处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        let obj &#x3D; &#123;</span><br><span class="line">          async getName() &#123;</span><br><span class="line">            let result &#x3D; await user;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    let user &#x3D; await ajax(</span><br><span class="line">      &#96;http:&#x2F;&#x2F;localhost:8083&#x2F;users?name&#x3D;$&#123;name&#125;&#96;</span><br><span class="line">    );</span><br><span class="line">    user.name +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new User().get(&quot;阿顺&quot;).then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="声明形式"><a href="#声明形式" class="headerlink" title="声明形式"></a>声明形式</h4><p>函数声明</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let get = async function(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对象方法声明</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">  	return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">as.get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>立即执行函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=&quot;阿顺&quot;`);</span><br><span class="line">  let lessons = await ajax( </span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>类方法中的使用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User().get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>async 内部发生错误，会将返回的promise状态置为rejected 状态，所以可以使用<code>catch</code> 来处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function as() &#123;</span><br><span class="line">  console.log(shun);</span><br><span class="line">&#125;</span><br><span class="line">as().catch(error =&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是异步请求数据不存在时的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(&quot;阿顺小哥&quot;).catch(error =&gt; &#123;</span><br><span class="line">  alert(&quot;用户不存在&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若await后的<code>promise</code> 被拒绝，并且没有使用<code>then\catch</code>处理，将抛出异常，可以使用 <code>try...catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let users = [&quot;阿顺&quot;, &quot;Ashun&quot;, &quot;shun&quot;];</span><br><span class="line"></span><br><span class="line">        async function getUser(name) &#123;</span><br><span class="line">        	let test = users.includes(name);</span><br><span class="line">          try &#123;</span><br><span class="line">            await new Promise((res, rej) =&gt; &#123;</span><br><span class="line">              console.log(test);</span><br><span class="line">              test ? res(test) : rej(`$&#123;name&#125; not find`);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getUser(&quot;阿顺A&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 await 时当前面的出现失败且未处理，后面的将不可以执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>如果对前一个错误进行了处理，后面的 await 可以继续执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;).catch(e =&gt; console.log(e));</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>try...catch</code> 特性忽略不必要的错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;&#125;</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以将多个 await 放在 try…catch 中统一处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function get(type) &#123;</span><br><span class="line">  const host = &quot;http://localhost:8083/&quot;</span><br><span class="line">  try &#123;</span><br><span class="line">    const goods = await ajax(`$&#123;host&#125;/goodsList?type=$&#123;type&#125;`);</span><br><span class="line">    const category = await ajax(`$&#123;host&#125;/category?id=$&#123;goods.id&#125;`);</span><br><span class="line">    console.log(lessons);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(&quot;商品不存在&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;new&quot;);</span><br></pre></td></tr></table></figure>



<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><p>有时需要多个await 同时执行，有以下几种方法处理，下面多个await 将产生等待</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">async function p1() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function p2() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashun&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await p1();</span><br><span class="line">  await p2();</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>使用 <code>Promise.all()</code> 处理多个promise并行执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await Promise.all([p1(), p2()]);</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>先执行返回promise，再使用await处理结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promises() &#123;</span><br><span class="line">  let a1 = p1();</span><br><span class="line">  let a2 = p2();</span><br><span class="line">  await a1;</span><br><span class="line">  await a2;</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="阿顺特烦恼"
      src="/images/headPortrait.jpg">
  <p class="site-author-name" itemprop="name">阿顺特烦恼</p>
  <div class="site-description" itemprop="description">阿顺特烦恼,希望大家没有烦恼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/astfn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;astfn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/ashuntefannao" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;ashuntefannao" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Gitee</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fab fa-adn"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿顺特烦恼</span>
</div>
  <div class="powered-by">
     <!-- 外部引入 访客计数器-->
      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span><br/>
      
      <strong style="color:#ccc">ASHUNTEFANNAO</strong><br/>
      <span style="color:#ccc;font-size:13px">博客文章版权归作者 阿顺特烦恼 所有</span><br/>
      <span style="color:#ccc;font-size:13px">欢迎转载 但未经作者同意 必须保留此段声明</span><br/>
  </div>
  
  <!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  -->



<!-- 外部脚本 -->

<!--以下部分脚本依赖jquery-->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<!--浏览器搞笑标题 //实测会影响图标-->
	<!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js"></script>-->

	<!-- 🌸飘落 -->
		<!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js"></script>-->

	<!-- 雪花飘落 -->
	  <!-- <script async src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js"></script> -->

	<!-- // 文字 -->
    <!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js"></script>-->

<!-- // 烟花 -->
	<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
	<script async type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
	<script async src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/fireworks.js"></script>

<!-- // 星星跟随坠落 -->
	<script async src="https://cdn.jsdelivr.net/gh/cungudafa/cdn@2.1.2/js/cursor.js"></script>

<!-- // 连线 -->
	<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>
	<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

<!-- 样式二（飘动的彩带） -->
	<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js" type="text/javascript"></script>

<!--背景切换-->
  <!--<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>-->



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
