<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/Ashun.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/Ashun.ico">
  <link rel="mask-icon" href="/images/favicons/Ashun.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#34495e","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阿顺特烦恼,希望大家没有烦恼">
<meta property="og:type" content="website">
<meta property="og:title" content="AshunBlog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="AshunBlog">
<meta property="og:description" content="阿顺特烦恼,希望大家没有烦恼">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="阿顺特烦恼">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>AshunBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AshunBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习,天天Code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/astfn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/04/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%94%9F%E6%B4%BB/%E5%85%B3%E4%BA%8E%E6%88%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span>
            <a href="/2021/05/04/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%94%9F%E6%B4%BB/%E5%85%B3%E4%BA%8E%E6%88%91/" class="post-title-link" itemprop="url">关于我</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-04 15:43:09 / 修改时间：15:55:08" itemprop="dateCreated datePublished" datetime="2021-05-04T15:43:09+08:00">2021-05-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
           <style>
      span.ashun {
        color: #d35400;
        font-weight: bold;
      }
      .active {
        display: inline-block;
        animation: active 0.8s 2 linear;
        letter-spacing: 0.4rem;
      }
      @keyframes active {
        25% {
          color: #ecf0f1;
          transform: scale(1.2);
        }
        40% {
          color: #9b59b6;
          transform: scale(1.5);
        }
        50% {
          color: #546de5;
          transform: scale(2);
        }
        60% {
          color: #e67e22;
          transform: scale(1.5);
        }
        80% {
          color: pink;
          transform: scale(1.2);
        }
      }
       strong.Ashun{
     font-size:20px;
     display:block;
     text-align:center;
       }
    </style><body>



<p>   <strong class="Ashun">无论我怎样改变，都是那个少年</strong></p>
<script>let div = document.querySelector("strong.Ashun");let text = div.innerText;[...text].reduce((pre, val) => {pre == 0 && (div.innerHTML = "");let span = document.createElement("span");span.classList.add("ashun");span.innerText = val;div.append(span);span.addEventListener("mouseenter", (e) => {e.target.classList.add("active");});span.addEventListener("animationend", (e) => {e.target.classList.remove("active");});}, 0);</script></body>

<iframe src="//player.bilibili.com/player.html?aid=672756810&bvid=BV1CU4y1b7Sx&cid=332877650&page=1&danmaku=0" scrolling="no" style="border-radius:15px;" frameborder="no" framespacing="0" allowfullscreen="false"> </iframe>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span>
            <a href="/2021/04/22/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">第一篇博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 19:02:56" itemprop="dateCreated datePublished" datetime="2021-04-22T19:02:56+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:31:11" itemprop="dateModified" datetime="2021-05-17T09:31:11+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Ashuntefannao"><a href="#Ashuntefannao" class="headerlink" title="Ashuntefannao"></a>Ashuntefannao</h1><blockquote>
<p>这是我的第一个博客项目,时间原因，后续持续更新……</p>
</blockquote>
<iframe src="//player.bilibili.com/player.html?aid=50256015&bvid=BV1jb411G7Ks&cid=88079872&page=1&danmaku=0" scrolling="no" style="border-radius:15px;" frameborder="no" framespacing="0" allowfullscreen="false"> </iframe>

<p>test</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&quot;Ashuntefannao&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="string">&quot;Const&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">args=&#123;name,age&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.arguments=args</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.arguments.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is a test String&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">网络请求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:44:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:44:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:26:23" itemprop="dateModified" datetime="2021-05-17T09:26:23+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>浏览器天生具发送HTTP请求的能力，比如在在址栏输入内容，提交FORM表单等。本章来学习通过JS程序来管理HTTP请求的能力。</p>
<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><p>最传统的网络请求是通过提交表单进行的，表单的提交、地址栏输入内容，都会导致界面的全部刷新。</p>
<p>而使用JS脚本发送HTTP请求，**<code>不会带来页面的刷新</code>**，我们可以向后台请求数据，拿到数据后渲染到界面上，会有页面局部更新的效果，所以用户体验非常好。</p>
<h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>请求方式有很多，一般使用以下4种</p>
<ol>
<li><p>GET</p>
<blockquote>
<p>该方式一般应用于 单纯获取数据 的业务，请求参数包含在URL内</p>
</blockquote>
</li>
<li><p>POST</p>
<blockquote>
<p>该方式一般应用于 向服务器提交数据 ，请求参数置于请求体当中</p>
</blockquote>
</li>
<li><p>PUT</p>
<blockquote>
<p>该方式一般应用于 更改服务器数据 的业务</p>
</blockquote>
</li>
<li><p>DELETE</p>
<blockquote>
<p>该方式一般应用于 删除服务器数据 的业务</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p><code>open()</code>用于创建请求（单纯创建，并不发送）</p>
<blockquote>
<p>注意：如果<code>open()</code>的<code>method</code>为<code>GET</code>，则<code>url</code>需要自带参数。</p>
<ul>
<li>get请求就是通过url进行的</li>
<li>参数格式<code>key=val</code>多个参数之间使用<code>&amp;</code>隔开</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>method</td>
<td>请求方式</td>
</tr>
<tr>
<td>url</td>
<td>请求地址</td>
</tr>
<tr>
<td>async</td>
<td>是否异步(默认为true)</td>
</tr>
</tbody></table>
<h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p><code>send(body)</code>用于发送请求</p>
<ul>
<li>若请求方式为<code>GET</code>，则不用为其传递参数(get请求在url中传参)。</li>
<li>若请求方式为<code>POST</code>,则要把参数传递到<code>send(body)</code>中</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>body</td>
<td>请求体(要发送的数据)（字符串类型）</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test?name&#x3D;Ashun&quot;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.open(&quot;POST&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">let body&#x3D;&#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">xhr.send(body);</span><br></pre></td></tr></table></figure>



<h5 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h5><p>用于设置请求头，一般我们会指定编码方式。</p>
<ul>
<li>请求方式为<code>POST</code>，需要设置请求头的编码方式，<code>GET</code>不用设置。</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>请求头的key（字符串类型）</td>
</tr>
<tr>
<td>vlaue</td>
<td>请求头的value（字符串类型）</td>
</tr>
</tbody></table>
<ul>
<li><p>当传递的参数为form表单形式的数据，则需要设置<code>Content-type:application/x-www-form-urlencoded</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(&quot;name&#x3D;Ashun&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>若传递的参数为json字符串，则需要设置<code>Content-type:application/json</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.send(JSON.stringify(&#123; name: &quot;Ashun&quot; &#125;));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders"></a>getAllResponseHeaders</h5><p>用于获取响应头，返回所有的响应头数据（字符串类型）。</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader"></a>getResponseHeader</h5><p>获取响应头中指定<code>header</code>的值，返回该响应头的数据（字符串类型）。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>响应头的key（字符串类型）</td>
</tr>
</tbody></table>
<h5 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h5><p>终止请求。</p>
<hr>
<h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p><code>HTTP</code>状态码，如<code>200/404</code>等等。</p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p><code>HTTP</code>状态文本（字符串），与状态码对应如：OK、NotFound…</p>
<table>
<thead>
<tr>
<th align="center">status</th>
<th align="center">statusText</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">NotFound</td>
</tr>
</tbody></table>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p><code>xhr</code>状态码，使用<code>XmlHttpRequest</code>时共有5种状态。</p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未初始化，尚未调用open()方法</td>
</tr>
<tr>
<td>1</td>
<td>初始化，调用了open()方法，未调用send()方法</td>
</tr>
<tr>
<td>2</td>
<td>发送，已经调用了send()方法，未接收到响应</td>
</tr>
<tr>
<td>3</td>
<td>接收，已经接收到部分响应数据</td>
</tr>
<tr>
<td>4</td>
<td>完成，已经接收到全部响应数据</td>
</tr>
</tbody></table>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><p>这是服务器返回的数据（字符串类型）</p>
<hr>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>以下回调函数需要我们手动配置，当达到对应的状态后自动回调</p>
<h5 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h5><p>当请求完毕后，会自动执行该函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(xhr.getAllResponseHeaders());</span><br><span class="line">  console.log(xhr.responseText);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h5><p>当请求产生错误时，会自动执行该函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(xhr.status);</span><br><span class="line">  console.log(&quot;请求失败&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>当xhr状态码改变时，自动回调。 可以结合xhr、HTTP状态码，对请求是否成功做出判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;请求结束，并且成功</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123; </span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">  &#125; else if (xhr.status &#x3D;&#x3D; 404) &#123;</span><br><span class="line">    console.log(&quot;请求失败&quot;);</span><br><span class="line">  &#125;	else if(xhr.status &#x3D;&#x3D; 500)&#123;</span><br><span class="line">    console.log(&quot;服务器内部错误&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p><code>FormData</code>是JavaScript的一个内置对象，当满足以下使用条件时，会使请求变得更加简便</p>
<ul>
<li>使用表单<code>form</code>发送请求</li>
<li>请求方式为<code>POST</code></li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li>实例化对象，并传入表单Dom<code>let formdata=new FormData(formDom)</code></li>
<li>将其置于请求体中<code>xhr.send(formdata)</code></li>
</ol>
<p>FormData对象，会自动将传入的表单Dom中的数据，转化为正确的形式（<code>key=val</code>多个参数使用<code>&amp;</code>隔开）。</p>
<p>通过使用步骤可知，使用FormData请求的方式必须为<code>POST</code>(请求参数置于请求体当中)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">      &lt;button type&#x3D;&quot;button&quot;&gt;Login&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let formDom &#x3D; document.querySelector(&quot;form&quot;);</span><br><span class="line">      let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">      let btn &#x3D; document.querySelector(&quot;button&quot;);</span><br><span class="line">      btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;如果请求的是同源服务器，那么可以省略掉协议、域名、端口</span><br><span class="line">        xhr.open(&quot;post&quot;, &quot;&#x2F;formdata0&quot;);</span><br><span class="line">        let formdata &#x3D; new FormData(formDom);</span><br><span class="line">        xhr.send(formdata);</span><br><span class="line">        xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          xhr.status &#x3D;&#x3D; 200 &amp;&amp; console.log(xhr.responseText);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(xhr.status);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>若不使用FormData，则我们需要做更多的操作</p>
<ul>
<li>收集表单元素的数据，并以正确格式拼接（<code>FormData</code>自动收集）</li>
<li>发送请求前，需要设置请求头（<code>FormData</code>不需要）</li>
</ul>
<hr>
<h4 id="请求-返回类型"><a href="#请求-返回类型" class="headerlink" title="请求/返回类型"></a>请求/返回类型</h4><p>页面向服务器提交数据、服务器返回给浏览器数据。在这两个过程中，若传递的是<code>引用类型数据</code>，则最终都需要转化为<code>JSON String</code>。</p>
<p><strong>页面向服务器提交数据</strong></p>
<p>向服务器提交数据，请求方式为<code>POST</code>，若发送的数据为引用类型，需要设置响应头信息<code>Content-Type:application/json</code>,且放入请求体中的数据必须是JSON字符串(<code>send(JSON.stringify(data))</code>)</p>
<p><strong>服务器返回给浏览器数据</strong></p>
<p>服务器可以直接返回页面 引用类型 数据，但是页面接收到的还是<code>JSON String</code>，需要将数据反序列化得到真正的数据。</p>
<p>发送请求</p>
<ul>
<li>若直接接收服务器返回的引用类型数据，则为JSON String</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.send(JSON.stringify(&#123; name: &quot;Ashun&quot; &#125;));</span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  console.log(typeof xhr.responseText, xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;结果： string &#123; &quot;name&quot;: &quot;Ashun&quot; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以判断响应头信息，返回对应的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      xhr.onload &#x3D; function () &#123;</span><br><span class="line">        let isJson &#x3D; xhr</span><br><span class="line">          .getResponseHeader(&quot;Content-Type&quot;)</span><br><span class="line">          .includes(&quot;application&#x2F;json&quot;);</span><br><span class="line">        isJson</span><br><span class="line">          ? console.log(JSON.parse(xhr.responseText))</span><br><span class="line">          : console.log(xhr.responseText);</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>

<p>服务器响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.post(&quot;&#x2F;test&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  let postRes &#x3D; &quot;&quot;;</span><br><span class="line">  req.on(&quot;data&quot;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">    postRes +&#x3D; chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    res.send(JSON.parse(postRes));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h3><p>​    上面我们了解了<code>Ajax</code>的基本使用，现在我们可以封装一个<code>Ajax</code>请求处理函数，让请求更加的简便。</p>
<p><strong>需求</strong></p>
<p>每次请求的过程，都需要经历以下步骤</p>
<ul>
<li>创建xhr对象</li>
<li>初始化请求</li>
<li>设置请求头(post)</li>
<li>发送请求</li>
<li>请求完成后的处理</li>
</ul>
<p>我们可以将上述步骤抽离出来，把需要改变的部分暴露出去，让外部来决定，即：请求方式、请求地址、是否设置请求头、传递的参数、请求完毕后的具体操作。</p>
<p>还要根据服务器返回不同类型的结果进行判断，正确提交给外部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function ajax(preset) &#123;</span><br><span class="line">  let options &#x3D; Object.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;get&quot;,</span><br><span class="line">      url: &quot;&quot;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        [&quot;Content-Type&quot;]: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      success: (result, xhr) &#x3D;&gt; console.log(result),</span><br><span class="line">      error: (xhr) &#x3D;&gt; console.log(xhr.status),</span><br><span class="line">    &#125;,</span><br><span class="line">    preset</span><br><span class="line">  );</span><br><span class="line">  &#x2F;&#x2F;数据拼接</span><br><span class="line">  let queryStr &#x3D; Object.entries(options.data)</span><br><span class="line">    .map(([key, val]) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;val&#125;&#96;)</span><br><span class="line">    .join(&quot;&amp;&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;请求处理</span><br><span class="line">  const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  if (options.type &#x3D;&#x3D; &quot;get&quot;) &#123;</span><br><span class="line">    xhr.open(options.type, &#96;$&#123;options.url&#125;?$&#123;queryStr&#125;&#96;);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">  if (options.type &#x3D;&#x3D; &quot;post&quot;) &#123;</span><br><span class="line">    xhr.open(options.type, options.url);</span><br><span class="line">    &#x2F;&#x2F;设置header</span><br><span class="line">    Object.entries(options.header).forEach(([prop, val]) &#x3D;&gt; &#123;</span><br><span class="line">      xhr.setRequestHeader(prop, val);</span><br><span class="line">    &#125;);</span><br><span class="line">    let contentType &#x3D; options.header[&quot;Content-Type&quot;];</span><br><span class="line">    &#x2F;&#x2F;根据请求头信息，判断发送数据的形式</span><br><span class="line">    contentType.includes(&quot;json&quot;)</span><br><span class="line">      ? xhr.send(JSON.stringify(options.data))</span><br><span class="line">      : xhr.send(queryStr);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据响应头信息，返回对应类型的数据</span><br><span class="line">    let isJson &#x3D; xhr.getResponseHeader(&quot;Content-Type&quot;).includes(&quot;json&quot;);</span><br><span class="line">    let result &#x3D; isJson ? JSON.parse(xhr.responseText) : xhr.responseText;</span><br><span class="line">    &#x2F;&#x2F;根据HTTP状态码，执行不同的callback</span><br><span class="line">    xhr.status &#x3D;&#x3D; 200 ? options.success(result, xhr) : options.error(xhr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  type: &quot;post&quot;,</span><br><span class="line">  url: &quot;test&quot;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    [&quot;Content-Type&quot;]: &quot;application&#x2F;json&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &quot;Ashun&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: (res, xhr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res, xhr.status);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><p><code>fetch(url,&#123;options&#125;)</code>是JS升级后提供的更简便的网络请求的操作方法，内部使用Promise来完成异步请求。</p>
<ul>
<li>response.json()处理为JSON对象，将后台返回的JSON字符串处理为JSON对象</li>
<li>response.text()处理为TEXT类型数据</li>
<li>response.blog()处理为Blog二进制数据</li>
</ul>
<h4 id="请示步骤"><a href="#请示步骤" class="headerlink" title="请示步骤"></a>请示步骤</h4><p>使用fetch方法发送异步请求需要分以下两步操作</p>
<h5 id="响应头解析"><a href="#响应头解析" class="headerlink" title="响应头解析"></a>响应头解析</h5><p>第一步对服务器返回的响应头进行解析，会接到Response类创建的对象实例，里面包含以下属性。</p>
<ul>
<li><code>status</code>:HTTP状态码</li>
<li><code>ok</code>:状态码为200-299 时为true的布尔值</li>
</ul>
<h5 id="响应内容解析"><a href="#响应内容解析" class="headerlink" title="响应内容解析"></a>响应内容解析</h5><p>第二步对返回的 保存在response.body 中的响应结果进行解析，支持了以下几种方式对结果进行解析，且以下方法都默认返回Promise</p>
<ul>
<li>response.json()处理为JSON对象，将后台返回的JSON字符串处理为JSON对象</li>
<li>response.text()处理为TEXT类型数据</li>
<li>response.blog()处理为Blog二进制数据</li>
</ul>
<blockquote>
<p>以上方法不能同时使用，因为使用一个方法后数据已经被处理，其他方法就不可以操作了</p>
</blockquote>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>下面来体验使用fetch发送请求</p>
<p><strong>后台服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;&#x2F;test&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.send(&#123; name: &quot;阿顺&quot; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>发送请求</strong></p>
<p>以下为发送get请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(&quot;&#x2F;test&quot;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">          return result.json();</span><br><span class="line">        &#125;)</span><br><span class="line">        .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">        .catch((err) &#x3D;&gt; console.log(err));</span><br></pre></td></tr></table></figure>



<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>发送POST请求需要设置请求头Request header</p>
<p><strong>发送请求</strong></p>
<ul>
<li>发送的JSON类型需要设置请求头为 <code>application/json;charset=utf-8</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function post() &#123;</span><br><span class="line">  let response = await fetch(&quot;/test&quot;, &#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: JSON.stringify(&#123; name: &quot;阿顺&quot;, title: &quot;Ashuntefannao&quot; &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">  if (response.ok) &#123;</span><br><span class="line">    let result = await response.json();</span><br><span class="line">    console.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后台响应</strong></p>
<p>将数据原样返回</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.post(&quot;/test&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  let postRes = &quot;&quot;;</span><br><span class="line">  req.on(&quot;data&quot;, (chunk) =&gt; &#123;</span><br><span class="line">    postRes += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">    res.send(JSON.parse(postRes));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:43:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:43:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:19:03" itemprop="dateModified" datetime="2021-05-17T09:19:03+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在文档、浏览器、标签元素等元素在特定状态下触发的行为即为事件，比如用户的单击行为、表单内容的改变行为即为事件，我们可以为不同的事件定义处理程序。JS使用异步事件驱动的形式管理事件。</p>
<p><strong>事件类型</strong></p>
<p>JS为不同的事件定义的类型，也可以称为事件名称。</p>
<p><strong>事件目标</strong></p>
<p>事件目标指触发事件的对象，比如a标签被点击那么a标签就是事件目标。元素是可以嵌套的，所以在进行一次点击行为时可能会触发多个事件目标(事件冒泡)。</p>
<h3 id="处理程序"><a href="#处理程序" class="headerlink" title="处理程序"></a>处理程序</h3><p>事件的目的是要执行一段代码，我们称这类代码块为事件处理（监听）程序。当在对象上触发事件时就会执行定义的事件处理程序。</p>
<h4 id="HTML绑定"><a href="#HTML绑定" class="headerlink" title="HTML绑定"></a>HTML绑定</h4><p>可以在html元素上设置事件处理程序，浏览器解析后会绑定到DOM属性中</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(`Ashuntefannao`)&quot;&gt;阿顺特烦恼&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>往往事件处理程序业务比较复杂，所以绑定方法或函数会很常见</p>
<ul>
<li>绑定函数或方法时需要加上括号</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;show()&quot;&gt;阿顺特烦恼&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function show() &#123;</span><br><span class="line">    alert(&#x27;Ashuntefannao&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用对象方法做为事件处理程序</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; onkeyup=&quot;SHUN.show()&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  class SHUN &#123;</span><br><span class="line">    static show() &#123;</span><br><span class="line">      console.log(&#x27;Ashun&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以传递事件源对象与事件对象</p>
<ul>
<li>传入<code>this</code>指向事件源span元素</li>
<li>传入<code>event</code>指向事件对象，可通过其访问各种事件处理的属性/方法。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this指向span元素，event为事件对象，--&gt;</span><br><span class="line">&lt;span onclick=&quot;show(this,&#x27;Ashun&#x27;,&#x27;阿顺特烦恼&#x27;,event)&quot;&gt;ASHUN&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function show(...args) &#123;</span><br><span class="line">        console.log(args)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="DOM绑定"><a href="#DOM绑定" class="headerlink" title="DOM绑定"></a>DOM绑定</h4><p>也可以将事件处理程序绑定到DOM属性中</p>
<ul>
<li>使用setAttribute方法设置事件处理程序无效</li>
<li>属性名区分大小写</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>无法为事件类型绑定多个事件处理程序，下面绑定了多个事件处理程序，因为属性是相同的所以只有最后一个有效</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.fontSize = &#x27;55px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>通过上面的说明我们知道使用HTML与DOM绑定事件都有缺陷，建议使用新的事件监听绑定方式addEventListener 操作事件</p>
<p>使用addEventListener添加事件处理程序有以下几个特点</p>
<ul>
<li>transtionend / DOMContentLoaded 等事件类型只能使用 addEventListener 处理</li>
<li>同一事件类型可以设置多个事件处理程序，按设置的顺序先后执行</li>
<li>也可以对未来添加的元素绑定事件</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>addEventListener</td>
<td>添加事件处理程序</td>
</tr>
<tr>
<td>removeEventListener</td>
<td>移除事件处理程序</td>
</tr>
</tbody></table>
<p>addEventListener的参数说明如下</p>
<ol>
<li>参数一事件类型</li>
<li>参数二事件处理程序callback<ul>
<li>callback默认接收<code>event事件对象</code>参数</li>
</ul>
</li>
<li>参数三为定制的选项，可传递object或boolean类型。后面会详细介绍使用区别</li>
</ol>
<h4 id="绑定多个事件"><a href="#绑定多个事件" class="headerlink" title="绑定多个事件"></a>绑定多个事件</h4><p>使用addEventListener来多个事件处理程序</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.style.fontSize = &#x27;55px&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通过对象绑定"><a href="#通过对象绑定" class="headerlink" title="通过对象绑定"></a>通过对象绑定</h4><p><code>事件处理程序可以是对象</code>，对象的 handleEvent 方法会做为事件处理程序执行。下面将元素的事件统一交由对象处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  class Events &#123;</span><br><span class="line">    handleEvent(e) &#123;</span><br><span class="line">      this[e.type](e)</span><br><span class="line">    &#125;</span><br><span class="line">    click() &#123;</span><br><span class="line">      console.log(&#x27;单击事件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    mouseover() &#123;</span><br><span class="line">      console.log(&#x27;鼠标悬停事件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, new Events())</span><br><span class="line">  app.addEventListener(&#x27;mouseover&#x27;, new Events())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h4><p>使用removeEventListener删除事先绑定的事件处理函数</p>
<ul>
<li>事件处理程序单独定义函数或方法，这可以保证访问的事件处理程序是同一个</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;button id=&quot;rmEvent&quot;&gt;删除事件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  const rm = document.querySelector(&#x27;#rmEvent&#x27;)</span><br><span class="line">  function show(event) &#123;</span><br><span class="line">  	console.log(event.target)</span><br><span class="line">    console.log(&#x27;APP我执行了&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, show)</span><br><span class="line">  rm.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    app.removeEventListener(&#x27;click&#x27;, show)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="事件选项"><a href="#事件选项" class="headerlink" title="事件选项"></a>事件选项</h4><p>addEventListener的第三个参数为定制的选项，可传递object或boolean类型</p>
<p>下面是传递对象时的说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>可选参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>once</td>
<td>true/false</td>
<td>只执行一次事件</td>
</tr>
<tr>
<td>capture</td>
<td>true/false</td>
<td>事件是在捕获/冒泡哪个阶段执行，true:捕获阶段 false:冒泡阶段，默认为false</td>
</tr>
<tr>
<td>passive</td>
<td>true/false</td>
<td>声明事件里不会判断 <code>preventDefault()</code>，可以减少系统默认行为的等待</td>
</tr>
</tbody></table>
<p>传递Boolean时</p>
<ul>
<li>true：事件捕获方式执行，等同于参数<code>&#123;capture:true&#125;</code></li>
<li>false：事件冒泡方式执行，等同于参数<code>&#123;capture:false&#125;</code></li>
</ul>
<p><strong>事件捕获</strong></p>
<p>事件执行顺序：最顶层window-&gt;最底层触发事件的dom</p>
<p><strong>事件冒泡</strong></p>
<p>事件执行顺序与事件捕获相反</p>
<p>下面使用once:true 来指定事件只执行一次</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;app&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;阿顺特烦恼_Ashun&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; once: true &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置 <code>&#123; capture: true &#125;</code> 或直接设置第三个参数为true用来在捕获阶段执行事件</p>
<blockquote>
<p>addEventListener的第三个参数传递true/false 和设置 {capture:true/false}是一样</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;background-color: red&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;bt&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    const bt = document.querySelector(&#x27;#bt&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是div事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: true &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bt.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是按钮事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: true &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置 <code>&#123; capture: false &#125;</code> 或 直接设置第三个参数为false 或 不设置第三个参数(默认为false), 用来在冒泡阶段执行事件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;background-color: red&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;bt&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    const bt = document.querySelector(&#x27;#bt&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是div事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: false &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bt.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是按钮事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: false &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>passive</code>选项:   声明事件里不会判断 <code>preventDefault()</code>，可以减少系统默认行为的等待</p>
<p>很多移动端的页面都会监听 touchstart 等 touch 事件，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;touchstart&quot;, function(e)&#123;</span><br><span class="line">    ... &#x2F;&#x2F; 浏览器不知道这里会不会有 e.preventDefault()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>执行事件处理程序时，会产生包含当前事件相关信息的对象，即为事件对象。<strong>系统会自动做为参数传递给事件处理程序</strong>。</p>
<ul>
<li>大部分浏览器将事件对象保存到window.event中</li>
<li>有些浏览器会将事件对象做为事件处理程序的参数传递</li>
</ul>
<p>事件对象常用属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>事件类型</td>
</tr>
<tr>
<td>target</td>
<td>事件目标对象，冒泡方式时父级对象可以通过该属性找到在哪个子元素上最终执行事件</td>
</tr>
<tr>
<td>currentTarget</td>
<td>当前执行事件的对象</td>
</tr>
<tr>
<td>timeStamp</td>
<td>事件发生时间</td>
</tr>
<tr>
<td>x</td>
<td>相对窗口的X坐标</td>
</tr>
<tr>
<td>y</td>
<td>相对窗口的Y坐标</td>
</tr>
<tr>
<td>clientX</td>
<td>相对窗口的X坐标</td>
</tr>
<tr>
<td>clientY</td>
<td>相对窗口的Y坐标</td>
</tr>
<tr>
<td>screenX</td>
<td>相对计算机屏幕的X坐标</td>
</tr>
<tr>
<td>screenY</td>
<td>相对计算机屏幕的Y坐标</td>
</tr>
<tr>
<td>pageX</td>
<td>相对于文档的X坐标</td>
</tr>
<tr>
<td>pageY</td>
<td>相对于文档的Y坐标</td>
</tr>
<tr>
<td>offsetX</td>
<td>相对于事件对象的X坐标</td>
</tr>
<tr>
<td>offsetY</td>
<td>相对于事件对象的Y坐标</td>
</tr>
<tr>
<td>layerX</td>
<td>相对于父级定位的X坐标</td>
</tr>
<tr>
<td>layerY</td>
<td>相对于父级定位的Y坐标</td>
</tr>
<tr>
<td>path</td>
<td>冒泡的路径</td>
</tr>
<tr>
<td>altKey</td>
<td>是否按了alt键</td>
</tr>
<tr>
<td>shiftKey</td>
<td>是否按了shift键</td>
</tr>
<tr>
<td>metaKey</td>
<td>是否按了媒体键</td>
</tr>
<tr>
<td>window.pageXOffset</td>
<td>文档参考窗口水平滚动的距离</td>
</tr>
<tr>
<td>window.pageYOffset</td>
<td>文档参考窗口垂直滚动的距离</td>
</tr>
</tbody></table>
<h3 id="冒泡捕获"><a href="#冒泡捕获" class="headerlink" title="冒泡捕获"></a>冒泡捕获</h3><h4 id="冒泡行为"><a href="#冒泡行为" class="headerlink" title="冒泡行为"></a>冒泡行为</h4><p>事件默认是冒泡执行的：标签元素是嵌套的，在一个元素上触发的事件，同时也会向上触发父级元素对应的事件处理程序，一直到最顶层window。</p>
<ul>
<li>大部分事件都会冒泡，但像focus事件则不会</li>
<li>event.target <code>指向事件链中最底层事件的对象</code></li>
<li>event.currentTarget == this 即当前执行事件的对象</li>
</ul>
<p>以下示例有标签的嵌套，并且父子标签都设置了事件，当在子标签上触发事件事会冒泡执行父级标签的事件，直至window</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      #app &#123;</span><br><span class="line">        height: 70px;</span><br><span class="line">        background-color: #95a5a6;</span><br><span class="line">      &#125;</span><br><span class="line">      strong &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #f39c12;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">      const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">      const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line">      </span><br><span class="line">      window.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;window Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      document.documentElement.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;html Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;App Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下例无论点击哪个元素，都会变为<strong>蓝色</strong></p>
<ul>
<li><code>event.target</code>指向事件链中的最底层的事件对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      article &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background: #5f27cd;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      section &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: #ff9f43;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">      &lt;section&gt;&lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#0abde3&quot;; &#x2F;&#x2F; 祖先级body改蓝色</span><br><span class="line">      console.log(event.target);	&#x2F;&#x2F;由于冒泡执行，点击任意元素，该语句都会执行</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#ee5253&quot;; &#x2F;&#x2F; 父级article改红色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#10ac84&quot;; &#x2F;&#x2F; 子级section改绿色</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>若通过<code>event.currentTarget</code>处理当前所触发事件的元素，则更改的颜色就会对应起来</p>
<ul>
<li>由于事件冒泡，点击某个元素，也会导致其祖先元素的更改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#0abde3&quot;; &#x2F;&#x2F; 祖先级body改蓝色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#ee5253&quot;; &#x2F;&#x2F; 父级article改红色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#10ac84&quot;; &#x2F;&#x2F; 子级section改绿色</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><p>冒泡过程中的任何事件处理程序中，都可以执行 <code>event.stopPropagation/stopImmediatePropagation()</code> 方法阻止继续进行冒泡传递</p>
<ul>
<li>event.stopPropagation() 用于阻止冒泡</li>
<li>event.stopImmediatePropagation() 阻止<code>事件冒泡</code>并且阻止<code>相同事件类型的其他事件处理函数被调用</code></li>
</ul>
<p>使用event.stopPropagation处理冒泡行为中的例子，通过阻止冒泡，点击某个元素，不会影响祖先元素的背景颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#0abde3&quot;;</span><br><span class="line">      console.log(event.target);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#ee5253&quot;;</span><br><span class="line">      console.log(event.currentTarget);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#10ac84&quot;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><code>stopPropagation</code>只是阻止冒泡，不会阻止相同事件类型的其它事件处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">	&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> 			const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">      const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line"></span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;App Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        console.log(&quot;strong Method__1&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__2&quot;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>点击strong，打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;strong Method__1</span><br><span class="line">&#x2F;&#x2F;strong Method__2</span><br></pre></td></tr></table></figure>

<p>若将上述代码中的<code>stopPropagation</code>改为<code>stopImmediatePropagation</code>，则也会阻止相同事件的其它处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击strong，打印结果: &#x2F;&#x2F;strong Method__1</span><br></pre></td></tr></table></figure>



<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获：事件执行顺序与冒泡行为相反，会由事件链的最顶层window逐步向下传递执行。事件捕获在实际使用中频率不高。</p>
<ul>
<li><p>通过设置第三个参数为true或{ capture: true } 在捕获阶段执行事件处理程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      #app &#123;</span><br><span class="line">        height: 70px;</span><br><span class="line">        background-color: #95a5a6;</span><br><span class="line">      &#125;</span><br><span class="line">      strong &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #f39c12;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">     const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line"></span><br><span class="line">      app.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&quot;App Method&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      strong.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__1&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__2&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>由于在给<code>#app</code>添加事件时，第三个参数设置为<code>true/&#123;capture:true&#125;</code>,在事件捕获阶段执行，所以在点击<code>strong</code>时，会先执行<code>#app</code>的事件处理程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 结果</span><br><span class="line">App Method</span><br><span class="line">strong Method__1</span><br><span class="line">strong Method__2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>借助冒泡思路，我们可以不为子元素设置事件，而将事件设置在父级。然后通过父级事件对象的<code>event.target</code>查找事件链底层的元素，并对它做出处理。</p>
<ul>
<li>这在为多个元素添加相同事件时很方便</li>
<li>会使添加事件变得非常容易</li>
</ul>
<p>下面是为父级UL设置事件来控制子元素LI的样式切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      .active &#123;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        background-color: #eee;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;阿顺&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;Ashuntefannao&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   document.querySelector(&quot;ul&quot;).addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">      e.target.classList.toggle(&quot;active&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用事件代理来共享事件处理程序，不用为每个元素单独绑定事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li data-action&#x3D;&quot;border&quot; data-border&#x3D;&quot;2px solid #aaa&quot;&gt;阿顺&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-action&#x3D;&quot;color&quot; data-color&#x3D;&quot;red&quot;&gt;Ashuntefannao&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class Event &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          let action &#x3D; e.target.dataset.action;</span><br><span class="line">          this[action](e.target);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      border(event) &#123;</span><br><span class="line">        event.style.border &#x3D; event.dataset.border;</span><br><span class="line">      &#125;</span><br><span class="line">      color(event) &#123;</span><br><span class="line">        console.log(event.dataset);</span><br><span class="line">        event.style.color &#x3D; event.dataset.color;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new Event(document.querySelector(&quot;ul&quot;));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是使用事件代理实现的TAB面板效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">			.tab &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      dl &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line">      dt,</span><br><span class="line">      dd &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        color: white;</span><br><span class="line">      &#125;</span><br><span class="line">      dt &#123;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #34495e;</span><br><span class="line">      &#125;</span><br><span class="line">      dd &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 60px;</span><br><span class="line">        background-color: #e67e22;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt data-action&#x3D;&quot;toggle&quot;&gt;阿顺特烦恼&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd data-action&#x3D;&quot;hidden&quot;&gt;Ashuntefannao&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;dt data-action&#x3D;&quot;toggle&quot;&gt;阿顺&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd data-action&#x3D;&quot;hidden&quot;&gt;Ashun&lt;&#x2F;dd&gt;</span><br><span class="line">      &lt;&#x2F;dl&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class Card &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          let action &#x3D; e.target.dataset.action;</span><br><span class="line">          this[action](e);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      toggle(event) &#123;</span><br><span class="line">        event.target</span><br><span class="line">          .querySelectorAll(&quot;[data-action&#x3D;&#39;hidden&#39;]&quot;)</span><br><span class="line">          .forEach((elem) &#x3D;&gt; (elem.hidden &#x3D; true));</span><br><span class="line">        event.target.nextElementSibling.hidden &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">      hidden(event) &#123;</span><br><span class="line">        event.target.hidden &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new Card(document.querySelector(&quot;.tab&quot;));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面实现通过代理事件行为，在表单提交时禁用提交按钮，并记录提示次数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;button type=&quot;button&quot; data-submit-disabled data-action=&quot;submit,counter&quot;&gt;提交表单&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class FORM &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        this.$el = el;</span><br><span class="line">        this.sum = 0;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class="line">          let actions = e.target.dataset.action;</span><br><span class="line">          actions &amp;&amp;</span><br><span class="line">            actions.split(&quot;,&quot;).forEach((method) =&gt; &#123;</span><br><span class="line">              this[method](e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      submit(e) &#123;</span><br><span class="line">        this.disabled(e, true);</span><br><span class="line">        console.log(&quot;正在提交&quot;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;提交成功！&quot;);</span><br><span class="line">          this.disabled(e, false);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;</span><br><span class="line">      disabled(event, boolean) &#123;</span><br><span class="line">        this.$el</span><br><span class="line">          .querySelectorAll(&quot;[data-submit-disabled]&quot;)</span><br><span class="line">          .forEach((btn) =&gt; (btn.disabled = boolean));</span><br><span class="line">      &#125;</span><br><span class="line">      counter() &#123;</span><br><span class="line">        console.log(`提交次数:$&#123;++this.sum&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new FORM(document.querySelector(&quot;form&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="未来元素"><a href="#未来元素" class="headerlink" title="未来元素"></a>未来元素</h4><p>下面使用事件代理来对未来元素进行事件绑定</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(this.textContent)</span><br><span class="line">  &#125;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    show.call(event.target)</span><br><span class="line">  &#125;)</span><br><span class="line">  let newH2 = document.createElement(&#x27;h2&#x27;)</span><br><span class="line">  newH2.textContent = &#x27;Ashuntefannao&#x27;</span><br><span class="line">  app.append(newH2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以将这个功能封装起来，用来代理某一类未来元素的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;section&gt;My name is Section&lt;&#x2F;section&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Element.prototype.on &#x3D; function (EventType, Element, func) &#123;</span><br><span class="line">      this.addEventListener(EventType, (event) &#x3D;&gt; &#123;</span><br><span class="line">        if (event.target.tagName &#x3D;&#x3D;&#x3D; Element.toUpperCase()) &#123;</span><br><span class="line">          func(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line"></span><br><span class="line">    app.on(&quot;click&quot;, &quot;h2&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(event.target);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let h2 &#x3D; document.createElement(&quot;h2&quot;);</span><br><span class="line">    h2.innerText &#x3D; &quot;Ashuntefannao&quot;;</span><br><span class="line">    app.append(h2);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><p>JS中有些对象会设置默认事件处理程序，比如A链接在点击时会进行跳转，点击submit会提交表单信息…</p>
<p>一般默认处理程序会在用户定义的处理程序后执行，我们可以在事件处理函数中取消默认事件的执行。</p>
<ul>
<li>使用onclick绑定的事件处理程序，return false 可以阻止默认行为</li>
<li>推荐使用<code>event.preventDefault()</code>阻止默认行为</li>
</ul>
<p>下面阻止超链接的默认行为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下，你就知道&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.querySelector(&#x27;a&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    alert(event.target.innerText)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="文档事件"><a href="#文档事件" class="headerlink" title="文档事件"></a>文档事件</h3><p>下面来学习针对文档事件的处理。</p>
<h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>window.onload</td>
<td>文档解析及外部资源加载后</td>
</tr>
<tr>
<td>DOMContentLoaded</td>
<td>文档解析后执行，不需要等待图片/样式文件等外部资源加载，该事件只能通过addEventListener设置</td>
</tr>
<tr>
<td>window.onbeforeunload</td>
<td>文档刷新或关闭时</td>
</tr>
<tr>
<td>window.onunload</td>
<td>文档卸载时</td>
</tr>
<tr>
<td>scroll</td>
<td>页面滚动时</td>
</tr>
</tbody></table>
<h4 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h4><p>window.onload事件在文档解析后及图片、外部样式文件等资源加载完后执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function () &#123;</span><br><span class="line">    alert(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h4 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h4><p>DOMContentLoaded事件在文档标签解析后执行，不需要等外部图片、样式文件、JS文件等资源加载</p>
<ul>
<li>该事件只能够通过<code>addEventListener</code>添加</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;</span><br><span class="line">    alert(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h4 id="onbeforeunload"><a href="#onbeforeunload" class="headerlink" title="onbeforeunload"></a>onbeforeunload</h4><p>当浏览器窗口关闭或者刷新时，会触发beforeunload事件，可以取消关闭或刷新页面。</p>
<ul>
<li>返回值为非空字符串时，有些浏览器会做为弹出的提示信息内容</li>
<li>部分浏览器使用addEventListener无法绑定事件</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload = function (e) &#123;</span><br><span class="line">  return &#x27;真的要离开吗？&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="unload"><a href="#unload" class="headerlink" title="unload"></a>unload</h4><p>window.unload事件在文档资源被卸载时执行，在beforeunload后执行</p>
<ul>
<li>不能执行alert、confirm等交互指令</li>
<li>发生错误也不会阻止页面关闭或刷新</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//文档被关闭时，在localStorage中存储用户信息</span><br><span class="line">window.addEventListener(&#x27;unload&#x27;, function (e) &#123;</span><br><span class="line">  localStorage.setItem(&#x27;name&#x27;, &#x27;Ashun&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h4 id="事件类型-1"><a href="#事件类型-1" class="headerlink" title="事件类型"></a>事件类型</h4><p>针对鼠标操作的行为有多种事件类型</p>
<ul>
<li>鼠标事件会触发在Z-INDEX 层级最高的那个元素上</li>
</ul>
<table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>click</td>
<td>鼠标单击事件，同时触发 mousedown/mouseup</td>
</tr>
<tr>
<td>dblclick</td>
<td>鼠标双击事件</td>
</tr>
<tr>
<td>contextmenu</td>
<td>点击右键后显示的所在环境的菜单</td>
</tr>
<tr>
<td>mousedown</td>
<td>鼠标按下</td>
</tr>
<tr>
<td>mouseup</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>mousemove</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>mouseover</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>mouseout</td>
<td>鼠标从元素上离开时</td>
</tr>
<tr>
<td>mouseup</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>mouseenter</td>
<td>鼠标移入时触发，不产生冒泡行为</td>
</tr>
<tr>
<td>mosueleave</td>
<td>鼠标移出时触发，不产生冒泡行为</td>
</tr>
<tr>
<td>oncopy</td>
<td>复制内容时触发</td>
</tr>
<tr>
<td>scroll</td>
<td>元素滚动时，可以为元素设置overflow:auto; 产生滚动条来测试</td>
</tr>
</tbody></table>
<h4 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;copy&#x27;, () =&gt; &#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  alert(&#x27;禁止复制内容&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="relatedTarget"><a href="#relatedTarget" class="headerlink" title="relatedTarget"></a>relatedTarget</h4><p>relatedTarget是控制鼠标移动事件的来源和目标对象的</p>
<ul>
<li>如果移动过快会跳转中间对象</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  const shun = document.querySelector(`#shun`)</span><br><span class="line">  app.addEventListener(&#x27;mouseout&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(event.target)</span><br><span class="line">    console.log(event.relatedTarget)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="mouseenter与mouseleave"><a href="#mouseenter与mouseleave" class="headerlink" title="mouseenter与mouseleave"></a>mouseenter与mouseleave</h4><p>mouseenter与mouseleave事件从子元素移动到父元素时不触发父元素事件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    background: #e74c3c;</span><br><span class="line">    padding: 80px;</span><br><span class="line">    width: 500px;</span><br><span class="line">  &#125;</span><br><span class="line">  #shun &#123;</span><br><span class="line">    background: #f39c12;</span><br><span class="line">    padding: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"> 	Ashuntefannao</span><br><span class="line">  &lt;div id=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  const shun = document.querySelector(`#shun`)</span><br><span class="line"></span><br><span class="line">  app.addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;app&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  shun.addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;shun&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>针对键盘输入操作的行为有多种事件类型</p>
<table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Keydown</td>
<td>键盘按下时，一直按键不松开时keydown事件会重复触发</td>
</tr>
<tr>
<td>keyup</td>
<td>按键抬起时</td>
</tr>
<tr>
<td>keypress</td>
<td>按键 按下、抬起 都会触发，一直按键不松开也会持续触发</td>
</tr>
</tbody></table>
<h4 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h4><p>键盘事件产生的事件对象包含相对应的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keyCode</td>
<td>返回键盘的ASCII字符数字</td>
</tr>
<tr>
<td>code</td>
<td>按键码，字符以Key开始，数字以Digit开始，特殊字符有专属名子。左右ALT键字符不同。 不同布局的键盘值会不同</td>
</tr>
<tr>
<td>key</td>
<td>按键的字符含义表示，大小写不同。不能区分左右ALT等。不同语言操作系统下值会不同</td>
</tr>
<tr>
<td>altKey</td>
<td>是否按了alt键</td>
</tr>
<tr>
<td>ctrlKey</td>
<td>是否按了ctlr键</td>
</tr>
<tr>
<td>shiftKey</td>
<td>是否按了shift键</td>
</tr>
<tr>
<td>metaKey</td>
<td>是否按了媒体键</td>
</tr>
</tbody></table>
<hr>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>下面是可以用在表单上的事件类型</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>focus</td>
<td>获取焦点事件</td>
</tr>
<tr>
<td>blur</td>
<td>失去焦点事件</td>
</tr>
<tr>
<td>element.focus()</td>
<td>让元素强制获取焦点</td>
</tr>
<tr>
<td>element.blur()</td>
<td>让元素失去焦点</td>
</tr>
<tr>
<td>change</td>
<td>文本框在<code>内容发生改变</code>并<code>失去焦点</code>时触发</td>
</tr>
<tr>
<td>input</td>
<td><code>value</code> 被修改时，会触发 <code>input</code> 事件</td>
</tr>
<tr>
<td>submit</td>
<td>提交表单时触发</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87/" class="post-title-link" itemprop="url">空间坐标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:42:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:42:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:16:48" itemprop="dateModified" datetime="2021-05-17T09:16:48+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="空间坐标"><a href="#空间坐标" class="headerlink" title="空间坐标"></a>空间坐标</h2><h3 id="视口与文档"><a href="#视口与文档" class="headerlink" title="视口与文档"></a>视口与文档</h3><p>首先理解视口（窗口）与文档的含义</p>
<ul>
<li>网页很多都是多屏（通过滚动条显示看不见的内容），所以文档尺寸一般大于视口尺寸</li>
<li>视口可以理解为可视区域，而不是全部的文档</li>
<li>视口尺寸不包括浏览器工具条、菜单、标签、状态栏等</li>
<li>当你打开控制台后，视口尺寸就相应变小了</li>
<li>position使用文档定位，fixed使用视口定位</li>
<li>文档坐标在页面滚动时不发生改变</li>
<li>视口坐标的操作需要考虑滚动条的位置</li>
</ul>
<img src="空间坐标.assets/视口_文档区域1.png" alt="image-20210413150736697" style="zoom:75%;" />

<h4 id="视口与文档尺寸"><a href="#视口与文档尺寸" class="headerlink" title="视口与文档尺寸"></a>视口与文档尺寸</h4><p>视口坐标需要知道滚动条位置才可以进行计算，有以下几种方式获取滚动位置</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>window.innerWidth</td>
<td>视口宽度</td>
<td>包括滚动条（不常用）</td>
</tr>
<tr>
<td>window.innerHeight</td>
<td>视口高度</td>
<td>包括滚动条（不常用）</td>
</tr>
<tr>
<td>document.documentElement.clientWidth</td>
<td>视口宽度</td>
<td></td>
</tr>
<tr>
<td>document.documentElement.clientHeight</td>
<td>视口高度</td>
<td></td>
</tr>
</tbody></table>
<h3 id="几何尺寸"><a href="#几何尺寸" class="headerlink" title="几何尺寸"></a>几何尺寸</h3><p>元素在页面中拥有多个描述几何数值的尺寸，下面截图进行了形象的描述。</p>
<img src="空间坐标.assets/视口_文档区域2.png" alt="image-20210413150736697" style="zoom:75%;" />



<h4 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h4><p>下面是获取尺寸的方法或属性</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>element.getBoundingClientRect</td>
<td>返回元素在视口坐标及元素大小，width/height不包括外边距，与offsetWidth/offsetHeight匹配</td>
<td>窗口坐标</td>
</tr>
<tr>
<td>element.getClientRects</td>
<td>行级元素每行尺寸位置组成的数组</td>
<td></td>
</tr>
<tr>
<td>element.offsetParent</td>
<td>拥有定位属性的父级，或body/td/th/table</td>
<td>对于隐藏元素/body/html值为null</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>元素宽度尺寸，包括内边距与边框和滚动条</td>
<td></td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>元素高度尺寸，包括内边距与边框和滚动条</td>
<td></td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>相对于祖先元素的X轴坐标</td>
<td></td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>相对于祖先元素的Y轴坐标</td>
<td></td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>元素宽度，不包含边框，只包含内容和内边距，行元素尺寸为0</td>
<td></td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>元素高度，不包含边框，只包含内容和内边距，行元素尺寸为0</td>
<td></td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>内容距离外部的距离，滚动条在左侧时包括滚动条尺寸</td>
<td></td>
</tr>
<tr>
<td>element.clientTop</td>
<td>内容距离顶部的距离，滚动条在顶部时包括滚动条尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>元素宽度，内容+内边距+内容溢出的尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>元素高度，内容+内边距+内容溢出的尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>水平滚动条左侧已经滚动的宽度</td>
<td></td>
</tr>
<tr>
<td>element.scrollTop</td>
<td>垂直滚动条顶部已经滚动的高度</td>
<td></td>
</tr>
</tbody></table>
<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle"></a>getComputedStyle</h4><p>为什么不要使用getComputedStyle</p>
<ul>
<li>尺寸设置auto时获取结果不可用</li>
<li>由于滚动条的存在，不同浏览器返回结果不同</li>
<li>当元素没有设置CSS尺寸时，获取不到相应的尺寸内容</li>
</ul>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>使用<code>getBoundingClientRect</code>获取元素矩形信息</p>
<img src="空间坐标.assets/视口_文档区域3.png" alt="image-20210413150736697" style="zoom:38%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        height: 300px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        border: 5px solid #ddd;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">        let position &#x3D; div.getBoundingClientRect();</span><br><span class="line">        console.log(position);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>计算结果的矩形尺寸不包括外边距</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bottom: 340</span><br><span class="line">height: 330</span><br><span class="line">left: 18</span><br><span class="line">right: 348</span><br><span class="line">top: 10</span><br><span class="line">width: 330</span><br><span class="line">x: 18</span><br><span class="line">y: 10</span><br></pre></td></tr></table></figure>



<h4 id="getClientRects"><a href="#getClientRects" class="headerlink" title="getClientRects"></a>getClientRects</h4><p>getClientRects使用场景：多行元素时 分别返回每行所占的尺寸，下面的行元素将为每行返回对应矩形尺寸</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	span &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let span = document.querySelector(&#x27;span&#x27;)</span><br><span class="line">  let info = span.getClientRects()</span><br><span class="line">  console.log(info)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上例计算结果如下</p>
<table>
<thead>
<tr>
<th align="left">(index)</th>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">width</th>
<th align="left">height</th>
<th align="left">top</th>
<th align="left">right</th>
<th align="left">bottom</th>
<th align="left">left</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">8</td>
<td align="left">8</td>
<td align="left">1255.7125244140625</td>
<td align="left">20.80000114440918</td>
<td align="left">8</td>
<td align="left">1263.7125244140625</td>
<td align="left">28.80000114440918</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">28.80000114440918</td>
<td align="left">675.8624877929688</td>
<td align="left">20.80000114440918</td>
<td align="left">28.80000114440918</td>
<td align="left">683.8624877929688</td>
<td align="left">49.60000228881836</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">length</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">2</td>
</tr>
</tbody></table>
<h3 id="坐标点元素"><a href="#坐标点元素" class="headerlink" title="坐标点元素"></a>坐标点元素</h3><p>JS提供了方法获取指定坐标上的元素，如果指定坐标点在视口外，返回值为NULL</p>
<ul>
<li>坐标都是从左上角计算，这与CSS中的right/bottom等不同</li>
<li>视口坐标类似于position:fixed</li>
<li>文档坐标类似于position:absolute</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>element.elementsFromPoint(x,y)</td>
<td>返回指定坐标点所在的元素集合<code>Array</code></td>
</tr>
<tr>
<td>element.elementFromPoint(x,y)</td>
<td>返回指定坐标点最顶层的元素</td>
</tr>
</tbody></table>
<h4 id="元素集合"><a href="#元素集合" class="headerlink" title="元素集合"></a>元素集合</h4><p>返回指定坐标点上的元素集合<code>Array</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        background-color: black;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.elementsFromPoint(99, 99));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回结果为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[div#app, body, html]</span><br></pre></td></tr></table></figure>

<h4 id="底层元素"><a href="#底层元素" class="headerlink" title="底层元素"></a>底层元素</h4><p>返回坐标点上的最底层的元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        background-color: black;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.elementFromPoint(99, 99));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回结果为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div</span><br></pre></td></tr></table></figure>



<h3 id="滚动控制"><a href="#滚动控制" class="headerlink" title="滚动控制"></a>滚动控制</h3><p>下面掌握文档或元素的滚动操作</p>
<h4 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h4><p>获取滚动</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>window.pageXOffset</td>
<td>文档相对视口水平滚动的像素距离</td>
<td></td>
</tr>
<tr>
<td>window.pageYOffset</td>
<td>文档相对视口竖直滚动的像素距离</td>
<td></td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>获取和设置元素X轴滚动位置</td>
<td></td>
</tr>
<tr>
<td>element.scrollTop</td>
<td>获取和设置元素Y轴滚动位置</td>
<td></td>
</tr>
</tbody></table>
<p>控制滚动</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollBy()</td>
<td>按偏移量进行滚动内容</td>
<td>参数为<code>obj</code>，{top:垂直偏移量,left:水平偏移量,behavior:’滚动方式’}</td>
</tr>
<tr>
<td>element.scroll() 或 element.scrollTo()</td>
<td>滚动到指定的具体位置</td>
<td>参数为<code>obj</code>，{top:X轴文档位置,left:Y轴文档位置,behavior:’滚动方式’}</td>
</tr>
<tr>
<td>element.scrollIntoView(bool)</td>
<td>定位到顶部或底部</td>
<td>参数为:<code>obj/boolean</code>—参数为<code>boolean</code>：true元素定位到顶部，为false定位到窗口底部。—参数为<code>obj</code>：<code>&#123;block:&quot;start/end&quot;,behavior:&quot;smooth&quot;&#125;</code></td>
</tr>
</tbody></table>
<h4 id="获取滚动位置"><a href="#获取滚动位置" class="headerlink" title="获取滚动位置"></a>获取滚动位置</h4><h5 id="文档滚动位置"><a href="#文档滚动位置" class="headerlink" title="文档滚动位置"></a>文档滚动位置</h5><p>下例是查看文档滚动的X/Y坐标示例,<code>window.pageXOffset/pageYOffset</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 3000px; height: 3000px; background: #e34334&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onscroll = function () &#123;</span><br><span class="line">        console.log(window.pageXOffset)</span><br><span class="line">        console.log(window.pageYOffset)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>doucment.documentElement</code>能够访问到html元素，所以可以使用元素的方法<code>element.scrollTop/scrollLeft</code>获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 3000px; height: 3000px; background: #e34334&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onscroll &#x3D; function () &#123;</span><br><span class="line">        console.log(document.documentElement.scrollTop)</span><br><span class="line">        console.log(document.documentElement.scrollLeft)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="元素滚动位置"><a href="#元素滚动位置" class="headerlink" title="元素滚动位置"></a>元素滚动位置</h5><p>下面查看元素内容的滚动属性，请在控制台查看结果</p>
<ul>
<li>要为父元素设置 overflow:scroll 以使其产生滚动条</li>
<li>使用scroll 事件来监听结果</li>
</ul>
<img src="空间坐标.assets/视口_文档区域4.gif" alt="视口_文档区域4.gif" style="zoom:75%;" />

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;width: 300px; height: 300px; border: solid 6px #e34334; overflow: auto&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width: 1000px; height: 1000px; background: #833ca4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">    app.addEventListener(&#x27;scroll&#x27;, function () &#123;</span><br><span class="line">        console.log(this.scrollLeft)</span><br><span class="line">        console.log(this.scrollTop)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="控制滚动位置"><a href="#控制滚动位置" class="headerlink" title="控制滚动位置"></a>控制滚动位置</h4><p>下面介绍的是控制元素滚动的操作方法</p>
<h5 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy"></a>scrollBy</h5><p>使用<code>scrollBy(&#123;top,left,behavior&#125;)</code><strong>按偏移量</strong>滚动整个文档</p>
<ul>
<li><code>behavior:smooth </code>为平滑滚动</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: linear-gradient(</span><br><span class="line">          to bottom,</span><br><span class="line">          #ecf0f1,</span><br><span class="line">          #1abc9c,</span><br><span class="line">          #f39c12,</span><br><span class="line">          #ecf0f1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">//每隔1秒,向下滚动30px,参照上次的位置，即按偏移量进行滚动</span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    document.documentElement.scrollBy(&#123; top: 30, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>scrollTop/scrollLeft</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      let top &#x3D; 0;</span><br><span class="line">      setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        top +&#x3D; 30;</span><br><span class="line">        document.documentElement.scrollTop &#x3D; top;</span><br><span class="line">      &#125;, 1000);</span><br></pre></td></tr></table></figure>



<h5 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h5><p>使用<code>scroll(&#123;top,left,behavior&#125;)</code>滚动到指定位置</p>
<ul>
<li><code>behavior:smooth</code> 为平滑滚动</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body &#123;</span><br><span class="line">    height: 3000px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">//3秒后，滚动到指定位置</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    document.documentElement.scroll(&#123; top: 30, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>scrollTop/scrollLeft</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        document.documentElement.scrollTop &#x3D; 30;</span><br><span class="line">      &#125;, 1000);</span><br></pre></td></tr></table></figure>



<h5 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h5><p>使用元素scrollIntoView方法实现滚动操作，参数可以是布尔值或对象</p>
<ul>
<li>参数为Boolean<ul>
<li>参数为 true 时顶部对齐，相当于{block: “start”}</li>
<li>参数为 false 时底部对齐，相当于{block: “end”}</li>
</ul>
</li>
<li>参数为obj<ul>
<li>block:”start/width”</li>
<li>behavior:”smooth”</li>
</ul>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: red;</span><br><span class="line">        border-top: solid 50px #efbc0f;</span><br><span class="line">        border-bottom: solid 50px #1bb491;</span><br><span class="line">    &#125;</span><br><span class="line">    span &#123;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background: #000;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        display: block;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 50px;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 50%;</span><br><span class="line">        right: 50px;</span><br><span class="line">        border: solid 2px #ddd;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;hdcms.com&lt;/div&gt;</span><br><span class="line">&lt;span&gt;TOP&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#x27;span&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">        let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">        app.scrollIntoView(&#123; block: &#x27;end&#x27;, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h4><h5 id="backTop"><a href="#backTop" class="headerlink" title="backTop"></a>backTop</h5><p>下例是开发中常用的回到顶部示例</p>
<img src="空间坐标.assets/视口_文档区域5.gif" alt="视口_文档区域5.gif" style="zoom:75%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: linear-gradient(</span><br><span class="line">          to bottom,</span><br><span class="line">          #ecf0f1,</span><br><span class="line">          #1abc9c,</span><br><span class="line">          #f39c12,</span><br><span class="line">          #ecf0f1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      .backtop &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        position: fixed;</span><br><span class="line">        right: 10px;</span><br><span class="line">        bottom: 10px;</span><br><span class="line">        z-index: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: rgba(0, 0, 0, 0.75);</span><br><span class="line">        color: white;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        transition: 0.6s;</span><br><span class="line">        transform: scale(0);</span><br><span class="line">      &#125;</span><br><span class="line">      .show &#123;</span><br><span class="line">        transform: scale(1) rotateZ(360deg);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;backtop&quot;&gt;Top&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let backtop &#x3D; document.querySelector(&quot;.backtop&quot;);</span><br><span class="line">      backtop.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        document.documentElement.scrollIntoView(&#123;</span><br><span class="line">          block: &quot;start&quot;,</span><br><span class="line">          behavior: &quot;smooth&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      window.onscroll &#x3D; function () &#123;</span><br><span class="line">        let test &#x3D;</span><br><span class="line">          document.documentElement.scrollTop +</span><br><span class="line">            document.documentElement.clientHeight &gt;</span><br><span class="line">          document.documentElement.scrollHeight - 300;</span><br><span class="line"></span><br><span class="line">        backtop.classList[test ? &quot;add&quot; : &quot;remove&quot;](&quot;show&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="漂浮广告"><a href="#漂浮广告" class="headerlink" title="漂浮广告"></a>漂浮广告</h5><p>下面是全屏漂浮广告的示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        color: rgba(255, 255, 255, 0.8);</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: #e34334;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Ad &#123;</span><br><span class="line">        constructor(preset) &#123;</span><br><span class="line">          this.$el &#x3D; preset.el;</span><br><span class="line">          &#x2F;&#x2F;初始移动方向，1向下&#x2F;向右 -1 向上&#x2F;向左</span><br><span class="line">          this.x &#x3D; this.y &#x3D; 1;</span><br><span class="line">          this.preset &#x3D; Object.assign(&#123;delay: 10,step: 1,&#125;,preset);</span><br><span class="line">          this.run();</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">          this.init();</span><br><span class="line">          setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            this.$el.style.left &#x3D; this.leftMove() + &quot;px&quot;;</span><br><span class="line">            this.$el.style.top &#x3D; this.topMove() + &quot;px&quot;;</span><br><span class="line">          &#125;, this.preset.delay);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置定位模式</span><br><span class="line">        init() &#123;</span><br><span class="line">          this.$el.style.position &#x3D; &quot;fixed&quot;;</span><br><span class="line">          this.$el.style.top &#x3D; 0;</span><br><span class="line">          this.$el.style.left &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        leftMove() &#123;</span><br><span class="line">          let &#123; x, width &#125; &#x3D; this.$el.getBoundingClientRect();</span><br><span class="line">          let &#123; clientWidth &#125; &#x3D; document.documentElement;</span><br><span class="line">          if (x &gt; clientWidth - width) this.x &#x3D; -1;</span><br><span class="line">          if (x &lt; 0) this.x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">          return x + this.preset.step * this.x;</span><br><span class="line">        &#125;</span><br><span class="line">        topMove() &#123;</span><br><span class="line">          let &#123; y, height &#125; &#x3D; this.$el.getBoundingClientRect();</span><br><span class="line">          let &#123; clientHeight &#125; &#x3D; document.documentElement;</span><br><span class="line">          if (y &gt; clientHeight - height) this.y &#x3D; -1;</span><br><span class="line">          if (y &lt; 0) this.y &#x3D; 1;</span><br><span class="line">          return y + this.preset.step * this.y;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      new Ad(&#123; el: div &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/DOM/" class="post-title-link" itemprop="url">DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:41:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:41:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:12:09" itemprop="dateModified" datetime="2021-05-17T09:12:09+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>DOM 即Document Object Model 文档对象模型。如果对HTML很了解使用DOM并不复杂。</p>
<p>通过js操作界面元素，操作的对象即DOM。</p>
<p>浏览器在加载页面时会生成DOM对象，以供我们使用JS控制页面元素。</p>
<h4 id="文档渲染"><a href="#文档渲染" class="headerlink" title="文档渲染"></a>文档渲染</h4><p>浏览器会将HTML文本内容进行渲染，并生成相应的JS对象，同时会对不符规则的标签进行处理。</p>
<ul>
<li>浏览器会将标签规范后渲染页面</li>
<li>目的一让页面可以正确呈现</li>
<li>目的二可以生成统一的JS可操作对象</li>
</ul>
<h5 id="标签修复"><a href="#标签修复" class="headerlink" title="标签修复"></a>标签修复</h5><p>在html文件中，若只有内容<code>阿顺特烦恼</code>而<strong>没有任何标签时</strong>，浏览器会自动修复成以下格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">阿顺特烦恼</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>下面H1标签结束错误并且属性也没有引号，浏览器在渲染中会进行修复</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1 id=ashun&gt;阿顺特烦恼&lt;h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>处理后的结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;ashun&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="表格处理"><a href="#表格处理" class="headerlink" title="表格处理"></a>表格处理</h5><p>表格tabel中不允许有内容，浏览器在渲染过程中会进行处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  阿顺特烦恼</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;阿顺&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>渲染后会添加tbody标签并将table中的字符移出到table标签外部</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">阿顺特烦恼</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">  	&lt;tr&gt;</span><br><span class="line">      &lt;th&gt;阿顺&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h5 id="标签移动"><a href="#标签移动" class="headerlink" title="标签移动"></a>标签移动</h5><p>所有内容要写在BODY标签中，下面的SCRIPT标签写在了BODY后面，浏览器渲染后也会进行处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.dir(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>渲染后处理的结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.dir(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="操作时机"><a href="#操作时机" class="headerlink" title="操作时机"></a>操作时机</h4><p>需要保证浏览器已经渲染了内容才可以读取的节点对象，下例将无法读取到节点对象</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">  console.log(node); //null</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>不过我们可以将脚本通过事件放在页面渲染完执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = () =&gt; &#123;</span><br><span class="line">    const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">    console.log(node);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>或使用定时器将脚本设置为异步执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">   	const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">    console.log(node)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>为脚本设置<code>type=&quot;module&quot;</code>,会延迟解析模块脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">   	const node &#x3D; document.getElementById(&#39;as&#39;);</span><br><span class="line">    console.log(node)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;h1 id&#x3D;&quot;as&quot;&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>或将脚本设置在外部文件并使用<code>defer/async</code>属性加载，即会等到DOM解析后迟延执行</p>
<ul>
<li>仅引入外部脚本时有效</li>
<li>多个外部脚本使用<code>defer/async</code>属性加载，不能够保证加载的前后顺序，当模块之间存在依赖时要注意</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;as&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;as&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h4><p>JS中获取html内容的对象，称为DOM节点对象（node)，即然是对象就包括操作NODE的属性和方法</p>
<ul>
<li>包括12种类型的节点对象</li>
<li>常用了节点为document、标签元素节点、文本节点、注释节点</li>
<li>节点均继承自Node类型，所以拥有相同的属性或方法</li>
<li>document是DOM操作的起始节点</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body id=&quot;as&quot;&gt;</span><br><span class="line">  &lt;!-- 阿顺特烦恼 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	// document节点 noteType为9</span><br><span class="line">  console.log(document.nodeType)</span><br><span class="line">  </span><br><span class="line">  // 第一个子节点为&lt;!DOCTYPE html&gt;，且nodetype为10</span><br><span class="line">  console.log(document.childNodes.item(0).nodeType)</span><br><span class="line">  </span><br><span class="line">  // body 是标签节点 nodeType为1</span><br><span class="line">  console.log(document.body.nodeType) </span><br><span class="line">  </span><br><span class="line">  // body的属性节点nodeType 为2</span><br><span class="line">  console.log(document.body.attributes[0].nodeType)</span><br><span class="line">  </span><br><span class="line">	// body的第一个节点为文本节点，nodeType为3</span><br><span class="line">  console.log(document.body.childNodes.item(0).nodeType)</span><br><span class="line">  </span><br><span class="line">  // body的第二个节点为注释，nodeType类型为8</span><br><span class="line">  console.log(document.body.childNodes[1].nodeType)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在浏览器渲染过程中会将文档内容生成为不同的对象，来对下例中的h1标签进行讨论，其他节点情况相似</p>
<ul>
<li>不同类型节点由专有的构造函数创建对象</li>
<li>使用console.dir 可以打印出DOM节点对象结构</li>
<li>节点也是对象所以也具有JS对象的特征</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function prototype(el) &#123;</span><br><span class="line">    console.log(el.__proto__)</span><br><span class="line">    el.__proto__ ? prototype(el.__proto__) : &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  prototype(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最终得到的节点的原型链为</p>
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>根对象</td>
</tr>
<tr>
<td>EventTarget</td>
<td>提供事件支持</td>
</tr>
<tr>
<td>Node</td>
<td>提供parentNode等节点操作方法</td>
</tr>
<tr>
<td>Element</td>
<td>提供getElementsByTagName、querySelector等方法</td>
</tr>
<tr>
<td>HTMLElement</td>
<td>所有元素的基础类，提供className、nodeName等方法</td>
</tr>
<tr>
<td>HTMLHeadingElement</td>
<td>Head标题元素类</td>
</tr>
</tbody></table>
<p>为标签元素和表单元素添加内容截取方法substr</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Utils &#123;</span><br><span class="line">      	//检查是否为表单元素</span><br><span class="line">        static isForm(node) &#123;</span><br><span class="line">          return node instanceof HTMLInputElement;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取原型</span><br><span class="line">        static getPrototype(node) &#123;</span><br><span class="line">          let prototypes = [];</span><br><span class="line">          let test = node.__proto__;</span><br><span class="line">          if (test) &#123;</span><br><span class="line">            prototypes.push(test);</span><br><span class="line">            prototypes.push(...Utils.getPrototype(test));</span><br><span class="line">          &#125;</span><br><span class="line">          return prototypes;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      Node.prototype.substr = function (m, n) &#123;</span><br><span class="line">        if (Utils.isForm(this)) &#123;</span><br><span class="line">          return this.value.substr(m, n);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return this.innerText.substr(m, n);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      //表单测试</span><br><span class="line">      let input = document.querySelector(&quot;input&quot;);</span><br><span class="line">      console.log(input.substr(0, 2));</span><br><span class="line">      console.log(Utils.getPrototype(input));</span><br><span class="line">      //标签测试</span><br><span class="line">      let div = document.querySelector(&quot;div&quot;);</span><br><span class="line">      console.log(div.substr(0, 2));</span><br><span class="line">      console.log(Utils.getPrototype(div));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对象特征"><a href="#对象特征" class="headerlink" title="对象特征"></a>对象特征</h4><p>即然DOM与我们其他JS创建的对象特征相仿，所以也可以为DOM对象添加属性或方法。</p>
<p>对于系统应用的属性，应该明确含义不应该随意使用，比如ID是用于标识元素唯一属性，不能用于其他目地</p>
<ul>
<li>后会会讲到其他解决方案，来自定义属性，下面的直接修改ID属性是不建议的</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let as = document.getElementById(&quot;as&quot;);</span><br><span class="line">as.id = &quot;Ashun&quot;;</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>title用于鼠标停留时显示提示文档也不应该用于其他目地</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  as.title = &#x27;Ashun&#x27;</span><br><span class="line">  console.log(as)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是为对象合并属性的示例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  Object.assign(as, &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    change() &#123;</span><br><span class="line">      this.innerHTML = &#x27;Ashun&#x27;</span><br><span class="line">      this.style.color = this.color</span><br><span class="line">    &#125;,</span><br><span class="line">    onclick() &#123;</span><br><span class="line">      this.change()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>合并对象属性更改样式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  Object.assign(as.style, &#123;</span><br><span class="line">    color: &#x27;white&#x27;,</span><br><span class="line">    backgroundColor: &#x27;red&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DOCUMENT"><a href="#DOCUMENT" class="headerlink" title="DOCUMENT"></a>DOCUMENT</h3><p>document是window对象的属性，是由HTMLDocument类实现的实例。</p>
<ul>
<li>document包含 DocumentType（唯一）或 html元素（唯一）或 comment等元素</li>
</ul>
<p>原型链中也包含Node，所以可以使用有关节点操作的方法如nodeType/NodeName等</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.dir(document.nodeType)</span><br><span class="line">console.dir(document.nodeName)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关使用Document操作cookie与本地储存将会在相应章节中介绍</p>
</blockquote>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>下面通过节点的<code>nodeType</code>来获取html元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let html = [...document.childNodes].filter((node) =&gt; &#123;</span><br><span class="line">  if (node.nodeType === 1) &#123;</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)[0]</span><br><span class="line">console.log(html)</span><br></pre></td></tr></table></figure>

<p>获取整个html元素：<code>document.documentElement</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(document.documentElement)</span><br></pre></td></tr></table></figure>

<h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>使用<code>title</code>获取和设置文档标题</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取文档标题内容</span><br><span class="line">console.log(document.title)</span><br><span class="line"></span><br><span class="line">//设置文档标签内容</span><br><span class="line">document.title = &#x27;阿顺特烦恼-Ashun&#x27;</span><br></pre></td></tr></table></figure>

<p>获取<code>body</code>标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body</span><br></pre></td></tr></table></figure>

<p>获取当前<code>URL</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(document.URL)</span><br></pre></td></tr></table></figure>

<p><code>domain</code>获取域名</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain</span><br></pre></td></tr></table></figure>

<p><code>referrer</code>获取来源地址</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(document.referrer)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>不同类型的节点拥有不同属性，下面是节点属性的说明与示例</p>
<h4 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h4><p>nodeType指以数值返回节点类型</p>
<table>
<thead>
<tr>
<th>nodeType</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>元素节点</td>
</tr>
<tr>
<td>2</td>
<td>属性节点</td>
</tr>
<tr>
<td>3</td>
<td>文本节点</td>
</tr>
<tr>
<td>8</td>
<td>注释节点</td>
</tr>
<tr>
<td>9</td>
<td>document对象</td>
</tr>
</tbody></table>
<p>下面是节点nodeType的示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ashun&quot;&gt;&lt;!-- 阿顺特烦恼 --&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; document.querySelector(&#96;#app&#96;)</span><br><span class="line">  console.log(node.nodeType) &#x2F;&#x2F;1</span><br><span class="line">  console.log(node.firstChild);&#x2F;&#x2F; #text&#123;…&#125;</span><br><span class="line">  console.log(node.firstChild.nodeType) &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">  const as &#x3D; document.querySelector(&#39;.ashun&#39;)</span><br><span class="line">  console.log(as.childNodes[0].nodeType) &#x2F;&#x2F;8</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用对象的原型检测节点类型</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">let p = document.querySelector(&#x27;p&#x27;)</span><br><span class="line">console.log(h1 instanceof HTMLHeadingElement) //true</span><br><span class="line">console.log(p instanceof HTMLHeadingElement) //false</span><br><span class="line">console.log(p instanceof Element) //true</span><br></pre></td></tr></table></figure>

<p>下面递归获取所有标签元素，并返回符合html嵌套结构的数据。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=&quot;as&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;strong&gt;阿顺特烦恼&lt;/strong&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p1&gt;ashun&lt;span&gt;ashuna&lt;/span&gt;&lt;/p1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">				function childTag(node) &#123;</span><br><span class="line">          let result = [];</span><br><span class="line">          [...node.childNodes].map((v) =&gt; &#123;</span><br><span class="line">            if (v.nodeType === 1) &#123;</span><br><span class="line">              result.push(&#123; node: v, childs: childTag(v) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          return result;</span><br><span class="line">        &#125;</span><br><span class="line">        let as = document.getElementById(&quot;as&quot;);</span><br><span class="line">        console.log(childTag(as));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>优化：当没有子节点时，childs为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">result.push(&#123; node: v, childs: childTag(v).length ? childTag(v) : null &#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h4><p>nodeName指定节点的名称</p>
<ul>
<li>获取值为大写形式</li>
</ul>
<table>
<thead>
<tr>
<th>nodeType种类</th>
<th>nodeName返回结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>元素名称如DIV</td>
</tr>
<tr>
<td>2</td>
<td>属性名称</td>
</tr>
<tr>
<td>3</td>
<td>#text</td>
</tr>
<tr>
<td>8</td>
<td>#comment</td>
</tr>
</tbody></table>
<p>下面来操作 nodeName</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺特烦恼 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.nodeName) //DIV</span><br><span class="line">  console.log(node.firstChild.nodeName) //#text</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(as.childNodes[0].nodeName) //#comment</span><br><span class="line">  console.log(as.attributes.class.nodeName);//calss</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="tagName"><a href="#tagName" class="headerlink" title="tagName"></a>tagName</h4><p>nodeName可以获取不限于节点种类的名称，tagName仅能用于获取标签元素节点名称</p>
<ul>
<li>tagName存在于Element类的原型中</li>
<li>元素上使用tagName与nodeName无异</li>
<li>获取值为大写形式</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  console.log(node.tagName) //H1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h4><p>使用nodeValue或data函数获取节点值，也可以使用节点的data属性获取节点内容</p>
<table>
<thead>
<tr>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>3</td>
<td>文本内容</td>
</tr>
<tr>
<td>8</td>
<td>注释内容</td>
</tr>
</tbody></table>
<p>下面来看nodeValue的示例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.nodeValue) //null</span><br><span class="line">  console.log(node.innerHTML)</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.as&#x27;)</span><br><span class="line">  console.log(as.firstChild.nodeValue) //ASHUN</span><br><span class="line"></span><br><span class="line">  const ashun = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(ashun.childNodes[0].nodeValue) // 阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用data属性获取节点内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  阿顺特烦恼</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.childNodes[0].data)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="树状节点"><a href="#树状节点" class="headerlink" title="树状节点"></a>树状节点</h4><p>下面获取标签树状结构即多级标签结构，来加深一下nodeType/nodeName等知识</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function element(node) &#123;</span><br><span class="line">        if (node.nodeType != 1) return</span><br><span class="line"></span><br><span class="line">        return Array.from(node.childNodes)</span><br><span class="line">            .filter(node =&gt; node.nodeType == 1)</span><br><span class="line">            .map(node =&gt; (&#123;</span><br><span class="line">                name: node.nodeName,</span><br><span class="line">                children: element(node),</span><br><span class="line">            &#125;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let nodes = element(document.documentElement)</span><br><span class="line">    console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="节点集合"><a href="#节点集合" class="headerlink" title="节点集合"></a>节点集合</h3><p>Nodelist与HTMLCollection都是包含多个节点标签的集合，大部分功能也是相同的。</p>
<ul>
<li><code>getElementsBy...</code>等方法、<code>node.children</code> 返回的是HTMLCollection</li>
<li><code>querySelectorAll </code>、<code>node.childNodes</code> 返回的是 NodeList</li>
<li>二者都是<code>类数组</code>结构，可直接通过下标访问dom，但不能直接使用Array的方法，二者都可以迭代，二者也存在差异</li>
</ul>
<p><strong>HTMLCollection</strong></p>
<ul>
<li>不可使用<code>for/each</code>遍历</li>
<li>只是元素集合，包含dom元素</li>
</ul>
<p><strong>NodeList</strong></p>
<ul>
<li>可使用<code>for/each</code>遍历</li>
<li>querySelectorAll 返回的虽然是 NodeList ，但是实际上是元素集合（只包含元素），并且是静态的（其他接口返回的HTMLCollection和NodeList都是live的）</li>
<li>NodeList是节点集合（可以包含元素，也可以包含文本节点）</li>
</ul>
<p>nodelist包含文本节点</p>
<img src="C:/Users/张佳顺/Desktop/study1.assets/image-20210411170505383.png" alt="image-20210411170505383" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;a&quot;&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;cc&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">console.log(document.getElementsByClassName(&#39;a&#39;)[0].childNodes);&#x2F;&#x2F;nodelist</span><br><span class="line">console.log(document.getElementsByClassName(&#39;a&#39;)[0].children);&#x2F;&#x2F;Htmlcollection</span><br></pre></td></tr></table></figure>

<p>HTMLCollection不可使用for/each遍历操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let htmlCollection &#x3D; document.getElementsByClassName(&quot;shun&quot;);</span><br><span class="line">let nodeList &#x3D; document.querySelectorAll(&quot;.shun&quot;);</span><br><span class="line"></span><br><span class="line">nodeList.forEach((v) &#x3D;&gt; console.log(v));</span><br><span class="line">htmlCollection.forEach((v) &#x3D;&gt; console.log(v)); &#x2F;&#x2F;forEach is not a function</span><br></pre></td></tr></table></figure>



<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>Nodelist与HTMLCollection包含length属性，记录了节点元素的数量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    console.log(nodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h4><p>有时使用数组方法来操作节点集合，这就需要将节点集合转化为数组类型，有以下几种方式可以实现。</p>
<ol>
<li>使用call调用原型方法</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  let arr = Array.prototype.slice.call(elements, 0)</span><br><span class="line">  console.log(arr)</span><br><span class="line">  arr.map((item) =&gt; &#123;</span><br><span class="line">    item.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Array.from转换</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  console.log(Array.from(elements))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下面使用点语法转换节点为数组</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  ;[...elements].map((item) =&gt; &#123;</span><br><span class="line">    item.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">      this.style.textTransform = &#x27;uppercase&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="item"><a href="#item" class="headerlink" title="item"></a>item</h4><p>Nodelist与HTMLCollection提供了item()方法来根据索引获取元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes.item(0))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用数组索引获取更方便</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes[0])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="namedItem"><a href="#namedItem" class="headerlink" title="namedItem"></a>namedItem</h4><p>HTMLCollection具有namedItem方法可以按name或id属性来获取元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes.namedItem(&#x27;as&#x27;))</span><br><span class="line">   console.dir(nodes.namedItem(&#x27;astfn&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用属性方式获取</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes[&#x27;as&#x27;]);</span><br><span class="line">  console.dir(nodes.astfn)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>即HTMLCollection，可以通过属性的形式，获取对应 <code>索引、id属性、name属性</code> 的dom元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 name&#x3D;&quot;as&quot;&gt;ASHUN&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let items &#x3D; document.getElementsByTagName(&#39;h1&#39;)</span><br><span class="line">  console.log(items[0])</span><br><span class="line">  console.log(items[&quot;astfn&quot;])</span><br><span class="line">  console.log(items[&#39;as&#39;])</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="常用元素"><a href="#常用元素" class="headerlink" title="常用元素"></a>常用元素</h4><p>系统针对特定标签提供了快速选择的方式</p>
<p>下面展示的是获取所有a标签<code>document.links</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;&quot;&gt;Ashuntefannao&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.links;</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>获取特定元素方法如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>document.documentElement</td>
<td>文档节点即html标签节点</td>
</tr>
<tr>
<td>document.body</td>
<td>body标签节点</td>
</tr>
<tr>
<td>document.head</td>
<td>head标签节点</td>
</tr>
<tr>
<td>document.links</td>
<td>超链接集合</td>
</tr>
<tr>
<td>document.anchors</td>
<td>所有锚点集合</td>
</tr>
<tr>
<td>document.forms</td>
<td>form表单集合</td>
</tr>
<tr>
<td>document.images</td>
<td>图片集合</td>
</tr>
</tbody></table>
<hr>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>节点是父子级嵌套与前后兄弟关系，使用DOM提供的API可以获取这种关系的元素。</p>
<ul>
<li><strong>文本和注释也是节点，所以也在匹配结果中</strong></li>
<li>若只想获取dom元素，而不希望获得其它类型的节点，可以参考后续的<strong>元素关系</strong></li>
</ul>
<h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>节点是根据HTML内容产生的，所以也存在父子、兄弟、祖先、后代等节点关系，下例中的代码就会产生这种多重关系</p>
<ul>
<li>h1与ul是兄弟关系</li>
<li>span与li是父子关系</li>
<li>ul与span是后代关系</li>
<li>span与ul是祖先关系</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;Ashuntefannao&lt;/span&gt;</span><br><span class="line">    &lt;strong&gt;ashun&lt;/strong&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>下面是通过节点关系获取相应元素的方法</p>
<table>
<thead>
<tr>
<th>节点属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>childNodes</td>
<td>获取所有子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>获取父节点</td>
</tr>
<tr>
<td>firstChild</td>
<td>子节点中第一个</td>
</tr>
<tr>
<td>lastChild</td>
<td>子节点中最后一个</td>
</tr>
<tr>
<td>nextSibling</td>
<td>下一个兄弟节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>上一个兄弟节点</td>
</tr>
</tbody></table>
<p>子节点集合与首、尾节点获取</p>
<ul>
<li>文本也是node所以也会在匹配当中</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.childNodes) //所有子节点</span><br><span class="line">  console.log(node.firstChild) //第一个子节点是文本节点（换行符和空白字符）</span><br><span class="line">  console.log(node.lastChild) //最后一个子节点也是文本节点（换行符和空白字符）</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;astfn&quot; data&#x3D;&quot;as&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ashun&quot;&gt;阿顺&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; app.querySelector(&#96;.shun&#96;)</span><br><span class="line">  console.log(node.parentNode) &#x2F;&#x2F;div#app</span><br><span class="line">  console.log(node.childNodes) &#x2F;&#x2F;文本节点</span><br><span class="line">  console.log(node.nextSibling) &#x2F;&#x2F;下一个兄弟节点是文本节点（换行符和空白字符）</span><br><span class="line">  console.log(node.previousSibling) &#x2F;&#x2F;上一个节点也是文本节点（换行符和空白字符）</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>document是顶级节点html标签的父节点是document</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.parentNode === document)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下例是查找元素的所有父节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;as&quot;&gt;ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function parentNodes(node) &#123;</span><br><span class="line">    let nodes &#x3D; []</span><br><span class="line">    while ((node &#x3D; node.parentNode)) nodes.push(node)</span><br><span class="line">    return nodes</span><br><span class="line">  &#125;</span><br><span class="line">  const el &#x3D; document.getElementById(&#39;as&#39;)</span><br><span class="line">  const nodes &#x3D; parentNodes(el)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>获取所有的后代元素SPAN的内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span&gt;Ashuntefannao&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;</span><br><span class="line">    &lt;span&gt;ASHUN&lt;/span&gt;</span><br><span class="line">  &lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function getChildDom(parent, dom) &#123;</span><br><span class="line">  	let doms = [];</span><br><span class="line">  	for (let elem of parent.childNodes) &#123;</span><br><span class="line">   		if (elem.nodeName === dom.toUpperCase()) doms.push(elem);</span><br><span class="line">    	doms = doms.concat(getChildDom(elem, dom));</span><br><span class="line">      // doms.push(...getChildDom(elem, dom));</span><br><span class="line">  	&#125;</span><br><span class="line">   	return doms;</span><br><span class="line">  &#125;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const nodes = getChildNodeByName(app, &#x27;span&#x27;)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="元素关系"><a href="#元素关系" class="headerlink" title="元素关系"></a>元素关系</h3><p>使用childNodes等获取的节点<code>包括文本与注释</code>，但这不是我们常用的，系统也提供了只操作元素的方法。</p>
<table>
<thead>
<tr>
<th>节点属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>parentElement</td>
<td>获取父元素</td>
</tr>
<tr>
<td>children</td>
<td>获取所有子元素</td>
</tr>
<tr>
<td>childElementCount</td>
<td>子标签元素的数量</td>
</tr>
<tr>
<td>firstElementChild</td>
<td>第一个子标签</td>
</tr>
<tr>
<td>lastElementChild</td>
<td>最后一个子标签</td>
</tr>
<tr>
<td>previousElementSibling</td>
<td>上一个兄弟标签</td>
</tr>
<tr>
<td>nextElementSibling</td>
<td>下一个兄弟标签</td>
</tr>
<tr>
<td>contains</td>
<td>返回布尔值，判断传入的节点是否为该节点的后代节点</td>
</tr>
</tbody></table>
<p>以下实例展示怎样通过元素关系获取元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  console.log(app.children) //所有子元素</span><br><span class="line">  console.log(app.firstElementChild) //第一个子元素 div.astfn</span><br><span class="line">  console.log(app.lastElementChild) //最后一个子元素 div.ashun</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(as.parentElement) //父元素 div#app</span><br><span class="line"></span><br><span class="line">  console.log(as.previousElementSibling) //上一个兄弟元素 div.astfn</span><br><span class="line">  console.log(as.nextElementSibling) //下一个兄弟元素 div.ashun</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>html标签的父节点是document，但父标签节点不存在</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.parentNode === document) //true</span><br><span class="line">  console.log(document.documentElement.parentElement) //null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><p>系统提供了丰富的选择节点（NODE）的操作方法，下面我们来一一说明</p>
<h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h4><p>使用ID选择是非常方便的选择具有ID值的节点元素，但注意ID应该是唯一的</p>
<ul>
<li>只能通过document对象调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  console.dir(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面自定义函数来支持批量按ID选择元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function getByElementIds(ids) &#123;</span><br><span class="line">    return ids.map((id) =&gt; document.getElementById(id))</span><br><span class="line">  &#125;</span><br><span class="line">  let nodes = getByElementIds([&#x27;as&#x27;, &#x27;app&#x27;])</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>拥有ID的元素可做为WINDOW的属性进行访问</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果声明了变量这种访问方式将无效，所以并不建议使用这种方式访问对象</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = &#x27;ashun&#x27;</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>getElementById只能通过document访问，不能通过元素读取拥有ID的子元素，下面的操作将产生错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">  &lt;div id=&quot;as&quot;&gt;阿顺&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const node = app.getElementById(&#x27;as&#x27;) //app.getElementById is not a function</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementByName"><a href="#getElementByName" class="headerlink" title="getElementByName"></a>getElementByName</h4><p>使用getElementByName获取<strong>设置了name属性的元素</strong>，虽然在DIV等元素上同样有效，但一般用来对表单元素进行操作时使用。</p>
<ul>
<li>返回NodeList节点列表对象</li>
<li>NodeList顺序为元素在文档中的顺序</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const div = document.getElementsByName(&#x27;astfn&#x27;)</span><br><span class="line">  console.dir(div)</span><br><span class="line">  const input = document.getElementsByName(&#x27;username&#x27;)</span><br><span class="line">  console.dir(input)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h4><p>使用getElementsByTagName用于按标签名获取元素</p>
<ul>
<li>返回HTMLCollection元素集合</li>
<li>是不区分大小的获取</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const divs = document.getElementsByTagName(&#x27;DIV&#x27;)</span><br><span class="line">  console.dir(divs)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通配符</strong></p>
<p>可以使用通配符 ***** 获取所有元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;*&#x27;)</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h4><p>getElementsByClassName用于按class样式属性值获取元素集合</p>
<ul>
<li>设置多个值时顺序无关，指包含这些class属性的元素</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;astfn shun title&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByClassName(&#x27;shun&#x27;)</span><br><span class="line">  console.log(nodes.length) //2</span><br><span class="line"></span><br><span class="line">  //查找包含class属性包括 astfn 与 shun 的元素</span><br><span class="line">  const tags = document.getElementsByClassName(&#x27;astfn shun&#x27;)</span><br><span class="line">  console.log(tags.length) //1</span><br></pre></td></tr></table></figure>



<h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><h4 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h4><p>结合节点列表的length属性，使用for遍历</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    console.log(nodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Nodelist节点列表可以使用forEach来进行遍历，但HTMLCollection则不可以</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">  nodes.forEach((node, key) =&gt; &#123;</span><br><span class="line">    console.log(node)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>节点集合对象不是Array，原型中不存在map方法，但可以借用Array的原型map方法实现遍历</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">  Array.prototype.map.call(nodes, (node, index) =&gt; &#123;</span><br><span class="line">    console.log(node, index)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from用于将类数组转为组件，并提供第二个迭代函数。所以可以借用Array.from实现遍历</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  Array.from(nodes, (node, index) =&gt; &#123;</span><br><span class="line">    console.log(node, index)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以先使用Array.from将节点列表转为Array，再使用Array的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div name&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class="line">  let astfn&#x3D;Array.from(nodes).filter(v&#x3D;&gt;v.id&#x3D;&#x3D;&#x3D;&quot;astfn&quot;);</span><br><span class="line">  console.log(astfn)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="forOf"><a href="#forOf" class="headerlink" title="forOf"></a>forOf</h4><p>节点集合是类数组的可迭代对象所以可以使用for…of进行遍历</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (const item of nodes) &#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>也可使用<code>for/of</code>结合Object迭代器进行遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div name&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class="line">  for (let [key, dom] of Object.entries(nodes)) &#123;</span><br><span class="line">        console.log(key, dom);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (let key of Object.keys(nodes)) console.log(key);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (let dom of Object.values(nodes)) console.log(dom);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h3><p>在CSS中可以通过样式选择器修饰元素样式，在DOM操作中也可以使用这种方式查找元素。使用过jQuery库的朋友，应该对这种选择方式印象深刻。</p>
<p>使用getElementsByTagName等方式选择元素不够灵活，建议使用下面的样式选择器操作，更加方便灵活</p>
<h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h4><p>使用querySelectorAll根据CSS选择器获取Nodelist节点列表</p>
<ul>
<li><code>获取的NodeList节点列表是静态的，添加或删除元素后不变</code></li>
<li>可以链式调用，即 既是document的接口，也是dom元素的接口。可以获取对应dom的子孙dom</li>
</ul>
<p>获取所有div元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; document.getElementById(&#39;app&#39;)</span><br><span class="line">  const nodes &#x3D; app.querySelectorAll(&#39;div&#39;)</span><br><span class="line">  console.log(nodes.length) &#x2F;&#x2F;2</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>可以在其中应用css选择器规则，获取对应的节点列表</p>
<ul>
<li>获取id为app的dom中class为ashun的子节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; class&#x3D;&quot;ashun&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let nodes&#x3D;document.querySelectorAll(&quot;#app .ashun&quot;);</span><br><span class="line"> console.log(nodes.length);&#x2F;&#x2F;2</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据属性选择器获取元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; data&#x3D;&quot;as&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let nodes&#x3D;document.querySelectorAll(&quot;#app [data&#x3D;&#39;as&#39;]&quot;);</span><br><span class="line"> console.log(nodes[0]);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h4><p>querySelector使用CSS选择器获取一个元素，下面是根据属性获取单个元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot; data=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = app.querySelector(`#astfn[data=&#x27;as&#x27;]`)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>若存在多个相同属性的元素，则只获取第一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; class&#x3D;&quot;ashun&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; app.querySelector(&#96;.ashun&#96;)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="matches"><a href="#matches" class="headerlink" title="matches"></a>matches</h4><p><code>node.matches(cssSelector)</code>用于检测<strong>某元素</strong>是否与 <strong>指定的样式选择器匹配</strong>，下面过滤掉所有name属性的LI元素。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;li&gt;Ashuntefannao&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;ASHUN&lt;/li&gt;</span><br><span class="line">  &lt;li name=&quot;as&quot;&gt;阿顺&lt;/li&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const nodes = [...app.querySelectorAll(&#x27;li&#x27;)].filter((node) =&gt; &#123;</span><br><span class="line">    return !node.matches(`[name]`)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="closest"><a href="#closest" class="headerlink" title="closest"></a>closest</h4><p>查找最近的符合选择器的祖先元素（包括自身），下例查找父级拥有 <code>.comment</code>类的元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;comment&quot;&gt;</span><br><span class="line">  &lt;ul class=&quot;comment&quot;&gt;</span><br><span class="line">    &lt;li&gt;阿顺特烦恼&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const li = document.getElementsByTagName(&#x27;li&#x27;)[0]</span><br><span class="line">  const node = li.closest(`.comment`)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="动态与静态获取"><a href="#动态与静态获取" class="headerlink" title="动态与静态获取"></a>动态与静态获取</h3><ul>
<li><p>下面讨论的是 元素/节点<strong>集合</strong> 的动态与静态，而不是某个元素/节点的动态与静态。</p>
</li>
<li><p>获取某个元素都是静态的。</p>
</li>
</ul>
<p>通过 getElementsByTagname 等getElementsBy… 函数获取的Nodelist与HTMLCollection集合是动态的，即有元素添加或移动操作将实时反映最新状态。</p>
<ul>
<li>使用getElement…返回的都是动态的集合</li>
<li>使用querySelectorAll返回的是静态集合</li>
</ul>
<h4 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h4><p>下例中通过按钮动态添加元素后，获取的元素集合是动态的，而不是上次获取的固定快照。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;button id=&quot;add&quot;&gt;添加元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  let button = document.querySelector(&#x27;#add&#x27;)</span><br><span class="line">  button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    document.querySelector(&#x27;body&#x27;).insertAdjacentHTML(&#x27;beforeend&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)</span><br><span class="line">    console.log(elements)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<p>document.querySelectorAll获取的集合是静态的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;button id=&quot;add&quot;&gt;添加元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.querySelectorAll(&#x27;h1&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(elements.length)</span><br><span class="line">  let button = document.querySelector(&#x27;#add&#x27;)</span><br><span class="line">  button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    document.querySelector(&#x27;body&#x27;).insertAdjacentHTML(&#x27;beforeend&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)</span><br><span class="line">    console.log(elements.length)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用静态"><a href="#使用静态" class="headerlink" title="使用静态"></a>使用静态</h4><p>如果需要保存静态集合，则需要对集合进行复制</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  const clone = Array.prototype.slice.call(nodes)</span><br><span class="line">  console.log(nodes.length);//2</span><br><span class="line">  document.body.appendChild(document.createElement(&#x27;div&#x27;))</span><br><span class="line">  console.log(nodes.length);//3</span><br><span class="line">  console.log(clone.length);//2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h3><p>即在js中能够直接通过属性的方式，访问/操作DOM元素的属性。元素的标准属性具有相对应的DOM对象属性</p>
<ul>
<li>操作属性<code>区分大小写</code></li>
<li>多个单词属性命名规则为第一个单词小写，其他单词驼峰式命名</li>
<li>属性值是多类型并不全是字符串，也可能是对象等</li>
<li>事件处理程序属性值为函数</li>
<li>style属性为CSSStyleDeclaration对象</li>
<li>DOM对象不同生成的属性也不同</li>
</ul>
<h4 id="属性别名"><a href="#属性别名" class="headerlink" title="属性别名"></a>属性别名</h4><p>有些属性名与JS关键词冲突，系统已经起了别名</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>className</td>
</tr>
<tr>
<td>for</td>
<td>htmlFor</td>
</tr>
</tbody></table>
<h4 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h4><p>元素的标准属性可以直接进行操作，下面是直接设置元素的className</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;Ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  app.className = &#x27;astfn ashun&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面设置图像元素的标准属性</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let img = document.images[0]</span><br><span class="line">  img.src = &#x27;https://www.Ashuntefannao.com/icon.jpg&#x27;</span><br><span class="line">  img.alt = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用hidden隐藏元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.hidden = true</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过style属性改变行内样式</p>
<ul>
<li>js操作Dom属性时，多个单词属性命名规则为第一个单词小写，其他单词驼峰式命名</li>
<li>js中的背景颜色<code>backgroundColor</code>,css中<code>backgorund-color</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; document.querySelector(&#39;#app&#39;)</span><br><span class="line">  app.addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    this.style.backgroundColor &#x3D; &quot;red&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="多类型值"><a href="#多类型值" class="headerlink" title="多类型值"></a>多类型值</h4><p>大部分属性值是都是字符串，但并不是全部，下例中需要转换为数值后进行数据运算</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;age&quot; value=&quot;88&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let input = document.getElementsByName(&#x27;age&#x27;).item(0)</span><br><span class="line">  input.value = parseInt(input.value) + 100</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面表单checked属性值为Boolean类型</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;hot&quot;&gt; &lt;input id=&quot;hot&quot; type=&quot;checkbox&quot; name=&quot;hot&quot; /&gt;热门 &lt;/label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`[name=&#x27;hot&#x27;]`)</span><br><span class="line">  node.addEventListener(&#x27;change&#x27;, function () &#123;</span><br><span class="line">    console.log(this.checked)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>属性值<code>并非</code>都与HTML定义的值一样，下面返回的href属性值是完整链接</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#Ashuntefannao&quot; id=&quot;home&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#home`)</span><br><span class="line">  console.log(node.href)	</span><br><span class="line">  //http://127.0.0.1:5500/dom.html#Ashuntefannao</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="元素特征"><a href="#元素特征" class="headerlink" title="元素特征"></a>元素特征</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>对于标准的属性可以直接通过DOM属性的方式进行操作，但对于标签的 非标准的定制属性 则不可以。但JS提供了方法来控制标准或非标准的属性</p>
<p>可以理解为元素的属性分两个地方保存，DOM属性中记录标准属性，特征中记录标准和定制属性</p>
<ul>
<li>使用特征操作时属性名称不区分大小写</li>
<li>特征值都为字符串类型</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getAttribute(“prop”)</td>
<td>获取属性值</td>
</tr>
<tr>
<td>setAttribute(“prop”,”value”)</td>
<td>设置属性/添加属性</td>
</tr>
<tr>
<td>removeAttribute(“prop”)</td>
<td>删除属性</td>
</tr>
<tr>
<td>hasAttribute(“prop”)</td>
<td>属性检测</td>
</tr>
</tbody></table>
<p>特征是可迭代对象，下面使用for…of来进行遍历操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;add&quot; class&#x3D;&quot;add&quot;&gt;添加元素&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     let attrs &#x3D; document.querySelector(&quot;#add&quot;).attributes;</span><br><span class="line">      console.log(attrs);	&#x2F;&#x2F;NamedNodeMap &#123;…&#125;</span><br><span class="line">      for (const &#123; name, value &#125; of nameNodeMap) &#123;</span><br><span class="line">        console.log(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>getAttribute</code>获取的属性值都为<code>字符串</code>，所以若要获取数值类型需要进行转换</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;age&quot; value=&quot;88&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let input = document.getElementsByName(&#x27;age&#x27;).item(0)</span><br><span class="line">  let value = input.getAttribute(&#x27;value&#x27;) * 1 + 100</span><br><span class="line">  input.setAttribute(&#x27;value&#x27;, value)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用removeAttribute删除元素的class属性，并通过hasAttribute进行检测删除结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;ashun&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  as.removeAttribute(&#x27;class&#x27;)</span><br><span class="line">  console.log(as.hasAttribute(&#x27;class&#x27;)) //false</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>特征值与HTML定义的值是<code>一致的</code>，这和标准属性进行访问是不同的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#Ashuntefannao&quot; id=&quot;home&quot;&gt;后盾人&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#home`)</span><br><span class="line">  </span><br><span class="line">  // http://127.0.0.1:5500/dom.html#Ashuntefannao</span><br><span class="line">  console.log(node.href)</span><br><span class="line">  </span><br><span class="line">  // #Ashuntefannao</span><br><span class="line">  console.log(node.getAttribute(&#x27;href&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><p>元素提供了attributes 属性可以只读的获取元素的属性</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-content=&quot;阿顺&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)；</span><br><span class="line">  console.log(astfn.attributes);</span><br><span class="line">  console.dir(astfn.attributes[&#x27;class&#x27;].nodeValue) //astfn</span><br><span class="line">  console.dir(astfn.attributes[&#x27;data-content&#x27;].nodeValue) //阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="自定义特征"><a href="#自定义特征" class="headerlink" title="自定义特征"></a>自定义特征</h4><p>虽然可以随意定义特征并使用getAttribute等方法管理，但很容易造成与标签的现在或未来属性重名。建议使用以data-为前缀的自定义特征处理，针对这种定义方式JS也提供了接口方便操作。</p>
<ul>
<li>元素中以data-为前缀的属性会添加到内置的data属性集中</li>
<li>使用<code>dom.dataset</code>可获取对应dom的data属性集</li>
<li>改变dataset的值也会影响到元素上</li>
</ul>
<p>下面演示使用属性集设置DIV标签内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-content=&quot;阿顺特烦恼&quot; data-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  let content = astfn.dataset.content</span><br><span class="line">  console.log(content) //阿顺特烦恼</span><br><span class="line">  astfn.innerHTML = `&lt;span style=&quot;color:$&#123;astfn.dataset.color&#125;&quot;&gt;$&#123;content&#125;&lt;/span&gt;`</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>多个单词的特征使用驼峰命名方式读取</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-title-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  astfn.innerHTML = `</span><br><span class="line">    &lt;span style=&quot;color:$&#123;astfn.dataset.titleColor&#125;&quot;&gt;$&#123;astfn.innerHTML&#125;&lt;/span&gt;</span><br><span class="line">  `</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>改变dataset值也会影响到页面元素上</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;astfn&quot; data-title-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  astfn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.dataset.titleColor = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;][Math.floor(Math.random() * 3)]</span><br><span class="line">    this.style.color = this.dataset.titleColor</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h4><p>特征和标准属性，是记录元素属性的两个不同场所，<code>大部分更改会进行同步操作</code>。</p>
<ul>
<li>有些情况，通过标准属性更改，不能同步到元素特征，但元素特征的更改，能够同步到标准属性</li>
<li>推荐使用属性特征方法</li>
</ul>
<p>下面使用属性更改了className，会自动同步到了特征集中，反之亦然</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;red&quot;&gt;ASHUNTEFANNAO&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.className = &#x27;astfn&#x27;</span><br><span class="line">  console.log(app.getAttribute(&#x27;class&#x27;)) //astfn</span><br><span class="line">  app.setAttribute(&#x27;class&#x27;, &#x27;blue&#x27;)</span><br><span class="line">  console.log(app.className) //blue</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面对input值使用标准属性设置，<strong>但并没有同步到特征</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;package&quot; value=&quot;Ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const package = document.querySelector(`[name=&#x27;package&#x27;]`)</span><br><span class="line">  package.value = &#x27;阿顺&#x27;</span><br><span class="line">  console.log(package.getAttribute(&#x27;value&#x27;))//Ashuntefannao</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但改变input的特征value会同步到DOM对象的标准属性</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;package&quot; value=&quot;Ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const package = document.querySelector(`[name=&#x27;package&#x27;]`)</span><br><span class="line">  package.setAttribute(&#x27;value&#x27;, &#x27;阿顺&#x27;)</span><br><span class="line">  console.log(package.value) //阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>创建节点的就是构建出DOM对象，然后根据需要添加到其他节点中</p>
<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建文本节点并添加到元素中</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let text = document.createTextNode(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.append(text)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>使用createElement方法可以标签节点，下例创建span标签新节点并添加到div#app</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let span = document.createElement(&#x27;span&#x27;)</span><br><span class="line">  span.innerHTML = &#x27;Ashun&#x27;</span><br><span class="line">  app.append(span)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用PROMISE结合节点操作来加载外部JAVASCRIPT文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function js(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let js = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    js.type = &#x27;text/javascript&#x27;</span><br><span class="line">    js.src = file</span><br><span class="line">    js.onload = resolve</span><br><span class="line">    js.onerror = reject</span><br><span class="line">    document.head.appendChild(js)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js(&#x27;11.js&#x27;)</span><br><span class="line">  .then(() =&gt; console.log(&#x27;加载成功&#x27;))</span><br><span class="line">  .catch((error) =&gt; console.log(`$&#123;error.target.src&#125; 加载失败`))</span><br></pre></td></tr></table></figure>

<p>使用同样的逻辑来实现加载CSS文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function css(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let css = document.createElement(&#x27;link&#x27;)</span><br><span class="line">    css.rel = &#x27;stylesheet&#x27;</span><br><span class="line">    css.href = file</span><br><span class="line">    css.onload = resolve</span><br><span class="line">    css.onerror = reject</span><br><span class="line">    document.head.appendChild(css)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">css(&#x27;1.css&#x27;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;加载成功&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="cloneNode-amp-importNode"><a href="#cloneNode-amp-importNode" class="headerlink" title="cloneNode&amp;importNode"></a>cloneNode&amp;importNode</h4><p>使用cloneNode和document.importNode用于复制节点对象操作</p>
<ul>
<li>cloneNode是节点的方法：<code>dom.cloneNode(boolean)</code></li>
<li>cloneNode 参数为true时递归复制子节点即深拷贝</li>
<li>importNode是documet对象方法：<code>document.importNode(elem,boolean)</code></li>
</ul>
<p><code>dom.cloneNode(true)</code>复制div#app节点及其子节点，并添加到body元素中</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let newApp = app.cloneNode(true)</span><br><span class="line">  document.body.appendChild(newApp)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>dom.cloneNode(false)</code>只clone目标节点本身,不递归复制子节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	const node &#x3D; document.querySelector(&#96;#app&#96;);</span><br><span class="line">	let newNode &#x3D; node.cloneNode(false);</span><br><span class="line">	console.log(newNode);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>document.importNode(elem,boolean)</code>方法是低版本IE浏览器不支持的，也是复制节点对象的方法</p>
<ul>
<li>第一个参数为节点对象</li>
<li>第二个参数为true时递归复制</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let newApp = document.importNode(app, true)</span><br><span class="line">  document.body.appendChild(newApp)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="节点内容"><a href="#节点内容" class="headerlink" title="节点内容"></a>节点内容</h3><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>inneHTML用于向标签中添加html内容，同时触发浏览器的解析器<code>重绘DOM</code>。</p>
<p>下例使用innerHTML获取和设置div内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span&gt;阿顺特烦恼&lt;/span&gt;</span><br><span class="line">  &lt;div class=&quot;as&quot;&gt;Ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line"></span><br><span class="line">  app.innerHTML = &#x27;&lt;h1&gt;阿顺&lt;/h1&gt;&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重绘节点</strong></p>
<p>使用innertHTML操作会重绘元素，下面在点击第二次就没有效果了</p>
<ul>
<li>因为对#app内容进行了重绘，即删除原内容然后设置新内容</li>
<li>重绘后产生的button对象<code>也没有了事件</code></li>
<li>重绘后又产生了新img对象，所以在控制台中可看到新图片在加载</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;button&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">  &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    alert(this.innerHTML)</span><br><span class="line">    this.parentElement.innerHTML += &#x27;&lt;hr/&gt;阿顺特烦恼&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h4><p>outerHTML与innerHTML的区别是包含父标签</p>
<ul>
<li>outerHTML不会删除原来的旧元素</li>
<li>只是用新内容替换替换旧内容，旧内容（标签元素）依然存在<ul>
<li>设置后，再次打印获取dom或outerHTML还是原来的旧内容，但界面已经发生了更改</li>
</ul>
</li>
</ul>
<p>下面将div#app替换为新内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.outerHTML = &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用innerHTML内容是被删除然后使用新内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app)</span><br><span class="line">  app.innerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>而使用outerHTML是保留旧内容，页面中使用新内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app,app.outerHTML)</span><br><span class="line">  app.outerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(app,app.outerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="innerText与textContent"><a href="#innerText与textContent" class="headerlink" title="innerText与textContent"></a>innerText与textContent</h4><p>textContent与innerText是访问或添加文本内容到元素中</p>
<ul>
<li>textContent部分IE浏览器版本不支持</li>
<li>innerText部分FireFox浏览器版本不支持</li>
<li>获取时忽略所有标签,只获取文本内容</li>
<li>设置时将内容中的标签当文本对待不进行标签解析</li>
</ul>
<p>获取时忽略内容中的所有标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.textContent)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置内容时会将标签当普通文本对待，即转为HTML实体内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.textContent=&quot;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="outerText"><a href="#outerText" class="headerlink" title="outerText"></a>outerText</h4><p>与innerText差别是：outerText会所操作标签本身，innerText操作标签内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  h1.outerText = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(document.querySelector(&#x27;h1&#x27;)); //null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentText"><a href="#insertAdjacentText" class="headerlink" title="insertAdjacentText"></a>insertAdjacentText</h4><p><code>insertAdjacentText(position,str)</code></p>
<p>将文本插入到元素指定位置，不会对文本中的标签进行解析，包括以下位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>添加文本内容到div#app前面</p>
<ul>
<li>使用<code>insertAdjacentText</code>方法，只能追加普通文本，不会解析其中的HTML标签</li>
<li>若想要追加包含HTML标签的文本，并希望对其解析，可以使用后续章节<strong>节点管理</strong>中的<code>insertAdjacentHTML</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;hd&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.insertAdjacentText(&#x27;beforebegin&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)  //不会解析HTML标签</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><p>现在我们来讨论下节点元素的管理，包括添加、删除、替换等操作</p>
<h4 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>dom.append(elem/str)</code></td>
<td>节点内尾部添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.prepend(elem/str)</code></td>
<td>节点内开头添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.before(elem/str)</code></td>
<td>节点前面添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.after(elem/str)</code></td>
<td>节点后面添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.replaceWith(elem/str)</code></td>
<td>将节点替换为新节点或字符串</td>
</tr>
<tr>
<td><code>dom.remove()</code></td>
<td>删除节点</td>
</tr>
</tbody></table>
<p>在标签内容后面添加新内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.append(&#x27;-阿顺特烦恼&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>同时添加多个内容，包括字符串与元素标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.append(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.append(&#x27;@&#x27;, h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将标签替换为新内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.append(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.replaceWith(h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>添加新元素h1到目标元素div#app里面</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.innerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  app.append(h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将h2移动到h1之前</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Ashuntefannao&lt;/h2&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  let h2 = document.querySelector(&#x27;h2&#x27;)</span><br><span class="line">  h1.before(h2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用remove方法可以删除节点</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.remove()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentHTML"><a href="#insertAdjacentHTML" class="headerlink" title="insertAdjacentHTML"></a>insertAdjacentHTML</h4><p><code>insertAdjacentHTML(position,str)</code></p>
<p>将html文本插入到元素指定位置，浏览器会对文本进行标签解析，包括以下位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>在div#app前添加HTML文本</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;hd&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.insertAdjacentHTML(&#x27;beforebegin&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentElement"><a href="#insertAdjacentElement" class="headerlink" title="insertAdjacentElement"></a>insertAdjacentElement</h4><p><code>insertAdjacentElement(position,elem)</code></p>
<p>insertAdjacentElement() 方法将指定元素插入到元素的指定位置，包括以下位置</p>
<ul>
<li>第一个参数是位置</li>
<li>第二个参数为<strong>新元素节点</strong></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>在div#app 标签前插入span标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;astfn&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app &#x3D; document.querySelector(&#39;#app&#39;)</span><br><span class="line">  let span &#x3D; document.createElement(&#39;span&#39;)</span><br><span class="line">  span.innerHTML &#x3D; &#39;阿顺特烦恼&#39;</span><br><span class="line">  app.insertAdjacentElement(&#39;beforebegin&#39;, span)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="古老方法"><a href="#古老方法" class="headerlink" title="古老方法"></a>古老方法</h4><p>下面列表过去使用的操作节点的方法，现在不建议使用了。但在阅读老代码时可来此查看语法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appendChild</td>
<td>添加节点</td>
</tr>
<tr>
<td>insertBefore</td>
<td>用于插入元素到另一个元素的前面</td>
</tr>
<tr>
<td>removeChild</td>
<td>删除节点</td>
</tr>
<tr>
<td>replaceChild</td>
<td>进行节点的替换操作</td>
</tr>
</tbody></table>
<h4 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h4><p>在了解DocumentFragment之前，我们先了解一下页面的呈现、回流、重绘的过程。</p>
<h5 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h5><p>页面呈现、重绘、回流。</p>
<h6 id="界面呈现"><a href="#界面呈现" class="headerlink" title="界面呈现"></a>界面呈现</h6><blockquote>
<p>获取html解析为Dom tree–&gt;获取css样式解析为样式结构体–&gt;Dom tree与样式结构体结合形成render tree</p>
</blockquote>
<ol>
<li><p>```<br>浏览器把获取到的html代码解析成1个Dom树，html中的每个tag都是Dom树中的1个节点，根节点就是我们常用的document对象(<html> tag)。dom树就是我们用开发者工具看到的html结构，里面包含了所有的html tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;</span><br><span class="line">   浏览器把所有样式(主要包括css和浏览器的样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>dom tree和 样式结构体 结合后构建 呈现树(render tree)<br>render tree有点类似于dom tree，但其实区别有很大，render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，所以就不会包含到render tree中。<br>注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据css2的标准，render tree中的每个节点都称为box，box所有属性：width,height,margin,padding,left,top,border等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;</span><br><span class="line">   一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="界面回流"><a href="#界面回流" class="headerlink" title="界面回流"></a>界面回流</h6><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>影响布局的操作都会产生回流，发生回流(节点重新构建)一定会触发重绘。</p>
<h6 id="界面重绘"><a href="#界面重绘" class="headerlink" title="界面重绘"></a>界面重绘</h6><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
<p>界面重绘不一定存在界面回流。</p>
<hr>
<h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>当对节点进行添加、删除等操作时，都会引起页面回流来重新构建DOM渲染页面,</p>
<p><strong>解决以上问题可以使用以下几种方式</strong></p>
<ol>
<li>可以将DOM写成html字符串，然后使用innerHTML添加到页面中，但这种操作会比较麻烦，且不方便使用节点操作的相关方法。</li>
<li>使用createDocumentFragment来管理节点时，此时节点都在内存中，而不是DOM树中。对节点的操作不会引发页面回流,带来比较好的性能体验。</li>
</ol>
<p><strong>DocumentFragment特点</strong></p>
<ul>
<li>createDocumentFragment父节点为null</li>
<li>继承自node所以可以使用NODE的属性和方法</li>
<li>createDocumentFragment创建的是文档碎片，节点类型nodeType为11。因为不在DOM树中所以只能通过JS进行操作</li>
<li>添加createDocumentFragment添加到DOM后,就不可以再操作createDocumentFragment元素了,这与DOM操作是不同的</li>
<li>将文档DOM添加到createDocumentFragment时,会移除文档中的DOM元素</li>
<li>createDocumentFragment创建的节点添加到其他节点上时，会将子节点一并添加</li>
<li>createDocumentFragment是虚拟节点对象，不直接操作DOM所以性能更好</li>
<li>在排序/移动等大量DOM操作时建议使用createDocumentFragment</li>
</ul>
<h3 id="表单控制"><a href="#表单控制" class="headerlink" title="表单控制"></a>表单控制</h3><p>表单是高频操作的元素，下面来掌握表单项的DOM操作</p>
<h4 id="表单查找"><a href="#表单查找" class="headerlink" title="表单查找"></a>表单查找</h4><p>JS为表单的操作提供了单独的集合控制</p>
<ul>
<li>使用<code>document.forms</code>获取表单集合</li>
<li>使用<code>document.forms.formName</code>获取对应name属性的form表单</li>
<li>使用<code>form.elements.inputName\form.inputName</code>获取form中对应name属性的input表单元素</li>
<li>针对radio/checkbox获取的表单项是一个集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&quot; name&#x3D;&quot;from1&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;form1_input&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const form &#x3D; document.forms.form1</span><br><span class="line">  console.log(form.elements.form1_input)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>通过表单项可以反向查找FORM</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; name=&quot;form1&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;form1_input&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const form = document.forms.form1</span><br><span class="line">  console.log(form.form1_input.form === form) //true</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h3><p>通过DOM修改样式可以通过更改元素的class属性或通过style对象设置行样式来完成。</p>
<ul>
<li>建议使用class控制样式，将任务交给CSS处理，更简单高效</li>
</ul>
<h4 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置"></a>批量设置</h4><ul>
<li>使用<code>className</code>或<code>setAttribute</code>设置calss属性，<strong>会覆盖原来的类名</strong></li>
</ul>
<p>使用JS的className可以批量设置样式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.className = &#x27;astfn&#x27;</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过特征的方式来更改</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.setAttribute(&#x27;class&#x27;, &#x27;astfn&#x27;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h4><p>classList操作的是class属性列表，用于操作单个className，不会影响其它的className。如果对类单独进行控制使用 classList属性操作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>node.classList.add</td>
<td>添加类名</td>
</tr>
<tr>
<td>node.classList.remove</td>
<td>删除类名</td>
</tr>
<tr>
<td>node.classList.toggle</td>
<td>切换类名</td>
</tr>
<tr>
<td>node.classList.contains</td>
<td>类名检测</td>
</tr>
</tbody></table>
<p>在元素的原有class上添加新class</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.classList.add(&quot;ashun&quot;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用classList也可以移除class列表中的某个class</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.classList.remove(&#x27;container&#x27;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用toggle切换类，即类已经存在时删除，不存在时添加</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.classList.toggle(&#x27;astfn&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用contains检查class是否存在</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  console.log(app.classList.contains(&#x27;container&#x27;)) //true</span><br><span class="line">  console.log(app.classList.contains(&#x27;as&#x27;)) //false</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="设置行样式"><a href="#设置行样式" class="headerlink" title="设置行样式"></a>设置行样式</h4><p>通过style对象可以对行内样式属性单独设置，使用cssText可以批量设置行内样式</p>
<blockquote>
<p>直接通过dom.prop能够访问/修改节点的对应属性,那么这个属性就是之前讲到的标准属性.</p>
<p>通过style能够直接访问/修改 节点的样式属性 , 即操作的都是行内样式.</p>
</blockquote>
<p><strong>样式属性设置</strong></p>
<p>使用节点的style对象来设置行样式</p>
<ul>
<li>多个单词的属性使用驼峰进行命名</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line">  app.style.color = &#x27;yellow&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>批量设置行样式</strong></p>
<p>使用 <code>cssText=&quot;...cssStr&quot;</code>属性可以批量设置行样式，<strong>属性名和写CSS一样不需要考虑驼峰命名</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.style.cssText = `background-color:red;color:yellow`</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>setAttribute</code>改变style特征来批量设置样式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.setAttribute(&#x27;style&#x27;, `background-color:red;color:yellow;`)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h4><ul>
<li>可通过<code>dom.style.prop</code>或<code>getAttribute</code>获取行内样式</li>
<li>可通过<code>window.getComputedStyle(dom).prop</code>对象获取样式属性，下面进行说明</li>
</ul>
<p><code>style</code>和<code>getAttribute</code>只能获取行样式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">    background-color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app = document.getElementById(&quot;app&quot;);</span><br><span class="line"></span><br><span class="line">      function getLineStyle(dom) &#123;</span><br><span class="line">        console.log(`getAttribute---$&#123;dom.getAttribute(&quot;style&quot;)&#125;`);</span><br><span class="line">        console.log(`dom.stype.prop---$&#123;dom.style.backgroundColor&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">        getLineStyle(app);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          app.style.backgroundColor = &quot;yellowgreen&quot;;</span><br><span class="line">          getLineStyle(app);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><strong>getComputedStyle</strong></p>
<p>使用window.getComputedStyle可获取所有应用在元素上的样式属性</p>
<ul>
<li>函数第一个参数为元素</li>
<li>第二个参数为伪类</li>
<li>获取计算后的样式属性，是所有样式复合的结果 , 所以取得的单位和定义时的可能会有不同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">    background-color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app &#x3D; document.getElementById(&quot;app&quot;);</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(window.getComputedStyle(app).backgroundColor);</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          app.style.backgroundColor &#x3D; &quot;yellowgreen&quot;;</span><br><span class="line">          console.log(window.getComputedStyle(app).backgroundColor);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>window.getComputedStyle获取的是计算后的样式属性 , 是所有样式复合的结果</p>
<ul>
<li>由于行内样式优先级别高 , 所以打印的是蓝色对应的rgb值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div &#123;</span><br><span class="line">	background-color: black;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id&#x3D;&quot;app&quot; style&#x3D;&quot;background-color: blue&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app &#x3D; document.getElementById(&quot;app&quot;);</span><br><span class="line">      console.log(window.getComputedStyle(app).backgroundColor);  &#x2F;&#x2F;rgb(0,0,255)</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise%E6%A0%B8%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise%E6%A0%B8%E5%BF%83/" class="post-title-link" itemprop="url">Promise核心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:40:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:40:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:08:17" itemprop="dateModified" datetime="2021-05-17T09:08:17+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise核心"><a href="#Promise核心" class="headerlink" title="Promise核心"></a>Promise核心</h2><p>本章来自己开发一个Promise实现，提升异步编程的能力。</p>
<h3 id="起步构建"><a href="#起步构建" class="headerlink" title="起步构建"></a>起步构建</h3><p>首先声明定义类并声明Promise状态与值，有以下几个细节需要注意。</p>
<ul>
<li>executor为执行者</li>
<li>当执行者出现异常时触发<strong>拒绝</strong>状态，并异步抛出错误<ul>
<li>如果直接抛出错误，在打印时，看不到PROMISE本身的状态与值，所以将抛出错误放在异步宏任务中</li>
<li>这个结果和原生Promsie是相同的</li>
</ul>
</li>
<li>使用静态属性保存状态值</li>
<li>状态只能改变一次，所以在resolve与reject添加条件判断</li>
<li>因为 <code>resolve</code>或<code>rejected</code>方法在executor中调用，作用域也是executor作用域，这会造成在外部确认状态时：this指向window，现在我们使用的是class定义，this为undefined。所以我们要改变this指向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class PROMISE &#123;</span><br><span class="line">  static PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">  static FULFILLED &#x3D; &quot;fulfilled&quot;;</span><br><span class="line">  static REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.value &#x3D; undefined;</span><br><span class="line">    this.status &#x3D; PROMISE.PENDING;</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      this.reject(err);</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        throw err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.status &#x3D; PROMISE.FULFILLED;</span><br><span class="line">      this.value &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">      this.value &#x3D; reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试状态改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(new PROMISE(() &#x3D;&gt; &#123;&#125;));</span><br><span class="line">console.log(</span><br><span class="line">  new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>测试executor执行异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   console.log(</span><br><span class="line">     new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       console.log(as);</span><br><span class="line">     &#125;)</span><br><span class="line">   );</span><br><span class="line">&#x2F;&#x2F;对比原生Promise</span><br><span class="line">   console.log(</span><br><span class="line">     new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       console.log(as);</span><br><span class="line">     &#125;)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>



<h3 id="THEN"><a href="#THEN" class="headerlink" title="THEN"></a>THEN</h3><p>现在添加then方法来处理状态的改变，有以下几点说明</p>
<ol>
<li>then可以有两个参数，即成功和错误时的回调函数</li>
<li>若then处理的Promise状态为fulfilled，then的函数参数都不是必须的，如果传入非函数则将被忽略，还需要设置默认值为函数，用于处理没传参，或传入非函数的情况，并将PROMISE的value返回，为后期链式调用then传递值。</li>
<li>若then所处理的Promise状态为rejected且没有使用then的onRejected处理时，将会报错。</li>
<li>当执行then传递的函数发生异常时，统一交给onRejected来处理错误</li>
<li>then的执行是异步任务</li>
</ol>
<h4 id="基础构建"><a href="#基础构建" class="headerlink" title="基础构建"></a>基础构建</h4><p>先观察原生Promsie.then的特点</p>
<ul>
<li>能够处理异步确认状态</li>
<li>then异步执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    res(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>若没有处理拒绝状态的Promise，则会报错</li>
</ul>
<p>若Promise状态为rejected，且没有被then中的onRejected函数处理，将会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;没有传递onRejeted</span><br><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">    &#125;).then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;onRejeted不是函数，证明没有处理异常，依旧会报错</span><br><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">    &#125;).then((result) &#x3D;&gt; console.log(result), &quot;rejected&quot;);</span><br></pre></td></tr></table></figure>

<p>即便是空函数，也代表对异常做了处理，便不会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;Ashun&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  () &#x3D;&gt; &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实现基本功能</p>
<ul>
<li>对onResolve设置默认函数，并返回this.value，当PROMISE状态为fulfilled时，不传参，也会将值传递给下一个then</li>
</ul>
<p><strong>rejected处理</strong></p>
<p>实现方法（一）</p>
<ul>
<li><p>不为onRejected设置默认函数，若设置了默认函数，则会默认处理rejected状态</p>
</li>
<li><p>设置一个变量<code>isfilter</code>，监听rejected是否被处理</p>
</li>
<li><p>由于不确定onRejected是否为函数，也没有为其设置默认函数，所以在后期执行时，要判断其类型，再设置<code>isfilter</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class PROMISE &#123;</span><br><span class="line">  …</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    ……</span><br><span class="line">    this.isfilter &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"> 	……</span><br><span class="line">  then(onResolve, onReject) &#123;</span><br><span class="line">    if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">      onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onResolve(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          onReject(this.value);</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          onReject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式有一个弊端，就是一旦抛出错误，后续的同步代码将不再被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;Ashun&quot;);</span><br><span class="line">&#125;).then();</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;); &#x2F;&#x2F;rejected没有被处理，抛出错误，后续同步代码不会执行</span><br></pre></td></tr></table></figure>



<p><strong>实现方法（二）</strong></p>
<p>在reject回调函数中，<code>异步判断isfilter</code>，因为外部代码自上而下执行，isfilter的初始值为false，若不异步判断，则无论是否被处理，一旦执行reject回调函数，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码自上而下执行，若在reject回调函数中判断isfilter，则要异步判断，等待then处理后，再判断</span><br><span class="line"></span><br><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        	(result) &#x3D;&gt; console.log(result),</span><br><span class="line">        	(reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">reject(reason) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">    this.value &#x3D; reason;</span><br><span class="line">    &#x2F;&#x2F; 异步判断是否被过滤,等待then执行完毕，判断rejected是否被处理;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      if (!this.isfilter) &#123;</span><br><span class="line">        throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      onResolve(this.value);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      onReject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">    if (onReject instanceof Function) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onReject(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      this.isfilter &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来测试then方法，结果正常输出<code>Ashun</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        	(result) &#x3D;&gt; console.log(result),</span><br><span class="line">        	(reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">			);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<p>若没有处理rejected，会报错，并且不会影响后续同步代码的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(result &#x3D;&gt; console.log(result));</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;); </span><br></pre></td></tr></table></figure>



<h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>但上面的代码并不是异步执行的，使用setTimeout来将onFulfilled与onRejected做为异步宏任务执行</p>
<ul>
<li><code>isfilter</code>的改变不使用setTimeout包裹，只要onReject为Function，就立即设置<code>isfilter=true</code>，这样才能够让resolve及时监听<code>isfilter</code>的改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onResolve(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">    if (onReject instanceof Function) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          onReject(this.value);</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          onReject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      this.isfilter &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再执行代码，已经有异步效果了，先输出了<code>阿顺特烦恼</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> new PROMISE((res, rej) =&gt; &#123;</span><br><span class="line">        // res(&quot;Ashun&quot;);</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) =&gt; console.log(result),</span><br><span class="line">        (reason) =&gt; console.log(reason)</span><br><span class="line">      );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="PENDING异步"><a href="#PENDING异步" class="headerlink" title="PENDING异步"></a>PENDING异步</h4><p>当在PROMISE中<code>异步确认状态</code>时，then处理的是pending状态的PROMISE，所以不会执行对应的处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          res(&quot;as&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) &#x3D;&gt; console.log(result),</span><br><span class="line">        (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">      );</span><br><span class="line"># 由于处理的是pending状态的PROMISE，所以不会执行处理函数</span><br></pre></td></tr></table></figure>

<p>为了处理以上情况，需要进行几点改动</p>
<ol>
<li>在构造函数中添加callbacks来保存pending状态时处理函数，当状态改变时，即<code>resolve/reject</code>被调用时，再在<code>resolve/reject</code>函数体中调用callbacks对应状态的处理函数</li>
<li>callbacks中的处理函数也要设置为异步调用</li>
<li>只有在异步确认状态时，才会向callbacks中压入对应处理函数，所以在调用时，要判断处理函数是否存在。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">constructor(executor)&#123;</span><br><span class="line">	……</span><br><span class="line">	this.callbacks&#x3D;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">resolve(result) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.FULFILLED;</span><br><span class="line">    this.value &#x3D; result;</span><br><span class="line">    this.callbacks.onResolve &amp;&amp; this.callbacks.onResolve(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reject(reason) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">    this.value &#x3D; reason;</span><br><span class="line">    this.callbacks.onReject &amp;&amp; this.callbacks.onReject(this.value);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        if (!this.isfilter) throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">          &#x2F;&#x2F;设置默认值</span><br><span class="line">          if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">            onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;同步确认状态处理，直接执行对应处理函数</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                onResolve(this.value);</span><br><span class="line">              &#125; catch (err) &#123;</span><br><span class="line">                onReject(err);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">          	 if (onReject instanceof Function) &#123;</span><br><span class="line">          	 		this.isfilter &#x3D; true;</span><br><span class="line">            		setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              		try &#123;</span><br><span class="line">               		 onReject(this.value);</span><br><span class="line">              		&#125; catch (err) &#123;</span><br><span class="line">               		 onReject(err);</span><br><span class="line">              		&#125;</span><br><span class="line">           		 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">          &#x2F;&#x2F;先将处理函数添加到callbacks中，当状态发生改变时，再在this.resolve&#x2F;reject中调用</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">            this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  onResolve(result);</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                  onReject(err);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">            this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            	if (onReject instanceof Function) &#123;</span><br><span class="line">          	 		this.isfilter &#x3D; true;</span><br><span class="line">              	setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                	try &#123;</span><br><span class="line">                  	onReject(reason);</span><br><span class="line">               	 	&#125; catch (err) &#123;</span><br><span class="line">                 	 	onReject(err);</span><br><span class="line">               	 	&#125;</span><br><span class="line">              	&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>







<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p>Promise中的then是链式调用执行的，所以then也要默认返回状态为fulfilled的Promise。</p>
<ol>
<li>then的onReject函数是对前面Promise的rejected的处理</li>
<li>但默认返回的Promise状态要为fulfilled，所以在调用onRejected后，需要改变当前promise为fulfilled状态,并把执行结果传入。让下一个then得以接收</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认返回一个PROMISE</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let preResult &#x3D; onResolve(this.value);</span><br><span class="line">          resolve(preResult);			</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let preReason &#x3D; onReject(this.value);</span><br><span class="line">            resolve(preReason);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let preResult &#x3D; onResolve(result);</span><br><span class="line">            resolve(preResult);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        if (onReject instanceof Function) &#123;</span><br><span class="line">          this.isfilter &#x3D; true;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let preReason &#x3D; onReject(reason);</span><br><span class="line">              resolve(preReason);</span><br><span class="line">            &#125; catch (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面经过测试后，链式操作已经有效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    reject(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; result,</span><br><span class="line">    (reason) &#x3D;&gt; reason</span><br><span class="line">  )</span><br><span class="line">  .then()</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; console.log(result),</span><br><span class="line">    (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">  );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>原生Promise.then，若在then中手动返回一个新的Promise并确认状态，这个手动返回的Promise能够改变当前then的状态，并且下一个then就是对返回的Promise的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;Promise status: fulfilled&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return Promise.reject(&quot;then status: rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(null, (err) &#x3D;&gt; console.log(err));</span><br></pre></td></tr></table></figure>

<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>我们若要实现这个效果，就要判断then返回结果的类型是否为PROMISE，若是PROMISE，我们直接调用 <code>preRusult.then(resolve,reject)</code>即可，因为调用then会等待手动返回的PROMISE确认状态后执行。</p>
<p>让手动返回的PROMISE状态改变当前then默认返回的PROMISE的状态</p>
<ul>
<li>使用then处理，若手动返回PROMISE确认状态为fulfilled,就执行默认返回PROMISE的resolve，让其状态也变为fulfilled</li>
<li>同理，若手动返回PROMISE确认状态为rejected,就执行默认返回PROMISE的reject，让其状态也变为rejected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">          &#x2F;&#x2F;设置默认值</span><br><span class="line">       		………</span><br><span class="line">          return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  let preResult &#x3D; onResolve(this.value);</span><br><span class="line">                  if (preResult instanceof PROMISE) &#123;</span><br><span class="line">                    preResult.then(resolve, reject);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    resolve(preResult);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                  reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">              if (onReject instanceof Function) &#123;</span><br><span class="line">                this.isfilter &#x3D; true;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                    let preReason &#x3D; onReject(this.value);</span><br><span class="line">                    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">                      preReason.then(resolve, reject);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      resolve(preReason);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; catch (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">              this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                    let preResult &#x3D; onResolve(result);</span><br><span class="line">                    if (preResult instanceof PROMISE) &#123;</span><br><span class="line">                      preResult.then(resolve, reject);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      resolve(preResult);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; catch (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;;</span><br><span class="line">              this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">                if (onReject instanceof Function) &#123;</span><br><span class="line">                  this.isfilter &#x3D; true;</span><br><span class="line">                  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      let preReason &#x3D; onReject(reason);</span><br><span class="line">                      if (preReason instanceof PROMISE) &#123;</span><br><span class="line">                        preReason.then(resolve, reject);</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                        resolve(preReason);</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125; catch (err) &#123;</span><br><span class="line">                      reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>测试能够到的正确结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    rej(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; result,</span><br><span class="line">    (reason) &#x3D;&gt; reason</span><br><span class="line">  )</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">      res(&quot;then2 status Fulfilled&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; console.log(&#96;resolve__:$&#123;result&#125;&#96;),</span><br><span class="line">    (reason) &#x3D;&gt; console.log(&#96;rejected__:$&#123;reason&#125;&#96;)</span><br><span class="line">  );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h4><p>现在发现pendding、fulfilled、rejected 状态的代码非常相似，所以可以提取出方法Parse来复用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line"> 	……</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(onResolve(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(onReject(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onResolve(result), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onReject(reason), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Parse(Operation, resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let preReason &#x3D; Operation;</span><br><span class="line">    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">      preReason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(preReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回约束"><a href="#返回约束" class="headerlink" title="返回约束"></a>返回约束</h4><p>then手动返回的promise不能是then默认返回Promise，会产生循环调用，下面是原生Promise的示例将产生错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((res, rej) =&gt; &#123;</span><br><span class="line">        res(&quot;fulfilled&quot;);</span><br><span class="line">      &#125;).then((result) =&gt; promise);</span><br></pre></td></tr></table></figure>

<p>解决上面的问题来完善代码，添加当前promise做为parse的第一个参数与函数执行结果进行比对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line"> 	……</span><br><span class="line">  let promise &#x3D; new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(promise, onResolve(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onReject(this.value), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(promise, onResolve(result), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        if (onReject instanceof Function) &#123;</span><br><span class="line">          this.isfilter &#x3D; true;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            this.Parse(onReject(reason), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parse(promise, Operation, resolve, reject) &#123;</span><br><span class="line">  if (promise &#x3D;&#x3D;&#x3D; Operation) &#123;</span><br><span class="line">    throw new Error(&quot;Chaining cycle detected for promise&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    let preReason &#x3D; Operation;</span><br><span class="line">    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">      preReason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(preReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在进行测试也可以得到原生一样效果了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;fulfilled&quot;);</span><br><span class="line">&#125;).then((result) &#x3D;&gt; promise);</span><br></pre></td></tr></table></figure>



<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="RESOLVE"><a href="#RESOLVE" class="headerlink" title="RESOLVE"></a>RESOLVE</h4><p>下面来实现原生Promise的静态方法<code>Promise.resolve</code>用于快速返回一个状态为resolve的Promise</p>
<ul>
<li><p>默认返回Promise</p>
</li>
<li><p>同样需要注意返回类型，若为PROMISE，则使用then处理的就是返回的PROMISE</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(</span><br><span class="line">  new Promise((res) &#x3D;&gt; res(&quot;ashuntefannao&quot;))</span><br><span class="line">).then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>

<p>创建静态方法<code>static resolve</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static resolve(value) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (value instanceof PROMISE) &#123;</span><br><span class="line">      value.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROMISE.resolve(</span><br><span class="line">  new PROMISE((res, rej) &#x3D;&gt; rej(&quot;ashuntefannao&quot;))</span><br><span class="line">).then(null, (reason) &#x3D;&gt; console.log(&#96;rejected__$&#123;reason&#125;&#96;));</span><br><span class="line"></span><br><span class="line">PROMISE.resolve(&quot;ashun&quot;).then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>



<h4 id="REJECT"><a href="#REJECT" class="headerlink" title="REJECT"></a>REJECT</h4><p>封装思想和<code>resolve</code>静态方法相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (reason instanceof PROMISE) &#123;</span><br><span class="line">      reason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROMISE.reject(&quot;rejected&quot;).then(null, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">PROMISE.reject(PROMISE.resolve(&quot;阿顺特烦恼&quot;)).then((val) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>原生Promise的静态方法all</p>
<ul>
<li>接收一个PromiseArray，并按顺序对PromiseArray中的promise进行判断和处理</li>
<li>若存在一个promise没有确定状态，则all返回的Promise也为pending状态</li>
<li>若存在一个promise状态为rejected，则all返回的Promise也为rejected状态，并且后续的then能够接收到拒绝状态的promise传值。</li>
<li>若所有promise状态都为fulfilled，则返回一个有序的、元素为promise结果的数组</li>
</ul>
<p>由于all是有序处理，所以我们需要通过遍历，按顺序处理业务逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static all(PROMISEarr) &#123;</span><br><span class="line">  let resolveArr &#x3D; [];</span><br><span class="line">  let test &#x3D; true;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    for (let promise of PROMISEarr) &#123;</span><br><span class="line">      let isPending &#x3D; promise.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING;</span><br><span class="line">      let isReject &#x3D; promise.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED;</span><br><span class="line"></span><br><span class="line">      if (isPending) &#123;</span><br><span class="line">        test &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      &#125; else if (isReject) &#123;</span><br><span class="line">        test &#x3D; false;</span><br><span class="line">        promise.then(null, (reason) &#x3D;&gt; reject(reason));</span><br><span class="line">        break;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        promise.then((res) &#x3D;&gt; resolveArr.push(res));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test &amp;&amp; resolve(resolveArr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例可自行改变某个promise的状态，来检测不同结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p2 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let all &#x3D; PROMISE.all(arr).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(all);</span><br><span class="line">&#125;, 100);</span><br></pre></td></tr></table></figure>



<h4 id="RACE"><a href="#RACE" class="headerlink" title="RACE"></a>RACE</h4><ul>
<li><code>race(PromiseArray)</code>赛跑，哪个Promise优先确认状态，就返回哪个Promise</li>
<li>一开始我们就已经实现了promise状态一经确定，就不可再改变</li>
<li>所以在实现的时候，我们只需循环调用每一个promise的then方法，哪个最先确认状态，就会优先执行then，我们可以通过then的两个回调函数，来改变当前默认返回的Promsie的状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static race(PROMISEarr) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    PROMISEarr.map((promise) &#x3D;&gt; &#123;</span><br><span class="line">      promise.then(resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例可自行改变某个promise确认状态的延迟时间，来检测不同结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let race &#x3D; PROMISE.race(arr).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(&#96;result__$&#123;result&#125;&#96;),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(&#96;reason__$&#123;reason&#125;&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(race);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>



<h4 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h4><ul>
<li>不在乎状态拒绝与否，所有的promise确认状态后，将会返回有序结果，且返回的promise状态为fulfilled。</li>
<li>若有一个promise没有确认状态，则allSettled默认返回的promise状态也为fulfilled，也就不会执行后续的then</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static allSettled(PROMISEarr) &#123;</span><br><span class="line">  let results &#x3D; [];</span><br><span class="line">  let isPending &#x3D; true;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    for (let promise of PROMISEarr) &#123;</span><br><span class="line">      if (promise.status &#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">        isPending &#x3D; true;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      let status &#x3D; promise.status;</span><br><span class="line">      let value &#x3D; promise.value;</span><br><span class="line">      promise.then(</span><br><span class="line">        (result) &#x3D;&gt; &#123;</span><br><span class="line">          results.push(&#123; status, value &#125;);</span><br><span class="line">          if (results.length &#x3D;&#x3D; PROMISEarr.length) resolve(results);</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) &#x3D;&gt; &#123;</span><br><span class="line">          results.push(&#123; status, reason: value &#125;);</span><br><span class="line">          if (results.length &#x3D;&#x3D; PROMISEarr.length) resolve(results);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let allSettled &#x3D; PROMISE.allSettled(arr).then((result) &#x3D;&gt;</span><br><span class="line">  console.log(result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(allSettled);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>

<p>若有一个promise始终没有确认状态，则allSettled默认返回的promise状态也为pending。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E8%BD%AE%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E8%BD%AE%E8%AF%A2/" class="post-title-link" itemprop="url">任务轮询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:39:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:39:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:06:48" itemprop="dateModified" datetime="2021-05-17T09:06:48+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="任务轮询"><a href="#任务轮询" class="headerlink" title="任务轮询"></a>任务轮询</h2><p>JavaScript 语言的一大特点就是单线程，也就是说同一个时间只能处理一个任务。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，（事件循环）Event Loop方案营运而生。</p>
<p>JavaScript 处理任务是在等待任务、执行任务 、休眠等待新任务中不断循环中，也称这种机制为事件循环。</p>
<ul>
<li>主线程中的任务(同步代码)执行完后，才执行任务队列中的任务(异步代码)</li>
<li>有新任务到来时会将其放入队列，采取先进先执行的策略执行队列中的任务</li>
<li>比如多个 <code>setTimeout</code> 同时到时间了，就要依次执行</li>
</ul>
<p>任务包括 script(整体代码)、 setTimeout、setInterval、DOM渲染、DOM事件、Promise、XMLHTTPREQUEST等</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ul>
<li>立即执行主线程同步代码</li>
<li>所有主线程同步代码执行完毕后，先轮询异步微任务队列，将其中的微任务依次添加到主线程并执行。</li>
<li>微任务队列为空，轮询异步宏任务队列，将其中的异步宏任务依次添加到主线程并执行</li>
<li>所有的任务都是在主线程中执行的</li>
</ul>
<p>下面通过一个例子来详细分析宏任务与微任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Promise中的同步代码&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then((_) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise.then1&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((_) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise.then2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line"></span><br><span class="line"># 执行结果</span><br><span class="line">Ashuntefannao</span><br><span class="line">Promise中的同步代码</span><br><span class="line">阿顺特烦恼</span><br><span class="line">Promise.then1</span><br><span class="line">Promise.then2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<ol>
<li>立即执行最前面的主线程同步代码，打印结果</li>
<li>执行setTimeout，将其放入异步宏任务队列</li>
<li>立即执行后续同步代码，在Promise中</li>
<li>执行到第一个then，将其放入到异步微任务队列中</li>
<li>执行到第二个then，将其放入到异步微任务队列中</li>
<li>立即执行末尾的主线程同步代码，打印结果</li>
<li>所有主线程同步代码执行完毕，在微任务队列中取出第一个then代码块，放入主线程并执行</li>
<li>主线程同步代码执行完毕，继续轮询微任务队列，取出第二个then代码块并执行。</li>
<li>主线程代码执行完毕，微任务队列为空，轮询异步宏任务队列</li>
<li>取出setTimeout中的代码块，放入主线程，并执行</li>
<li>主线程同步代码执行完毕，微任务队列为空，异步宏任务队列为空</li>
</ol>
<img src="任务轮询.assets/EventLoop_1.png" alt="EventLoop_1" style="zoom:65%;" />



<h3 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h3><p>引擎在执行任务时不会进行DOM渲染，所以如果把<code>script</code> 定义在前面，要先执行完任务后再渲染DOM。</p>
<p>解决:</p>
<ol>
<li>将<code>script</code> 放在 BODY 结束标签前。</li>
<li>为<code>script</code>标签添加<code>type=&quot;module&quot;</code>,也会延迟解析执行</li>
<li>为<code>script</code>标签添加<code>defer=&quot;defer&quot;</code>属性</li>
<li>为<code>script</code>标签添加<code>async=&quot;async&quot;</code>属性</li>
</ol>
<ul>
<li><code>defer/async</code>属性，只对外部脚本引入生效，多次使用该属性引入其它外部脚本，不能够保证先后顺序，若引入的多个脚本之间存在依赖关系，需要注意。</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器会放入异步宏任务队列，需要等待同步任务、异步微任务执行完成后执行。</p>
<p>下面设置了 6 毫秒执行，如果主线程代码执行10毫秒，定时器要等主线程执行完才执行。</p>
<p>HTML标准规定最小时间不能低于4毫秒，有些异步操作如DOM操作最低是16毫秒，总之把时间设置大些对性能更好。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func,6);</span><br></pre></td></tr></table></figure>

<p>下面的代码会先输出 <code>Ashuntefannao</code> 之后输出 <code>阿顺特烦恼</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&quot;Ashuntefannao&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务一般由用户代码产生，微任务较宏任务执行优先级更高，<code>Promise.then</code> 是典型的微任务，实例化 Promise 时执行的代码是同步的，then注册的回调函数是异步微任务。</p>
<p>任务的执行顺序是同步任务、微任务、宏任务所以下面执行结果是 <code>1、2、3、4</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; console.log(4));</span><br><span class="line"></span><br><span class="line">new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;).then(_ &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br></pre></td></tr></table></figure>

<p>我们再来看下面稍复杂的任务代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;定时器&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;timeout timeout&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&quot;settimeout Promise&quot;);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;settimeout then&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&quot;Promise&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;then&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">阿顺特烦恼</span><br><span class="line">then</span><br><span class="line">定时器</span><br><span class="line">settimeout Promise</span><br><span class="line">settimeout then</span><br><span class="line">timeout timeout</span><br></pre></td></tr></table></figure>



<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><p>下面的定时器虽然都定时了一秒钟，但任务队列是按先进先出（先进先执行）原则，依次执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let i = 0;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(++i);</span><br><span class="line">  console.log(&quot;timeout1&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(++i);</span><br><span class="line">  console.log(&quot;timeout2&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">//一秒后打印结果</span><br><span class="line">1</span><br><span class="line">timeout1</span><br><span class="line">2</span><br><span class="line">timeout2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是一个进度条的示例，将每个数字放在一个任务中执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">    .loading &#123;</span><br><span class="line">      height: 30px;</span><br><span class="line">      background: yellowgreen;</span><br><span class="line">      width: 0;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let laodBox=document.querySelector(&quot;.loading&quot;);</span><br><span class="line">  function view() &#123;</span><br><span class="line">    let i = 0;</span><br><span class="line">    (function handle() &#123;</span><br><span class="line">      laodBox.innerHTML = i + &quot;%&quot;;</span><br><span class="line">      laodBox.style.width = i + &quot;%&quot;;</span><br><span class="line">      if (i++ &lt; 100) &#123;</span><br><span class="line">        setTimeout(handle, 20);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">  view();</span><br><span class="line">  console.log(&quot;定时器开始了...&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>一个比较耗时的任务可能造成游览器卡死现象，所以可以将任务拆分为多个异步小任务执行，暂时置于异步任务队列中，当主线程空闲时，在进行任务轮询。下面是一个数字统计的函数，我们会发现运行时间特别长</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        console.time(&quot;runtime&quot;);</span><br><span class="line">        function sub(num) &#123;</span><br><span class="line">          let count = 0;</span><br><span class="line">          for (let i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">            count += i;</span><br><span class="line">          &#125;</span><br><span class="line">          console.log(count);</span><br><span class="line">          console.timeEnd(&quot;runtime&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        let num = 987654321;</span><br><span class="line">        sub(num);</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;); //需要等待上面执行完才会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把任务分解成小块放入任务队列，游览器就不会出现卡死的现象了，也不会影响后续代码的执行</p>
<ul>
<li>执行run时，遇到第一个setTimeout，先将其添加到异步宏任务队列。</li>
<li>后面遇到同步代码，打印结果，又遇到异步宏任务，添加到任务队列中</li>
<li>同步代码执行完毕，取出第一个setTimeout到主线程并执行（运算for循环）</li>
<li>后面遇到同步代码，打印结果，又遇到异步宏任务，添加到任务队列中</li>
<li>同步代码执行完毕，取出第二个setTimeout到主线程并执行（调用run）</li>
<li>以此往复，任务轮询……</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let count = 0;</span><br><span class="line">        let num = 987654321;</span><br><span class="line">        function run() &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            for (let i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">              if (num &lt;= 0) break;</span><br><span class="line">              count += num--;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          if (num &gt; 0) &#123;</span><br><span class="line">            console.log(num);</span><br><span class="line">            setTimeout(run);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            console.log(num);</span><br><span class="line">            console.log(count);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交给微任务处理是更好的选择</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        async function run(num) &#123;</span><br><span class="line">          let res = await Promise.resolve().then((_) =&gt; &#123;</span><br><span class="line">            let count = 0;</span><br><span class="line">            for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">              count += num--;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">          &#125;);</span><br><span class="line">          console.log(res);</span><br><span class="line">        &#125;</span><br><span class="line">        run(987654321);</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise/" class="post-title-link" itemprop="url">Promise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:38:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:38:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:04:45" itemprop="dateModified" datetime="2021-05-17T09:04:45+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>JavaScript</code> 中存在很多异步操作,<code>Promise</code> 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。可以通过链式调用多个 <code>Promise</code> 达到我们的目的。</p>
<p>Promise 在各种开源库中已经实现，现在标准化后被浏览器默认支持。</p>
<blockquote>
<p>promise 是一个拥有 <code>then</code> 方法的对象或函数</p>
</blockquote>
<h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>下面通过多个示例来感受一下不使用 <code>promise</code> 时，处理相应问题的不易，及生成了不便阅读的代码。</p>
<h4 id="定时嵌套"><a href="#定时嵌套" class="headerlink" title="定时嵌套"></a>定时嵌套</h4><p>下面是一个定时器执行结束后，执行另一个定时器，这种嵌套造成代码不易阅读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createInterval(callback, delay &#x3D; 50) &#123;</span><br><span class="line">        let timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          callback(timer);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">      const div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      console.log(parseFloat(window.getComputedStyle(div).left));</span><br><span class="line"></span><br><span class="line">      function run() &#123;</span><br><span class="line">        createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">          div.style.left &#x3D;</span><br><span class="line">            parseFloat(window.getComputedStyle(div).left) + 2 + &quot;px&quot;;</span><br><span class="line">          &#x2F;&#x2F; console.log(&quot;left&quot;);</span><br><span class="line">          if (parseFloat(div.style.left) &gt;&#x3D; 50) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">            createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">              div.style.width &#x3D;</span><br><span class="line">                parseFloat(window.getComputedStyle(div).width) - 2 + &quot;px&quot;;</span><br><span class="line">              &#x2F;&#x2F; console.log(&quot;width&quot;);</span><br><span class="line">              parseFloat(div.style.width) &lt;&#x3D; 0 &amp;&amp; clearInterval(timer);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><p>下面是图片后设置图片边框，也需要使用回调函数处理，代码嵌套较复杂</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createImage(file, resolve, reject) &#123;</span><br><span class="line">  const img = new Image();</span><br><span class="line">  img.src = file;</span><br><span class="line">  img.onload = () =&gt; &#123;</span><br><span class="line">    resolve(img);</span><br><span class="line">    console.log(&quot;image Loading fulfilled&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.onerror = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;image loading fail&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  document.body.append(img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createImage(&quot;./images/img1.jpg&quot;, (img) =&gt; &#123;</span><br><span class="line">  img.style.border = &quot;5px solid pink&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>下面是异步加载外部<code>JS</code>文件，需要使用回调函数执行，并设置的错误处理的回调函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loadJS(file, resolve, reject) &#123;</span><br><span class="line">  let script = document.createElement(&quot;script&quot;);</span><br><span class="line">  script.src = file;</span><br><span class="line">  script.onload = resolve;</span><br><span class="line">  script.onerror = reject;</span><br><span class="line">  document.body.append(script);</span><br><span class="line">&#125;</span><br><span class="line">loadJS(</span><br><span class="line">  &quot;./js/ashun.js&quot;,</span><br><span class="line">  (script) =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">    title();</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; console.log(`$&#123;err.srcElement.src&#125;  load Reject`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实例中用到的 <code>ashun.js</code> 与 <code>SHUN.js</code> 内容如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ashun.js</span><br><span class="line">function title() &#123;</span><br><span class="line">  console.log(&quot;title method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># SHUN.js</span><br><span class="line">function run() &#123;</span><br><span class="line">  title();</span><br><span class="line">  console.log(&quot;run method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加载多个脚本时需要嵌套使用，下面<code>SHUN.js</code> 依赖 <code>ashun.js</code>，需要先加载<code>ashun.js</code> 后加载<code>SHUN.js</code></p>
<blockquote>
<p>不断的回调函数操作将产生回调地狱，使代码很难维护</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function loadJS(file,resolve,reject)&#123;……&#125;</span><br><span class="line"></span><br><span class="line">   loadJS(</span><br><span class="line">        &quot;/js/ashun.js&quot;,</span><br><span class="line">        (script) =&gt; &#123;</span><br><span class="line">          loadJS(</span><br><span class="line">            &quot;/js/SHUN.js&quot;,</span><br><span class="line">            (script) =&gt; &#123;</span><br><span class="line">              run();</span><br><span class="line">              console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">            &#125;,</span><br><span class="line">            (err) =&gt; &#123;</span><br><span class="line">              console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">          console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><p>使用传统的异步请求也会产生回调嵌套的问题。</p>
<p>比如若要获取商品的详情，就要分为两步</p>
<ol>
<li>先请求商品数据，得到商品的id</li>
<li>根据商品id请求获取对应商品的详情数据。</li>
</ol>
<p>以下接口无实际用途，仅作示例，可自己编写</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url, resolve, reject) &#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.open(&quot;GET&quot;, url);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onload = function() &#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      resolve(JSON.parse(this.response));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&quot;http://localhost:8888/goodslist/data, goods =&gt; &#123;</span><br><span class="line">  ajax(</span><br><span class="line">    `http://localhost:8888/category?id=$&#123;goods[&quot;id&quot;]&#125;`,</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      console.log(response[0]);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="肯德基"><a href="#肯德基" class="headerlink" title="肯德基"></a>肯德基</h4><p>下面是模拟肯德基吃饭的事情，使用 <code>promise</code> 操作异步的方式每个阶段会很清楚</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let kfc = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&quot;肯德基正在为您做餐……&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;餐品已经做好，为您上桌&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">let as = kfc.then((result) =&gt; &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">  console.log(&quot;阿顺收到消息&quot;);</span><br><span class="line">  return &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;我吃了2秒，不辣，张三你可以吃了&quot;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let zhangsan = as.then((msg) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&quot;张三收到阿顺消息：&quot; + msg);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      let msg = &quot;我吃了1秒，真好吃， 李四也尝尝吧&quot;;</span><br><span class="line">      console.log(msg);</span><br><span class="line">      resolve(msg);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">let lisi = zhangsan.then((result) =&gt; &#123;</span><br><span class="line">  console.log(&quot;李四收到消息：&quot; + result);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;李四:我吃了1秒，不错不错&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而使用以往的回调方式，就会让人苦不堪言</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function notice(msg, then) &#123;</span><br><span class="line">  then(msg);</span><br><span class="line">&#125;</span><br><span class="line">function meal() &#123;</span><br><span class="line">  notice(&quot;肯德基厨房开始做饭&quot;, (msg) =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">    notice(&quot;我是肯德基，你的餐已经做好&quot;, (msg) =&gt; &#123;</span><br><span class="line">      console.log(`阿顺收到肯德基消息: $&#123;msg&#125;`);</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        notice(&quot;张三，我吃了两秒了，不辣，你可以吃了&quot;, (msg) =&gt; &#123;</span><br><span class="line">          console.log(`张三收到阿顺消息: $&#123;msg&#125;`);</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            notice(&quot;很好吃，李四也尝尝吧&quot;, (msg) =&gt; &#123;</span><br><span class="line">              console.log(msg);</span><br><span class="line">              notice(&quot;李四收到消息&quot;, (msg) =&gt; &#123;</span><br><span class="line">                console.log(msg);</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                  console.log(&quot;李四:不错不错&quot;);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">meal();</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="异步状态"><a href="#异步状态" class="headerlink" title="异步状态"></a>异步状态</h3><p>Promise 意为承诺，就像我们去饭店用餐，点完餐后服务员会给我们一个票号，如果饭菜做好，我们凭借票号去领餐，这就代表成功状态，若由于其它原因饭菜不能够顺利做好，这就代表拒绝状态。在得到这些结果前，我们一直处于等待的状态。</p>
<ul>
<li>一个 <code>promise</code> 必须有一个 <code>then</code> 方法用于处理状态改变</li>
</ul>
<h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>Promise包含<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>三种状态</p>
<ul>
<li><code>pending</code> 指等待状态，初始化 <code>promise</code> 时的状态</li>
<li><code>resolve</code> 指已经解决，将 <code>promise</code> 状态设置为<code>fulfilled</code></li>
<li><code>reject</code> 指拒绝处理，将 <code>promise</code> 状态设置为<code>rejected</code></li>
<li><code>promise</code> 是生产者，通过 <code>resolve</code> 与 <code>reject</code> 函数告知结果</li>
<li><code>promise</code> 非常适合需要一定执行时间的异步任务</li>
<li>同一Promise状态一旦确定(<code>fufilled\rejected</code>),状态将不可再次更改</li>
</ul>
<p>promise 是队列状态，就像体育中的接力赛，或多米诺骨牌游戏，状态一直向后传递，当然 也可更改其中的任何一个promise的状态，来影响后续的promise。</p>
<p>promise 没有使用 <code>resolve</code> 或 <code>reject</code> 更改状态时，默认状态为 <code>pending</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">); //Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>当更改状态后</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;resolved&gt;: &quot;fulfilled&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; //Error</span><br></pre></td></tr></table></figure>

<p>若一个Promise为<code>rejected</code>状态，却没有处理，系统会发出警示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; &#x2F;&#x2F;Error:Uncaught (in promise) rejected</span><br></pre></td></tr></table></figure>

<p>使用<code>then\catch</code>处理后，不会报错，<code>then\catch</code>这些方法默认也会返回一个新的<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">        new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>按理来说上述Promise已经确认为rejected状态，也经过了<code>then\catch</code>的onRejected回调函数处理，应该返回<code>fufilled</code>状态（<code>then\catch</code>默认返回的promise状态为fufilled），但是为什么返回pending状态呢？</p>
<ul>
<li>console.log是同步代码会立即执行，当日志信息被打印时，promise的状态还未被确认，所以返回pending</li>
<li>将打印放在宏任务队列中，可看到正确结果</li>
</ul>
<p>关于<code>任务队列</code>，下一章节会详细讲解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 &#x3D; promise.catch((err) &#x3D;&gt; err);</span><br><span class="line"></span><br><span class="line">console.log(promise)&#x2F;&#x2F;Promise &#123;&lt;rejected&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">console.log(p1);		&#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(p1);	&#x2F;&#x2F;Promise &#123;&lt;fulfilled&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><code>promise</code> 自创建时，立即执行同步任务，<code>then</code> 会放在异步微任务中执行，需要等同步任务执行后才执行。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;fulfilled&quot;);</span><br><span class="line">  console.log(&quot;阿顺&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">// 阿顺 阿顺特烦恼 fulfilled</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">	resolve(&quot;fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(alert);</span><br><span class="line">alert(&quot;阿顺特烦恼&quot;);</span><br><span class="line">promise.then((_) &#x3D;&gt; alert(&quot;ashuntefannao&quot;));</span><br></pre></td></tr></table></figure>

<p>下例在三秒后将 <code>Promise</code> 状态设置为 <code>fulfilled</code> ，然后执行 <code>then</code> 方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>状态被改变后就不能再修改了，下面先通过<code>resolve</code> 改变为成功状态，表示<code>promise</code> 状态已经完成，就不能使用 <code>reject</code> 更改状态了</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;操作成功&quot;);</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="动态改变"><a href="#动态改变" class="headerlink" title="动态改变"></a>动态改变</h4><p>可以在一个<code>promise</code>中，通过处理另一个<code>promise1</code>，来改变<code>promise</code>的状态。</p>
<p>当在一个<code>promise</code>中，告知状态时传入的是另一个<code>promise1</code>，则后续使用<code>then</code>或其它方法对其进行处理时，处理的已经不再是promise的状态，而是promise1。</p>
<ul>
<li>在p2中确认<code>resolve</code>状态，但在后续的<code>then</code>中却执行了<code>rejected</code>回调函数。</li>
<li>在p2中确认状态时，返回的是p1，那么后续处理的promise将是p1，p2的状态已经无意义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject(&quot;p1 reject&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#96;p2发送resolve状态&#96;);</span><br><span class="line">        resolve(p1);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) &#x3D;&gt; console.log(&#96;p2 处理结果:fulfilled--$&#123;result&#125;&#96;),</span><br><span class="line">        (err) &#x3D;&gt; console.log(&#96;p2 处理结果:rejected--$&#123;err&#125;&#96;)</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>一个promise 需要提供一个then方法访问promise 结果，<code>then</code> 用于当 <code>promise</code> 状态发生改变时的处理，即<code>promise</code>处理异步操作过程，<code>then</code> 用于处理结果。</p>
<p><code>promise</code> 就像 <code>饭馆</code> 中的厨房，<code>then</code> 就是我们用户，如果餐做好了即 <code>fulfilled</code> ，做不了拒绝即<code>rejected</code> 状态。那么 then 就要对不同状态处理。</p>
<ul>
<li>then 方法 <strong>必须</strong> 返回 promise，用户返回或系统自动返回</li>
<li>第一个函数在<code>resolved</code> 状态时执行，即使用<code>resolve</code>确认完成状态时，执行<code>then</code>第一个callback处理成功状态</li>
<li>第二个函数在<code>rejected</code>状态时执行，即使用<code>reject</code>确认拒绝状态时，执行第二个callback处理失败状态，该函数是可选的</li>
<li>两个callback都接收 <code>promise</code> 确认状态时传入的值做为参数</li>
<li>也可以使用<code>catch</code> 来处理失败的状态</li>
<li>如果在 <code>then</code> 中手动返回 <code>promise</code> ，下一个<code>then</code> 会在上一个then返回的<code>promise</code> 状态改变后执行</li>
</ul>
<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><p>then的语法如下，onFulfilled 函数处理 <code>fulfilled</code> 状态， onRejected函数处理 <code>rejected</code> 状态</p>
<ul>
<li>onFulfilled 或 onRejected <code>不是函数将被忽略</code></li>
<li>两个函数只会被调用一次</li>
<li>onFulfilled 在 promise 执行成功时调用</li>
<li>onRejected 在 promise 执行拒绝时调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><code>then</code> 会在 <code>promise</code> 确认状态后执行，<code>then</code> 第一个callback在 <code>resolve</code>成功状态执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    console.log(`解决：$&#123;value&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    console.log(`拒绝:$&#123;reason&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 中第二个参数在失败状态执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果只关心成功则不需要传递 <code>then</code> 的第二个参数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果只关心失败时状态，<code>then</code> 的第一个参数传递 <code>null</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>promise 确认状态后转入的参数，会传入到<code>then</code>对应callback的参数中，如果then没有可处理函数，会一直向后传递</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&quot;rejected&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(</span><br><span class="line">  null,</span><br><span class="line">  f =&gt; console.log(f)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;resolve&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then();</span><br><span class="line">p2.then().then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;reject&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then(() &#x3D;&gt; &#123;&#125;);</span><br><span class="line">p2.then(null, null).then(null, reject &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><ul>
<li><code>then\catch</code>等promise的方法，是对上一个promise状态的处理，而使用<code>then/catch</code>后 它们本身又会默认返回一个新的promise，且状态为<code>fulfilled</code>,所以then才可不断地链式调用。</li>
<li>当然，也可以在<code>then\catch</code>中手动返回自定义的promise，可通过这个promise，改变当前then的状态</li>
</ul>
<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>， then 默认返回的 promise 状态是 fulfilled</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       reject(&quot;promise state rejected&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(null, (err) &#x3D;&gt; console.log(err))</span><br><span class="line">       .then((_) &#x3D;&gt; console.log(&quot;then默认状态为fulfilled&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>，不要认为上一个 promise状态会影响以后then返回的状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise(resolve =&gt; &#123;</span><br><span class="line">  rejected(&quot;p1 rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = p1.then(null,rej=&gt;console.log(reg));</span><br><span class="line">p2.then(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">console.log(p2); // Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">  console.log(p2); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 是对上个promise 的处理，每个 <code>then</code> 又会返回一个promise，默认传递 <code>fulfilled</code>状态，所以才可以不断地链式调用then处理promise。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line"># 执行结果如下</span><br><span class="line">  rejected</span><br><span class="line">  fulfilled</span><br><span class="line">  fulfilled</span><br></pre></td></tr></table></figure>

<p>如果内部手动返回 <code>promise</code> 时，后续处理的便是该 <code>promise</code>，即该promise可以改变当前then的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">         reject(&quot;promise state rejected&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">       promise</span><br><span class="line">         .then(</span><br><span class="line">           (result) &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">           (reject) &#x3D;&gt; console.log(reject)</span><br><span class="line">         )</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">         )</span><br><span class="line">         .then((res) &#x3D;&gt; &#123;</span><br><span class="line">           console.log(&quot;fufilled&quot;);</span><br><span class="line">           return Promise.reject(&quot;手动返回的promise，状态为rejected&quot;);</span><br><span class="line">         &#125;)</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">         );</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果如下</span><br><span class="line"> &quot;promise state rejected&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;手动返回的promise，状态为rejected&quot;</span><br></pre></td></tr></table></figure>

<p>若手动返回的不是Promise，则下一个then处理的还是 上一个then默认返回的Promise，状态为fulfilled。</p>
<ul>
<li>但是下一个then对应的处理函数，会接受上一个then返回的参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">        	console.log(rej)</span><br><span class="line">          return &quot;p1 rejected&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; p1.then((res) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#96;p2 fulfilled \n$&#123;res&#125;&#96;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> # 执行结果如下</span><br><span class="line">  &quot;promise state rejected&quot;</span><br><span class="line">  &quot;p2 fulfilled</span><br><span class="line">   p1 rejected&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(v &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个promise&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>then是处理上一个Promise的结果，只有上一个promise确认了状态，then才会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                resolve(&quot;resolved&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; console.log(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>循环调用</strong></p>
<p>如果 <code>then</code> 的返回值与所处理的 <code>promise</code> 相同将禁止执行，（避免陷入死循环）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then(() =&gt; &#123;</span><br><span class="line">  return p2;</span><br><span class="line">&#125;); // TypeError: Chaining cycle detected for promise</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a>其它类型</h4><p><strong>then able</strong>：具有then能力的类型</p>
<p>Promise 解决过程是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<ul>
<li>也就是说，如果<code>x</code>具有<code>then</code>方法，那么将会被系统认为是<code>类promise</code>的结构</li>
<li>若在Promise中返回<code>x</code>,则使用then处理Promise时，系统会尝试让原Promise的then方法接收<code>x</code>中then方法的状态</li>
</ul>
<p>包含then方法的Object可以当作promise使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(result);</span><br><span class="line">          return &#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                reject(&quot; p1 rejected&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">        p1.then(</span><br><span class="line">          (mgs) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(mgs);</span><br><span class="line">          &#125;,</span><br><span class="line">          (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Goods &#123;</span><br><span class="line">  constructor(id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goods?id&#x3D;$&#123;this.id&#125;&#96;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goodsList?type&#x3D;new&#96;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(goods &#x3D;&gt; &#123;</span><br><span class="line">  return new Goods(goods.id);</span><br><span class="line">&#125;)</span><br><span class="line">.then(category &#x3D;&gt; &#123;</span><br><span class="line">  console.log(category);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然也可以是类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(</span><br><span class="line">    class &#123;</span><br><span class="line">      static then(resolve, reject) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          resolve(&quot;解决状态&quot;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;).then(</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`fulfilled: $&#123;v&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`rejected: $&#123;v&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果对象中的 then 不是函数，则将对象做为值传递</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    then: &quot;阿顺特烦恼&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  console.log(v); //&#123;then: &quot;阿顺特烦恼&quot;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>下面使用未定义的变量同样会触发失败状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  as;</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; console.log(value),</span><br><span class="line">  reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果 onFulfilled 或 onRejected 抛出异常，则 p2 拒绝执行并返回拒因</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then();</span><br><span class="line">p2.then().then(null, resolve =&gt; &#123;</span><br><span class="line">  console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>catch(err=&gt;&#123;&#125;)</code>是用来接收Promise拒绝状态的。经catch处理后，默认返回的promise状态也为fulfilled</li>
<li><code>catch</code>相当于<code>then(null,onReject)</code></li>
<li>若某个promise已被<code>then(null,onReject)</code>处理，则<code>catch</code>将不会接收该拒绝状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          console.log(p1);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected,阿顺特烦恼</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err))</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected</span><br></pre></td></tr></table></figure>

<ul>
<li>建议使用 <code>catch</code> 处理错误</li>
<li>将 <code>catch</code> 放在最后面用于统一处理前面发生的错误</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;Notice: Promise Exception&quot;));</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.error(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 可以捕获之前所有 <code>promise</code> 的错误，所以建议将 <code>catch</code> 放在最后。下例中 <code>catch</code> 也可以捕获到了第一个 <code>then</code> 返回 的 <code>promise</code> 的错误。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;err from .then &quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>错误是冒泡的操作的，下面没有任何一个<code>then</code> 定义第二个函数参数<code>onRejected</code>，将一直冒泡到 <code>catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获对 <code>then</code> 抛出的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;这是then 抛出的错误&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;33&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获其他错误，下面在 <code>then</code> 中使用了未定义的变量，将会把错误抛出到 <code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg &#x3D;&gt; &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString()+&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以将上面的理解为如下代码，可以理解为内部自动执行 <code>try...catch</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但像下面的在<code>异步宏任务</code>中 <code>throw new Error</code> 将不会触发 <code>catch</code>，而使用系统错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg + &quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>catch</code> 中发生的错误也会抛给最近的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  ashun();</span><br><span class="line">&#125;)</span><br><span class="line">.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="定制错误"><a href="#定制错误" class="headerlink" title="定制错误"></a>定制错误</h4><p>可以根据不同的错误类型进行定制操作，下面将<code>url格式错误</code>与<code>参数错误</code>分别进行了处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class ParamError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;ParamError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;HttpError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if (!/^http/.test(url)) &#123;</span><br><span class="line">      throw new HttpError(&quot;请求地址格式错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else if (this.status == 404) &#123;</span><br><span class="line">        // throw new ParamError(&quot;用户不存在&quot;);</span><br><span class="line">        reject(new ParamError(&quot;用户不存在&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(&quot;加载失败&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(`http://localhost:8083?name=阿顺特烦恼`)</span><br><span class="line">.then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  if (error instanceof ParamError) &#123;</span><br><span class="line">    console.log(`参数错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  if (error instanceof HttpError) &#123;</span><br><span class="line">    alert(`url格式错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>无论状态是<code>resolve</code> 或 <code>reject</code> 都会执行此动作，<code>finally</code> 与状态无关。</p>
<ul>
<li>根据finally的特性，通常在其中做一些公共的操作，不论状态，都会执行的操作。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;reject&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve/reject状态都会执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>finally</code> 处理加载状态，当图片加载完成时移除加载图标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      .result &#123;</span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;loading&quot;&gt;loading...&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;result&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createImage(file) &#123;</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          let img &#x3D; new Image();</span><br><span class="line">          img.src &#x3D; file;</span><br><span class="line">          img.onload &#x3D; () &#x3D;&gt; resolve(img);</span><br><span class="line">          img.onerror &#x3D; () &#x3D;&gt; reject(&quot;加载失败&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        createImage(&quot;.&#x2F;images&#x2F;img1.jpg&quot;)</span><br><span class="line">          .then((img) &#x3D;&gt; &#123;</span><br><span class="line">            document.body.append(img);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; &quot;加载成功&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; err;</span><br><span class="line">          &#125;)</span><br><span class="line">          .finally(() &#x3D;&gt; &#123;</span><br><span class="line">            document.querySelector(&quot;div&quot;).style.display &#x3D; &quot;none&quot;;</span><br><span class="line">            document.querySelector(&quot;.result&quot;).style.display &#x3D; &quot;block&quot;;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><h5 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h5><p>下面是将 <code>ajax</code> 请求使用 <code>promise</code> 处理，代码结构清晰了很多</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&quot;http://localhost:8083/goodsList?name=new&quot;)</span><br><span class="line">.then(goods =&gt;ajax(`http://localhost:8083/category?id=$&#123;goods[&quot;id&quot;]&#125;`))</span><br><span class="line">.then(data =&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function loadJS(file) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">            script.src &#x3D; file;</span><br><span class="line">            document.body.append(script);</span><br><span class="line">            script.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              resolve(script);</span><br><span class="line">            &#125;;</span><br><span class="line">            script.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              reject(script);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        loadJS(&quot;.&#x2F;js&#x2F;ashun.js&quot;)</span><br><span class="line">          .then((script) &#x3D;&gt; &#123;</span><br><span class="line">            title();</span><br><span class="line">            console.log(&quot;ashun.js finishLaod&quot;);</span><br><span class="line">            return script;</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((ashunjs) &#x3D;&gt; &#123;</span><br><span class="line">            return loadJS(&quot;.&#x2F;js&#x2F;SHUN.js&quot;).then((script) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(&quot;SHUN.js finishLaod&quot;);</span><br><span class="line">              run();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((script) &#x3D;&gt; console.log(&#96;$&#123;script.src&#125;：加载失败&#96;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>下面是封装的<code>timeout</code> 函数，使用定时器操作更加方便</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function timeout(times) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, times);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(3000)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;3秒后执行&quot;);</span><br><span class="line">    return timeout(1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;执行上一步的promise后1秒执行&quot;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>使用Promise封装 <code>setInterval</code> 定时器并实现动画效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background: pink;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        function interval(callback, delay &#x3D; 5) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">              callback(id, resolve);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line"></span><br><span class="line">        function run() &#123;</span><br><span class="line">          const step &#x3D; 2;</span><br><span class="line">          interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">            let left &#x3D; parseFloat(window.getComputedStyle(div).left);</span><br><span class="line">            if (left &gt;&#x3D; 200) &#123;</span><br><span class="line">              clearInterval(timer);</span><br><span class="line">              resolve(&quot;left end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            div.style.left &#x3D; left + step + &quot;px&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(result);</span><br><span class="line">              return interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">                let width &#x3D; parseFloat(window.getComputedStyle(div).width);</span><br><span class="line">                if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">                  clearInterval(timer);</span><br><span class="line">                  resolve(&quot;width end&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                div.style.width &#x3D; width - step + &quot;px&quot;;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><ul>
<li>每个 <code>then</code> 都是一个promise，<code>then</code>会默认返回一个promise，且状态为fulfilled。</li>
<li>如果在 <code>then</code> 中手动返回一个新<code>promsie</code>，只当这个新的<code>promise</code> 确认状态后，才会继承执行下一个 <code>then</code></li>
</ul>
<h5 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h5><p>下面是对同一个 <code>promise</code> 分别使用不同的 <code>then</code> 进行操作 ，每个<code>then</code> 都得到了同一个promise 结果，这不是链式操作，实际使用意义不大。</p>
<img src="Promise.assets/Promise_then_1.png" alt="Promise_then_1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashuntefannao</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>promise</code> 中的 <code>then</code> 方法可以链式调用，<code>then</code> 方法的返回值会传递到下一个<code>then</code> 方法对应的处理函数中。</p>
<ul>
<li><code>then</code> 会返回一个<code>promise</code> ，所以如果有多个<code>then</code> 时会连续执行</li>
<li><code>then</code> 返回的值会做为当前<code>promise</code> 的结果</li>
</ul>
<p>下面是链式操作的 <code>then</code>，即始没有 <code>return</code> 也是会执行，因为每个<code>then</code> 默认会返回<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">    return title;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun-Ashuntefannao</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 方法可以返回一个新的<code>promise</code> 对象，等返回的<code>promise</code> 确认状态后，才会执行后面的 <code>then</code>。后面的<code>then</code> 方法就是对新返回的<code>promise</code> 状态的处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;第一个promise&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;第二个promise&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Promise类还提供一些静态方法，能够更好的处理异步操作。</p>
<ul>
<li>这些静态方法参数中若传入<code>非Promise</code>数据类型，则会将其转化为<code>Promise</code>,除了<code>reject</code>静态方法会默认将其转化为<code>Promise.resolve</code>,其余静态方法都会将其转化为<code>Promise.resolve</code>,数据本身作为返回结果。</li>
</ul>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p>使用 <code>promise.resolve(msg)</code> 方法可以快速的返回一个状态为resolve的promise对象。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Promise.resolve(&quot;fulfilled&quot;));	//Promise &#123;&lt;fulfilled&gt;: &quot;fulfilled&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state: rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        promise</span><br><span class="line">          .then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(rej);</span><br><span class="line">            return Promise.resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若传入值为promise，后续then处理的是传入的promsie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(Promise.reject(&quot;阿顺特烦恼&quot;)).catch((rej) &#x3D;&gt;console.log(rej));</span><br></pre></td></tr></table></figure>

<p>下面将请求结果缓存，如果再次请求时直接返回带值的 <code>promise</code></p>
<ul>
<li>为了演示使用了定时器，你也可以在后台设置延迟响应</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function query(name) &#123;</span><br><span class="line">  const cache = query.cache || (query.cache = new Map());</span><br><span class="line">  if (cache.has(name)) &#123;</span><br><span class="line">    console.log(&quot;走缓存了&quot;);</span><br><span class="line">    return Promise.resolve(cache.get(name));</span><br><span class="line">  &#125;</span><br><span class="line">  return ajax(`http://localhost:8083/users?name=$&#123;name&#125;`).then(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      cache.set(name, response);</span><br><span class="line">      console.log(&quot;没走缓存&quot;);</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>如果是 <code>then able</code> (具有then能力，类似promise)对象，会将对象包装成promise处理，这与其他promise处理方式一样的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const as = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.resolve(as).then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.resolve</code>,数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getName() &#123;</span><br><span class="line">  return &quot;ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Promise.resolve(getName).then((result) &#x3D;&gt; console.log(result()));</span><br><span class="line">&#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>



<h4 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h4><p>和 <code>Promise.resolve</code> 类似，<code>reject</code> 生成一个拒绝状态的<code>promise</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&quot;fail&quot;).catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Project.reject</code> 设置状态</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  if (v != &quot;Ashuntefannao&quot;) return Promise.reject(new Error(&quot;not Ashuntefannao&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.reject</code>数据本身作为<code>Promise.reject</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;name:&quot;Ashun&quot;&#125;;</span><br><span class="line">Promise.reject(obj).catch((reason) &#x3D;&gt; console.log(reason.name));</span><br><span class="line">&#x2F;&#x2F;Ashun</span><br></pre></td></tr></table></figure>



<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>使用<code>Promise.all(promiseArr)</code> 方法可以同时执行多个异步操作，比如页面加载时同进获取课程列表与推荐课程。</p>
<ul>
<li>任何一个 <code>Promise</code> 执行失败就会调用 <code>catch</code>方法</li>
<li>任何一个<code>Promise</code>没有确认状态，则all默认返回的promise状态也为pending，也就不会执行后续的then</li>
<li>适用于一次发送多个异步操作</li>
<li>参数必须是可迭代类型，如Array/Set</li>
<li>成功后返回包含 <code>promise</code> 结果的有序数组</li>
<li>若传入<code>非Promise</code>数据，则将其自动转化为<code>Promise.resolve</code>，数据本身作为返回值</li>
</ul>
<p>下例中当 <code>p1、p2</code> 两个 Promise 状态都为 <code>fulfilled</code> 时，p3状态才为<code>fulfilled</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 = new Promise((resolve) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p2 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p3 = Promise.all([p1, p2]).then(</span><br><span class="line">          (result) =&gt; console.log(result),</span><br><span class="line">          (err) =&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>若其中有一个promise状态为reject，则将调用<code>Promise.all()</code>后续<code>then</code>中的<code>onReject</code>，或<code>catch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;)</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2]).then(</span><br><span class="line">          (result) &#x3D;&gt; console.log(result),</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">…………</span><br><span class="line">let p3 &#x3D; Promise.all([p1, p2]).catch(</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>若某个状态为<code>rejected</code>的Promise已经被自身的<code>then</code>处理 , 那么该Promise最后返回的状态是<code>fulfilled</code>,(<strong>then默认返回状态为fulfilled的Promise</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;).then(null, (err) &#x3D;&gt; err);</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2])</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(&quot;有promise状态为rejected&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F; [&quot;p1 state: fulfilled&quot;, &quot;p2 state: reject&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据用户名获取用户，有任何一个用户获取不到时 <code>promise.all</code> 状态失败，执行 <code>catch</code> 方法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [&quot;阿顺&quot;, &quot;张三&quot;].map(name =&gt; &#123;</span><br><span class="line">  return ajax(`$&#123;api&#125;/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>可以将其他<code>非promise</code> 数据添加到 <code>all</code> 中，它将被处理成 <code>Promise.resolve</code>，数据本身会被当做<code>Promise.resolve</code>的返回值</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let getName = () =&gt; &quot;Ashun&quot;;</span><br><span class="line">        let Age = 18;</span><br><span class="line">        let promise = new Promise((resolve) =&gt; resolve(&quot;阿顺特烦恼&quot;));</span><br><span class="line">        Promise.all([getName, Age, promise]).then((result) =&gt;</span><br><span class="line">          console.log(result)</span><br><span class="line">        );</span><br><span class="line">        // [ƒ, 18, &quot;阿顺特烦恼&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h4><p><code>Promise.allSettled(PromsieArr)</code>，<strong>会将所有的Promsie视为已解决状态</strong>，会<code>忽略拒绝状态</code>的Promise，</p>
<p>拒绝状态的Promise信息，也会返回到最终的结果中。</p>
<ul>
<li>返回包含Promise状态和结果的有序数组</li>
<li><code>[&#123;status:resolve/reject,value/reason&#125;,&#123;…&#125;]</code></li>
</ul>
<p>下面的p2 返回状态为 <code>rejected</code> ，但<code>promise.allSettled</code> 不关心，<code>promise.allSettled</code>始终将自身状态设置为 <code>fulfilled</code> 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          resolve(&quot;p1 resolved&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          reject(&quot;p2 rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Promise.allSettled([p1, p2]).then((msg) =&gt; &#123;</span><br><span class="line">          console.log(msg);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line"> [</span><br><span class="line">	 &#123;status: &quot;fulfilled&quot;, value: &quot;p1 resolve&quot;&#125;,</span><br><span class="line">	 &#123;status: &quot;rejected&quot;, reason: &quot;p2 rejected&quot;&#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<p>下面是获取用户信息，但不关注某个用户是否获取不成功</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=阿顺`),</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=张三`)</span><br><span class="line">];</span><br><span class="line">Promise.allSettled(promises).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中若传入非promise数据类型，内部会转化为<code>Promise.resolve</code>,数据本身作为返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">				];</span><br><span class="line">Promise.allSettled(arr).then((result) &#x3D;&gt; console.log(result));</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">[</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: ƒ&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: 18&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>使用<code>Promise.race(promiseArr)</code> 能够处理容错异步，且返回最快确定状态的Promise结果，和<code>race</code>单词一样哪个Promise快用哪个，哪个先返回用哪个。</p>
<ul>
<li>以最快返回的promise为准</li>
<li>如果最快返加的状态为<code>rejected</code> 那整个<code>Promise.rece</code>状态为<code>rejected</code>执行cache</li>
<li>如果参数不是promise，内部将自动转为<code>Promise.resolve</code></li>
</ul>
<p>下例体现<code>Promise.rece</code>的特性，哪个Promise最先确定状态，就返回谁的处理结果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第一个Promise&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个异步&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([p1, p2])</span><br><span class="line">.then(results =&gt; &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// &quot;第二个异步&quot;</span><br></pre></td></tr></table></figure>

<p>可用其设置请求最长相应时间，下例：若请求在2秒内没有返回结果，则<code>promise.race</code> 状态失败,将会执行<code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const api &#x3D; &quot;http:&#x2F;&#x2F;localhost:8083&quot;;</span><br><span class="line">const promises &#x3D; [</span><br><span class="line">  ajax(&#96;$&#123;api&#125;&#x2F;users.php?name&#x3D;阿顺&#96;),</span><br><span class="line">  new Promise((a, b) &#x3D;&gt;</span><br><span class="line">    setTimeout(() &#x3D;&gt; b(new Error(&quot;request fail&quot;)), 2000)</span><br><span class="line">  )</span><br><span class="line">];</span><br><span class="line">Promise.race(promises)</span><br><span class="line">.then(response &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promises &#x3D; [</span><br><span class="line">          new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              resolve(&quot;请求成功&quot;);</span><br><span class="line">            &#125;, 1200);</span><br><span class="line">          &#125;),</span><br><span class="line">          new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              reject(&quot;请求超时&quot;);</span><br><span class="line">            &#125;, 1100);</span><br><span class="line">          &#125;),</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(promises)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((reason) &#x3D;&gt; console.log(reason));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数不是promise，内部将自动转为<code>Promise.resolve</code>,且数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(arr).then((result) &#x3D;&gt; console.log(result())); &#x2F;&#x2F;ashun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>如果在<code>then</code>中手动返回<code>promise</code> 时，后面的<code>then</code> 就是对返回的 <code>promise</code> 的处理</li>
<li>通过链式调用then，不断处理返回的Promsie，解决任务队列中的任务。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let promise = Promise.resolve();</span><br><span class="line">let p1 = promise.then(() =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p1`);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((a, b) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p2`);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; Promise.resolve();</span><br><span class="line">        promise &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;第一个then&quot;);</span><br><span class="line">            resolve(2);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(3);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(4);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Array.map</code> 构建的队列，有以下几点需要说明</p>
<ul>
<li><code>then</code> 内部返回的 <code>Promise</code> 更改外部的 <code>promise</code> 变量</li>
<li>为了让任务继续下去，执行完任务需要将 <code>promise</code> 状态修改为 <code>fulfilled</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          let promise = Promise.resolve();</span><br><span class="line">          tasks.map((val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line">shun-1</span><br><span class="line">第1个任务执行完毕，第2个任务开始执行</span><br><span class="line">Ashun-2</span><br><span class="line">第2个任务执行完毕，第3个任务开始执行</span><br><span class="line">Ashuntefannao-3</span><br></pre></td></tr></table></figure>

<p>下面再来通过 <code>reduce</code> 来实现队列</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          tasks.reduce((promise, val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">          &#125;, Promise.resolve());</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="高可用封装"><a href="#高可用封装" class="headerlink" title="高可用封装"></a>高可用封装</h4><p>上例中处理是在队列中完成，不方便业务定制，下面将Promise处理在剥离到外部</p>
<p><strong>后台请求处理类</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default function(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列处理类</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function(promises) &#123;</span><br><span class="line">  promises.reduce((promise, next) =&gt; promise.then(next), Promise.resolve())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后台脚本</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$users = [</span><br><span class="line">    1 =&gt; &quot;小明&quot;,</span><br><span class="line">    2 =&gt; &quot;李四&quot;,</span><br><span class="line">    3 =&gt; &quot;张三&quot;</span><br><span class="line">];</span><br><span class="line">sleep(1);</span><br><span class="line">echo $users[$_GET[&#x27;id&#x27;]];</span><br></pre></td></tr></table></figure>

<p><strong>使用队列</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import queue from &#x27;./queue.js&#x27;</span><br><span class="line">  import axios from &#x27;./axios.js&#x27;</span><br><span class="line">  queue(</span><br><span class="line">    [1, 2, 3].map(v =&gt; () =&gt;</span><br><span class="line">      axios(`user.php?id=$&#123;v&#125;`).then(user =&gt; console.log(user))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p> <code>async/await</code> 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。</p>
<ul>
<li><code>async/await</code> 本质还是promise，只是更简洁的语法糖书写</li>
<li><code>async/await</code> 使用更清晰的结构来替换 promise.then/catch 的方式</li>
<li><code>async/await</code>能够让异步代码，以<strong>同步的形式</strong>按顺序执行</li>
<li><code>async</code>声明的函数，会自动返回一个Promise。</li>
<li><code>await</code>必须在<code>async</code>声明的函数中使用。</li>
</ul>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>下面在 <code>fun</code> 函数前加上async，函数将默认返回一个状态为fulfilled的promise，函数体中使用return返回的数据，可以在后续的then中接收到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">				return &quot;阿顺特烦恼&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">fun().then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>

<p>若要按顺序处理多个异步代码块，使用传统的<code>promise.then/catch</code>在整个代码结构上，不如使用<code>async/await</code>清晰。</p>
<p>下例通过处理相同的问题，进行对比</p>
<p>使用传统<code>Promise</code>处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function promise(text) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(text || &quot;第一个then&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        promise()</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第二个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第三个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>async/await</code>处理可观察到，代码是按照同步形式执行的，结构更加清晰，代码量也减少了许多。</p>
<ul>
<li><code>await</code>相当于<code>then</code>，能够传递Promise的返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        async function promise(text) &#123;</span><br><span class="line">          return text || &quot;第一个then&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result1 &#x3D; await promise();</span><br><span class="line">          console.log(result1);</span><br><span class="line">          let result2 &#x3D; await promise(&quot;第二个then&quot;);</span><br><span class="line">          console.log(result2);</span><br><span class="line">          let result3 &#x3D; await promise(&quot;第三个then&quot;);</span><br><span class="line">          console.log(result3);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code>关键词后面紧跟Promise，使用 <code>await</code> 关键词，可以接收所处理的Promise的返回值，并且等待该Promise确定状态后，才可执行后面的代码。</p>
<ul>
<li><code>await</code> 后面一般是promise，如果不是直接返回</li>
<li><code>await</code> 必须放在 async 定义的函数中使用</li>
<li><code>await</code> 用于替代 <code>then</code> 使编码更优雅</li>
</ul>
<p>下例会在 await 这行等待promise执行，直到 promise 确认状态后才执行后续代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">  const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;Ashuntefannao&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">  let result = await promise;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>我们知道：在then中不能够返回所处理的Promise本身，会产生死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; Promise.resolve().then((_) &#x3D;&gt; p1);</span><br></pre></td></tr></table></figure>

<p>同理在<code>async</code>声明的函数中，也不能使用<code>await</code>处理函数本身。</p>
<ul>
<li>等待fun返回的promise确认状态，而fun在调用时，又会等待自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">	await fun();</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>下面是请求后台获取用户课程成绩的示例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function user() &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将操作放在立即执行函数中完成</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>下面是使用async 设置定时器，并间隔时间来输出内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function sleep(ms = 2000) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function run() &#123;</span><br><span class="line">  for (const value of [&quot;阿顺特烦恼&quot;, &quot;Ashun&quot;]) &#123;</span><br><span class="line">    await sleep();</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>



<h4 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h4><p>下面是模拟请求后台查看进度，进度条展示的效果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 0px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">        color: white;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#123;			</span><br><span class="line"> 				//随机产生小于3秒的请求时间。</span><br><span class="line">        function randomTime() &#123;</span><br><span class="line">          let max = 3;</span><br><span class="line">          let min = 1;</span><br><span class="line">          let multiple = Math.floor(Math.random() * (1000 - 100 + 1) + 100);</span><br><span class="line">          return Math.floor(Math.random() * (max - min + 1) + min) * multiple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">				//模拟请求延时。</span><br><span class="line">        async function request() &#123;</span><br><span class="line">          return new Promise((resolve) =&gt; setTimeout(resolve, randomTime()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div = document.querySelector(&quot;.loading&quot;);</span><br><span class="line">        //请求任务队列</span><br><span class="line">        let requsets = [request, request, request, request, request];</span><br><span class="line">        let sum = 0;</span><br><span class="line">        requsets.map(async (req) =&gt; &#123;</span><br><span class="line">          await req();</span><br><span class="line">          let percent = ++sum / requsets.length;</span><br><span class="line">          div.style.width = percent * 200 + &quot;px&quot;;</span><br><span class="line">          if (percent == 1) &#123;</span><br><span class="line">            div.innerHTML = &quot;加载完毕&quot;;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            div.innerHTML = percent * 100 + &quot;%&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="then-able"><a href="#then-able" class="headerlink" title="then able"></a>then able</h4><p>和 Promise 一样，await 也可以操作<code>then able</code> 对象</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    let user = ajax(`http://localhost:8083/user?name=$&#123;this.name&#125;`);</span><br><span class="line">    resolve(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async function get() &#123;</span><br><span class="line">  let user = await new User(&quot;阿顺&quot;);</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result &#x3D; await user;</span><br><span class="line">          console.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象、类中的方法，也可以用<code>async/await</code>处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        let obj &#x3D; &#123;</span><br><span class="line">          async getName() &#123;</span><br><span class="line">            let result &#x3D; await user;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    let user &#x3D; await ajax(</span><br><span class="line">      &#96;http:&#x2F;&#x2F;localhost:8083&#x2F;users?name&#x3D;$&#123;name&#125;&#96;</span><br><span class="line">    );</span><br><span class="line">    user.name +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new User().get(&quot;阿顺&quot;).then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="声明形式"><a href="#声明形式" class="headerlink" title="声明形式"></a>声明形式</h4><p>函数声明</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let get = async function(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对象方法声明</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">  	return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">as.get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>立即执行函数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=&quot;阿顺&quot;`);</span><br><span class="line">  let lessons = await ajax( </span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>类方法中的使用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User().get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>async 内部发生错误，会将返回的promise状态置为rejected 状态，所以可以使用<code>catch</code> 来处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function as() &#123;</span><br><span class="line">  console.log(shun);</span><br><span class="line">&#125;</span><br><span class="line">as().catch(error =&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是异步请求数据不存在时的错误处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(&quot;阿顺小哥&quot;).catch(error =&gt; &#123;</span><br><span class="line">  alert(&quot;用户不存在&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若await后的<code>promise</code> 被拒绝，并且没有使用<code>then\catch</code>处理，将抛出异常，可以使用 <code>try...catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let users = [&quot;阿顺&quot;, &quot;Ashun&quot;, &quot;shun&quot;];</span><br><span class="line"></span><br><span class="line">        async function getUser(name) &#123;</span><br><span class="line">        	let test = users.includes(name);</span><br><span class="line">          try &#123;</span><br><span class="line">            await new Promise((res, rej) =&gt; &#123;</span><br><span class="line">              console.log(test);</span><br><span class="line">              test ? res(test) : rej(`$&#123;name&#125; not find`);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getUser(&quot;阿顺A&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 await 时当前面的出现失败且未处理，后面的将不可以执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>如果对前一个错误进行了处理，后面的 await 可以继续执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;).catch(e =&gt; console.log(e));</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>try...catch</code> 特性忽略不必要的错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;&#125;</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以将多个 await 放在 try…catch 中统一处理错误</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function get(type) &#123;</span><br><span class="line">  const host = &quot;http://localhost:8083/&quot;</span><br><span class="line">  try &#123;</span><br><span class="line">    const goods = await ajax(`$&#123;host&#125;/goodsList?type=$&#123;type&#125;`);</span><br><span class="line">    const category = await ajax(`$&#123;host&#125;/category?id=$&#123;goods.id&#125;`);</span><br><span class="line">    console.log(lessons);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(&quot;商品不存在&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;new&quot;);</span><br></pre></td></tr></table></figure>



<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><p>有时需要多个await 同时执行，有以下几种方法处理，下面多个await 将产生等待</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">async function p1() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function p2() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashun&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await p1();</span><br><span class="line">  await p2();</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>使用 <code>Promise.all()</code> 处理多个promise并行执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await Promise.all([p1(), p2()]);</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>先执行返回promise，再使用await处理结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function promises() &#123;</span><br><span class="line">  let a1 = p1();</span><br><span class="line">  let a2 = p2();</span><br><span class="line">  await a1;</span><br><span class="line">  await a2;</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headPortrait.jpg">
      <meta itemprop="name" content="阿顺特烦恼">
      <meta itemprop="description" content="阿顺特烦恼,希望大家没有烦恼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AshunBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 13:37:21" itemprop="dateCreated datePublished" datetime="2021-05-16T13:37:21+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 09:02:01" itemprop="dateModified" datetime="2021-05-17T09:02:01+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaScript大总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>正则表达式是用于匹配字符串中<code>字符组合</code>的模式，在 JavaScript中，正则表达式也是对象。</p>
<ul>
<li>正则表达式是在宿主环境下运行的，如<code>js/php/node.js</code> 等 , 即在不同的语言中都会有正则表达式。</li>
<li>本章讲解的知识在其他语言中知识也是可用的，但是会有些函数使用上的区别</li>
</ul>
<h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p>与普通函数操作字符串来比较，正则表达式可以写出更简洁、功能强大的代码。</p>
<p>下面使用获取字符串中的所有数字来比较函数与正则的差异。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Str = &quot;Ashuntefannao1.1324Ashun&quot;;</span><br><span class="line">let numbers = [...Str].filter((char) =&gt; !isNaN(Number(char))).join(&quot;&quot;);</span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式将简单得多</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Str = &quot;Ashuntefannao1.1324Ashun&quot;;</span><br><span class="line">let numbers = Str.match(/\d/g).join(&quot;&quot;);</span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="创建正则"><a href="#创建正则" class="headerlink" title="创建正则"></a>创建正则</h4><p>JS提供<code>字面量</code>与<code>对象</code>两种方式创建正则表达式，推荐使用<code>字面量形式</code>创建RegExp，形式更加简洁。</p>
<h5 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h5><p>使用<code>//</code>包裹的字面量创建方式是推荐的作法，但不能在<code>//</code>中使用变量作为匹配规则</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let reg=/[A-Z]/;</span><br><span class="line">console.log(reg.test(as)); //true</span><br><span class="line">console.log(/[A-Z]/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p><code>//</code>包裹的字面量创建的正则，其中不能应用变量，作为匹配规则。</p>
<ul>
<li><code>//</code>包裹的内容会被理解为正则语法，所以其中的<code>z</code>不是变量，是匹配<code>z</code>字符</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let z = &quot;shun&quot;;</span><br><span class="line">console.log(/z/.test(as)); //false</span><br><span class="line">console.log(/z/.test(&quot;zheng&quot;))//true</span><br></pre></td></tr></table></figure>

<p>虽然可以使用 <code>eval</code> 计算字符串表达式，将其转换为js语法来实现将变量解析到正则中，但是比较麻烦，所以<code>有变量时</code>建议使用下面所讲的<code>对象创建</code>方式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let z = &quot;shun&quot;;</span><br><span class="line">console.log(eval(`/$&#123;z&#125;/`).test(as)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><p>当正则需要动态创建时（应用str变量），建议使用对象方式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;ashuntefannao&quot;;</span><br><span class="line">let str = &quot;ashun&quot;;</span><br><span class="line">let reg = new RegExp(str);</span><br><span class="line">console.log(reg.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>根据用户输入高亮显示内容，支持用户输入正则表达式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;content&quot;&gt;ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let matchStr = prompt(&quot;请输入搜索的字符串,支持输入正则&quot;);</span><br><span class="line">  let reg = new RegExp(matchStr, &quot;g&quot;);</span><br><span class="line">  let dom = document.querySelector(&quot;#content&quot;);</span><br><span class="line">  dom.innerHTML = dom.innerHTML.replace(reg, (str) =&gt; &#123;</span><br><span class="line">  	console.log(str);</span><br><span class="line">  	return `&lt;strong style=&quot;color:red;&quot;&gt;$&#123;str&#125;&lt;/strong&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过对象创建正则，提取标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ASHUN&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#123;</span><br><span class="line">        function getElement(ele) &#123;</span><br><span class="line">          let html = document.body.innerHTML;</span><br><span class="line">          let matchStr = `&lt;($&#123;ele&#125;)&gt;.+&lt;/\\1&gt;`;</span><br><span class="line">          let reg = new RegExp(matchStr, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">          console.table(html.match(reg));</span><br><span class="line">        &#125;</span><br><span class="line">        getElement(&quot;h1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h4><p>选择修释符<code>|</code> 这个符号带表<code>或</code>的关系，也就是 <code>|</code> 左右两侧有一个匹配到就可以。</p>
<h6 id="要注意：使用的范围不同，得到的结果也不同"><a href="#要注意：使用的范围不同，得到的结果也不同" class="headerlink" title="要注意：使用的范围不同，得到的结果也不同"></a><em>要注意：使用的范围不同，得到的结果也不同</em></h6><ul>
<li>如果在整个表达式使用，则将整个表达式一分为二</li>
<li>同理，在原子组中使用，则只是将当前原子组一分为二</li>
</ul>
<p>检测电话是否是上海或北京的坐机</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let tel = &quot;010-12345678&quot;;</span><br><span class="line">//错误结果：只匹配 | 左右两边任一结果</span><br><span class="line">console.log(tel.match(/010|020\-\d&#123;7,8&#125;/)); </span><br><span class="line"></span><br><span class="line">//正确结果：需要放在原子组中使用，将当前原子组一分为二</span><br><span class="line">console.log(tel.match(/(010|020)\-\d&#123;7,8&#125;/));</span><br></pre></td></tr></table></figure>

<p>匹配字符是否包含<code>ashuntefannao</code> 或 <code>ashun</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const title = &quot;ashuntefannao&quot;;</span><br><span class="line">console.log(/ashuntefannao|ashun/.test(title)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p><code>\被转义字符</code></p>
<ul>
<li><p>转义用于 <code>改变字符的含义</code>，用来处理 <code>某个字符有多种语义时</code> 的情况。</p>
</li>
<li><p>在正则中具有特殊意义的字符，使用时需要转义。</p>
</li>
<li><p>假如有这样的场景，如果我们想通过正则查找<code>/</code>符号，但是 <code>/</code>在正则中有特殊的意义。如果写成<code>///</code>这会造成解析错误，所以要使用转义语法 <code>/\//</code>来匹配。</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const url = &quot;https://www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/https:\/\//.test(url)); //true</span><br></pre></td></tr></table></figure>

<p>使用 <code>RegExp</code> 构建正则时在转义上会有些区别，下面是对象与字面量定义正则时区别</p>
<ul>
<li>在普通字符串中，转义一次字符，结果不变</li>
<li>由于使用对象形式<code>new RegExp(str,mode)</code>创建正则时，第一个参数接收的是字符串，需要在字符串中定义匹配的规则，所以 若使用特殊意义的匹配字符 需要转义两次。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let price = 12.23;</span><br><span class="line">//含义1: . 除换行外任何字符 	含义2: .普通点</span><br><span class="line">//含义1: d 字母d   					含义2: \d 数字 0~9</span><br><span class="line">console.log(/\d+\.\d+/.test(price));</span><br><span class="line"></span><br><span class="line">//字符串中 \d 与 d 是一样的，所以在 new RegExp 时\d 即为 d</span><br><span class="line">console.log(&quot;\d&quot; == &quot;d&quot;);</span><br><span class="line"></span><br><span class="line">//使用对象定义正则时，可以先把字符串打印一样，结果是字面量一样的定义就对了</span><br><span class="line">console.log(&quot;\\d+\\.\\d+&quot;);</span><br><span class="line">let reg = new RegExp(&quot;\\d+\\.\\d+&quot;);</span><br><span class="line">console.log(reg.test(price));</span><br></pre></td></tr></table></figure>

<p>下面是网址检测中转义符使用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let url = &quot;https://www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(url.match(/https?:\/\/w+\.\w+\.\w+/));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h4><p>使用字符边界符用于控制匹配内容的开始与结束约定。</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束，忽略换行符</td>
</tr>
</tbody></table>
<p>匹配内容必须以<code>www</code>开始</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const as = &quot;www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/^www/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>匹配内容必须以<code>.com</code>结束</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const as = &quot;www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/\.com$/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>检测用户名长度为3~6位，且只能为字母。如果不使用 <code>^与$</code> 限制将得不到正确结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  	document.querySelector(&quot;[name=&#x27;username&#x27;]&quot;)</span><br><span class="line">          .addEventListener(&quot;input&quot;, function () &#123;</span><br><span class="line">            let test = this.value.match(/^[a-zA-Z]&#123;3,6&#125;$/);</span><br><span class="line">            console.log(test ? &quot;正确&quot; : &quot;错误&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;[a-zA-Z]&#123;3,6&#125;&#x2F;;</span><br><span class="line">    let reg1 &#x3D; &#x2F;^[a-zA-Z]&#123;3,6&#125;$&#x2F;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;不使用^$限制，虽然字符串长度不足时也可返回正确结果</span><br><span class="line">    &#x2F;&#x2F;但字符串长度超出时，返回的是自前向后匹配的结果</span><br><span class="line">    console.log(&quot;as&quot;.match(reg));							&#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;123ashuntefannao123&quot;.match(reg));	&#x2F;&#x2F;[&quot;ashunt&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用^$进行限制，以字母3-6位开头，并以字母3-6位结尾，则匹配结果为3-6位纯字母</span><br><span class="line">    console.log(&quot;ashuntefannao&quot;.match(reg1)); &#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;as&quot;.match(reg1)); 						&#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;ashun&quot;.match(reg1)); 				&#x2F;&#x2F;[&quot;ashun&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只是用^限制，则只要开头满足3-6位纯字母即可</span><br><span class="line">    console.log(&quot;ashuntefannao123&quot;.match(&#x2F;^[a-zA-Z]&#123;3,6&#125;&#x2F;)); &#x2F;&#x2F;[&quot;ashunt&quot;]</span><br><span class="line">    &#x2F;&#x2F;只是用$限制，则只要结尾满足3-6位纯字母即可</span><br><span class="line">    console.log(&quot;132ashuntefannao&quot;.match(&#x2F;[a-zA-Z]&#123;3,6&#125;$&#x2F;)); &#x2F;&#x2F;[&quot;fannao&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符是正则表达式中的最小元素，只代表单一（一个）字符。</p>
<h4 id="普通元字符"><a href="#普通元字符" class="headerlink" title="普通元字符"></a>普通元字符</h4><p>普通元字符，即 在正则中没有特殊意义的 普通字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &quot;ashun&quot;;</span><br><span class="line">console.log(&#x2F;a&#x2F;.test(a)); 		&#x2F;&#x2F;true</span><br><span class="line">console.log(a.match(&#x2F;a&#x2F;)[0]); &#x2F;&#x2F;a</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="特殊元字符"><a href="#特殊元字符" class="headerlink" title="特殊元字符"></a>特殊元字符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配任意一个数字</td>
<td>[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>与除了数字以外的任何一个字符匹配</td>
<td>[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>与任意一个字母、数字、下划线匹配</td>
<td>[a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>除了 字母、数字、下划线以外 与任何字符匹配</td>
<td>[^a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>任意一个空白字符匹配，如空格，制表符<code>\t</code>，换行符<code>\n</code></td>
<td>[\n\f\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>除了空白符外任意一个字符匹配</td>
<td>[^\n\f\r\t\v]</td>
</tr>
<tr>
<td>\p{prop}</td>
<td>配合<code>u</code>模式，匹配对应属性的字符</td>
<td>( \p{P} | \p{sc=Han} )</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符外的任意字符</td>
<td>[^\n]</td>
</tr>
</tbody></table>
<h4 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h4><p>匹配任意数字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao 2020&quot;;</span><br><span class="line">console.log(as.match(/\d/g)); //[&quot;2&quot;, &quot;0&quot;, &quot;2&quot;, &quot;0&quot;]</span><br></pre></td></tr></table></figure>

<p>匹配所有电话号码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let as = `</span><br><span class="line">	张三:010-99999999,李四:020-88888888</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let res = as.match(/\d&#123;3&#125;-\d&#123;7,8&#125;/g);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<p>获取所有用户名</p>
<ul>
<li><code>-</code>在原子组<code>[]</code>中具有特殊含义，为了避免冲突，最好转义使用</li>
<li>下列情况是否转义，情况都相同，但在表示一些匹配范围时，就会有歧义</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let as = `</span><br><span class="line">张三:010-99999999,李四:020-88888888`;</span><br><span class="line">let res = as.match(/[^:\d-,\s]+/g);</span><br><span class="line"></span><br><span class="line">console.log(/[^:\d\-,\s]+/g)</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;103azA&quot;.match(&#x2F;[0\-9]&#x2F;g));	&#x2F;&#x2F;[&quot;0&quot;]</span><br><span class="line">console.log(&quot;103azA&quot;.match(&#x2F;[0-9]&#x2F;g));	&#x2F;&#x2F;[&quot;1&quot;,&quot;0&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure>

<p>也可使用<code>\p&#123;prop&#125;</code>结合<code>u</code>模式，匹配属性为汉字的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(as.match(&#x2F;\p&#123;sc&#x3D;Han&#125;&#123;2,3&#125;&#x2F;gu)); &#x2F;&#x2F;[&quot;张三&quot;,&quot;李四&quot;]</span><br></pre></td></tr></table></figure>



<p>匹配任意非数字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(/\D/.test(2029)); //false</span><br></pre></td></tr></table></figure>

<p>匹配字母数字下划线</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;ashun@&quot;;</span><br><span class="line">console.log(as.match(/\w/g)); //[&quot;a&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;]</span><br></pre></td></tr></table></figure>

<p>匹配除了字母,数字或下划线外与任何字符匹配</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(/\W/.test(&quot;@&quot;)); //true</span><br></pre></td></tr></table></figure>

<p>匹配与任意一个空白字符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(/\s/.test(&quot; &quot;)); //true</span><br><span class="line">console.log(/\s/.test(&quot;\n \t&quot;)); //true</span><br></pre></td></tr></table></figure>

<p>匹配除了空白符外任意一个字符匹配</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;ashun@&quot;;</span><br><span class="line">console.log(as.match(/\S/g)); //[&quot;a&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;,&quot;@&quot;]</span><br></pre></td></tr></table></figure>

<p>如果要匹配 字符串点<code>&quot;.&quot;</code> 则需要转义</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let as = `ashuntefannao@com`;</span><br><span class="line">console.log(/ashuntefannao.com/i.test(as));  //true</span><br><span class="line">console.log(/ashuntefannao\.com/i.test(as)); //false</span><br></pre></td></tr></table></figure>

<p>使用<code>.</code>匹配除换行符外任意字符，下面匹配不到<code>ashun.com</code> 因为有换行符 且没有使用<code>g</code>模式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const url = `</span><br><span class="line">  https://www.Ashuntefanano.com</span><br><span class="line">  ashun.com</span><br><span class="line">`;</span><br><span class="line">console.log(url.match(/.+/));</span><br></pre></td></tr></table></figure>

<p>特殊元字符<code>.</code> 配合<code>s</code>模式，<code>.</code>就可以匹配任意字符 (能够匹配换行符)</p>
<ul>
<li>使用<code>s</code>单行模式（忽略换行）时，可以匹配所有</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let title = `</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    ashuntefannao</span><br><span class="line">    ashun</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">`;</span><br><span class="line">let res = title.match(/&lt;span&gt;.*&lt;\/span&gt;/s);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>

<p>正则中会将 空格 按普通字符对待</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tel = `010 - 999999`;</span><br><span class="line">console.log(/\d+-\d+/.test(tel)); //false</span><br><span class="line">console.log(/\d+ - \d+/.test(tel)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="所有字符"><a href="#所有字符" class="headerlink" title="所有字符"></a>所有字符</h4><ul>
<li>可以使用 <code>[\s\S]</code>、<code>[\d\D]</code>、<code>[\w\W]</code>等等来匹配所有字符</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let as = `</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    ashuntefannao</span><br><span class="line">    ashun</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">`;</span><br><span class="line">let res = as.match(/&lt;span&gt;[\s\S]+&lt;\/span&gt;/);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code>结合<code>s</code>单行模式(忽略换行符)，也可匹配所有字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">let res &#x3D; title.match(&#x2F;&lt;span&gt;.*&lt;\&#x2F;span&gt;&#x2F;s);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>正则表达式在执行时会按他们的默认执行方式进行处理，但有时候默认的处理方式总不能满足我们的需求，所以可以切换不同的匹配模式满足业务需求。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>不区分大小写字母的匹配</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索所有匹配内容</td>
</tr>
<tr>
<td>m</td>
<td>视为多行</td>
</tr>
<tr>
<td>s</td>
<td>视为单行忽略换行符，使用<code>.</code> 可以匹配所有字符</td>
</tr>
<tr>
<td>y</td>
<td>从 <code>regexp.lastIndex</code> 开始匹配</td>
</tr>
<tr>
<td>u</td>
<td>Unicode模式，能够正确处理四个字符的 UTF-16 编码</td>
</tr>
</tbody></table>
<h4 id="i"><a href="#i" class="headerlink" title="i"></a>i</h4><p>将所有<code>ashuntefannao</code> 统一为小写</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let site = &quot;ashuntefannao ASHUNTEFANNAO&quot;;</span><br><span class="line">site = site.replace(/ashuntefannao/gi, &quot;ashuntefannao&quot;);</span><br><span class="line">console.log(site);</span><br></pre></td></tr></table></figure>



<h4 id="g"><a href="#g" class="headerlink" title="g"></a>g</h4><p>使用 <code>g</code> 模式，可以搜索到所有满足匹配规则的string</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        let as = &quot;ashuntefannao&quot;;</span><br><span class="line">        as = as.replace(/n/, &quot;@&quot;);</span><br><span class="line">        console.log(as); //没有使用 g 修饰符是，只替换了第一个 n</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        let as = &quot;ashuntefannao&quot;;</span><br><span class="line">        as = as.replace(/n/g, &quot;@&quot;);</span><br><span class="line">        console.log(as); //使用全局修饰符后替换了全部的 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p><code>m</code>多行匹配模式，结合<code>^$</code>可约束匹配字符串中的每一行。</p>
<p>也就是说：字符串存在换行符<code>\n</code>时，字符串有几行，就匹配多少次。并且每一行都可使用<code>^$</code>进行约束。</p>
<ul>
<li>默认情况下，无论字符串是否有换行符，都只有一个开头<code>^</code>和结尾<code>$</code></li>
<li>结合<code>m</code>模式，每一行都有自身的<code>^$</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let str &#x3D; &#96;</span><br><span class="line">      # jsES6 #</span><br><span class="line">      # vue2.0 #</span><br><span class="line">      # ashunte #</span><br><span class="line">      &#96;;</span><br><span class="line">      console.log(str.match(&#x2F;^\s*#\s+.*\s#$&#x2F;gm));	</span><br><span class="line">      console.log(str.match(&#x2F;^\s*#\s+.+#\s*$&#x2F;g));&#x2F;&#x2F;null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例是将以 <code>#数字</code>开始的课程解析为对象结构，学习过后面讲到的原子组可以让代码简单些</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  			let str = `</span><br><span class="line">  				#1 js,200元 #</span><br><span class="line">  				#2 php,300元 #</span><br><span class="line">  				#9 ashuntefannao # 阿顺特烦恼</span><br><span class="line">  				#3 node.js,180元 #</span><br><span class="line">				`;</span><br><span class="line">        let lessons = str.match(/^\s*#.+#$/gm);</span><br><span class="line">        console.log(lessons);</span><br><span class="line">        lessons = lessons</span><br><span class="line">          .map((v) =&gt; v.replace(/\s*#\d\s*/, &quot;&quot;).replace(/\s*#\s*/, &quot;&quot;))</span><br><span class="line">          .map((v) =&gt; &#123;</span><br><span class="line">            let [name, price] = v.split(&quot;,&quot;);</span><br><span class="line">            return &#123; name, price &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        console.log(JSON.stringify(lessons, null, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p><code>s</code>单行模式，在匹配时忽略<code>换行符</code>，结合<code>.</code>能够匹配所有字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#96;</span><br><span class="line">      ashuntefannao.com</span><br><span class="line">      999999999</span><br><span class="line">      !@#$%^&amp;*()_+-</span><br><span class="line">&#96;;</span><br><span class="line">console.log(str.match(&#x2F;.+&#x2F;gs));</span><br></pre></td></tr></table></figure>



<h4 id="u"><a href="#u" class="headerlink" title="u"></a>u</h4><ul>
<li>每个字符都有属性，如<code>L</code>属性表示是字母，<code>P</code> 表示标点符号</li>
<li>其他属性简写可以访问 <a target="_blank" rel="noopener" href="https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt">属性的别名</a>网站查看。</li>
<li>在正则中，使用<code>\p&#123;prop&#125;</code>来匹配对应属性的字符</li>
<li><code>\p&#123;prop&#125;</code>需要结合 <code>u</code> 模式才有效。</li>
</ul>
<p>字符也有unicode文字系统属性 <code>Script=文字系统</code>，下面是使用 <code>\p&#123;sc=Han&#125;</code> 获取中文字符 <code>han</code>为中文系统，其他语言请查看 <a target="_blank" rel="noopener" href="http://www.unicode.org/standard/supported.html">文字语言表</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let user &#x3D; &#96;</span><br><span class="line">        阿顺-157******01</span><br><span class="line">        张三-132******88</span><br><span class="line"> &#96;;</span><br><span class="line">let reg &#x3D; &#x2F;\p&#123;sc&#x3D;Han&#125;+&#x2F;gu;</span><br><span class="line">console.log(user.match(reg));</span><br></pre></td></tr></table></figure>

<p>使用 <code>u</code> 模式可以正确处理四个字符的 UTF-16 字节编码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;𝒳𝒴&quot;;</span><br><span class="line">console.table(str.match(/[𝒳𝒴]/)); //结果为乱字符&quot;�&quot;</span><br><span class="line"></span><br><span class="line">console.table(str.match(/[𝒳𝒴]/u)); //结果正确 &quot;𝒳&quot;</span><br></pre></td></tr></table></figure>



<h4 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h4><p><code>reg.lastIndex</code> 可以返回或者设置正则表达式<code>开始匹配的位置</code></p>
<ul>
<li><strong>必须结合 <code>g</code>或<code>y</code> 模式使用</strong></li>
<li><strong>只对 <code>exec</code> 方法有效</strong></li>
<li><strong>使用 <code>exec</code> 匹配完所有结果时，<code>lastIndex</code> 会被重置为0</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        let text = `阿顺特烦恼希望大家没有烦恼,阿顺不喜欢烦恼`;</span><br><span class="line">        let reg = /阿顺(.&#123;2&#125;)/g;</span><br><span class="line">        reg.lastIndex = 10; //从索引10开始搜索</span><br><span class="line">        console.log(reg.exec(text));</span><br><span class="line">        console.log(reg.lastIndex); //上次匹配的结束位置+1=下次匹配的开始位置:18</span><br><span class="line"></span><br><span class="line">        reg = /\p&#123;sc=Han&#125;/gu;</span><br><span class="line">        while ((res = reg.exec(text))) &#123;</span><br><span class="line">          console.log(res[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(reg.lastIndex);	//匹配完所有结果，lastIndex重置为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reg.lastIndex</code>只对<code>reg.exec</code>有效，对<code>str.match()</code>毫无影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let str &#x3D; &quot;ashuntefannao&quot;;</span><br><span class="line">      let reg &#x3D; &#x2F;a&#x2F;g;</span><br><span class="line">      reg.lastIndex &#x3D; 11;</span><br><span class="line">      console.log(str.match(reg)); &#x2F;&#x2F;[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="y"><a href="#y" class="headerlink" title="y"></a>y</h4><p>我们来对比 <code>y</code> 与<code>g</code> 模式，在结合<code>lastIndex</code>时的使用差异。</p>
<ul>
<li>使用 <code>g</code> 模式会全局匹配，从头查到尾，一直匹配字符串</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let str = &quot;ashuntefannao&quot;;</span><br><span class="line">        let reg = /a/g;</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //1</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //9</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //12</span><br><span class="line">        console.log(reg.exec(str)); //null</span><br><span class="line">        console.log(reg.lastIndex); //0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但使用<code>y</code> 模式后如果从 <code>lastIndex</code> 开始匹配不成功就不继续匹配了 ，匹配结束<code>lastIndex</code>也会置为0</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;fannao&quot;;</span><br><span class="line">let reg = /a/y;</span><br><span class="line">reg.lastIndex = 1;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">console.log(reg.lastIndex); //2</span><br><span class="line">console.log(reg.exec(str)); //null</span><br><span class="line">console.log(reg.lastIndex); //0</span><br></pre></td></tr></table></figure>

<p>因为使用 <code>y</code> 模式可以在<code>lastIndex</code>匹配不到时停止匹配，起到及时止损的作用，在匹配下面字符中的qq时可以提高匹配效率</p>
<ul>
<li>如果提前知道匹配目标 <strong><code>是连续在一起的</code></strong> 那么使用<code>y</code>模式会更加的高效</li>
<li>但由于需要结合<code>lastIndex</code>,所以只能够使用<code>reg.exec</code>结合循环匹配。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let title = `阿顺特烦恼QQ群:11111111,999999999,88888888</span><br><span class="line">        阿顺特烦恼希望大家没有烦恼,阿顺不喜欢烦恼`;</span><br><span class="line"></span><br><span class="line">        let reg = /(\d+),?/y;</span><br><span class="line">        reg.lastIndex = 9;</span><br><span class="line">        while ((res = reg.exec(title))) console.log(res[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="原子表"><a href="#原子表" class="headerlink" title="原子表"></a>原子表</h3><p>在一组字符中匹配某个元字符，在正则表达式中通过元字符表来完成，就是放到<code>[]</code> (方括号)中。</p>
<h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h4><table>
<thead>
<tr>
<th>原子表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ … ]</td>
<td>只匹配其中的一个元字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配<code>除了</code>其中所有字符的任意一个元字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配0-9任何一个数字</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配小写a-z任何一个字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配大写A-Z任何一个字母</td>
</tr>
</tbody></table>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>使用<code>[]</code>匹配其中任意字符即成功，下例中匹配<code>Af</code>其中一个字符，而不会当成一个整体来对待</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const title = &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log(/Af/.test(title)); //false</span><br><span class="line">console.log(/[Af]/.test(title)); //true</span><br></pre></td></tr></table></figure>

<p>日期的匹配</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let time = &quot;2022-02-23&quot;;</span><br><span class="line">console.log(time.match(/\d&#123;4&#125;([-\/])\d&#123;2&#125;\1\d&#123;2&#125;/));</span><br></pre></td></tr></table></figure>

<p>获取<code>0~3</code>间的任意数字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const num = &quot;2&quot;;</span><br><span class="line">console.log(/[0-3]/.test(num)); //true</span><br></pre></td></tr></table></figure>

<p>匹配<code>a~f</code>间的任意字符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char = &quot;e&quot;;</span><br><span class="line">console.log(/[a-f]/.test(char)); //true</span><br></pre></td></tr></table></figure>

<p>顺序必须为<code>升序</code>，否则将报错</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const num = &quot;2&quot;;</span><br><span class="line">console.log(/[3-0]/.test(num)); //SyntaxError</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const as = &quot;ashuntefannao&quot;;</span><br><span class="line">console.log(/[f-a]/.test(as)); //SyntaxError</span><br></pre></td></tr></table></figure>

<p><code>排除法 ^ </code>获取所有用户名</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user = `</span><br><span class="line">张三:010-99999999,李四:020-88888888`;</span><br><span class="line">let res = user.match(/[^\s:\d\-,]+/g);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>[\s\S]</code> 或 <code>[\d\D]</code>等等，匹配到所有字符包括换行符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const reg = /[\s\S]+/g;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是使用原子表知识删除所有标题</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;div id=&quot;content&quot;&gt;</span><br><span class="line"> 			ashuntefannao</span><br><span class="line"> 			&lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line"> 		&lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;ASHUN&lt;/h2&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let html = document.body;</span><br><span class="line">        console.log(html.innerHTML.match(/^\s*&lt;(h[0-6])&gt;.*&lt;\/\1&gt;\s*$/gm));</span><br><span class="line"></span><br><span class="line">        html.innerHTML = html.innerHTML.replace(</span><br><span class="line">          /^\s*&lt;(h[0-6])&gt;.*&lt;\/\1&gt;\s*$/gm,</span><br><span class="line">          &quot;&quot;</span><br><span class="line">        );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="不需要转义的字符"><a href="#不需要转义的字符" class="headerlink" title="不需要转义的字符"></a>不需要转义的字符</h5><p>有些字符在正则中具有特殊含义，但是在原子组中却不用转义，只视为普通字符。</p>
<ul>
<li><code>|</code> ,  原子表中的<code>|</code>只是普通字符，不是选择符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;ASHUN|as&quot;.match(&#x2F;[a|A]&#x2F;g)); &#x2F;&#x2F;[&quot;A&quot;, &quot;|&quot;, &quot;a&quot;]</span><br><span class="line">console.log(&quot;ASHUN|as&quot;.match(&#x2F;(a|A)&#x2F;g)); &#x2F;&#x2F;[&quot;A&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code>  在原子表中也没有特殊含义，只是普通的字符<code>&quot;.&quot;</code>。</li>
<li><code>+</code>  在原子表中也只是普通字符<code>&quot;+&quot;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(site.match(&#x2F;[\w+.\w+]&#x2F;g).join(&quot;&quot;));</span><br><span class="line">console.log(site.match(&#x2F;[\w.]&#x2F;g).join(&quot;&quot;));</span><br></pre></td></tr></table></figure>

<p>若想使用这些特殊含义的字符，可以使用原子组<code>()</code>结合选择符<code>|</code>，让匹配形成<code>或</code>的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(site.match(&#x2F;(\w+|\.)&#x2F;g));</span><br><span class="line">console.log(site.match(&#x2F;(.+)&#x2F;g));</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="原子组"><a href="#原子组" class="headerlink" title="原子组"></a>原子组</h3><ul>
<li>如果一次要匹配多个元子，可以通过元子组完成</li>
<li>原子组与原子表的差别在于原子组一次匹配多个元子，而原子表则是匹配任意一个字符，而且原子组配合其它的方法，能够完成给更多的功能</li>
<li>元字符组用 <code>()</code> 包裹</li>
</ul>
<p>下面使用原子组匹配 <code>h1</code> 标签，如果想匹配 <code>h2</code> 只需要把前面原子组改为 <code>h2</code> 即可。</p>
<ul>
<li>匹配结束标签时的 <code>\1</code> 意为：应用第一个原子组匹配到的内容</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const dom = `&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;`;</span><br><span class="line">console.log(/&lt;(h1)&gt;.+&lt;\/\1&gt;/.test(hd)); //true</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>没有使用 <code>g</code> 模式时，自前向后只匹配到第一个，使用<code>str.match\reg.exec</code>方法 匹配到的信息包含以下数据</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>匹配到的完整内容</td>
</tr>
<tr>
<td>1,2….</td>
<td>匹配到的各个原子组内容</td>
</tr>
<tr>
<td>index</td>
<td>匹配到的str在原字符串中的位置</td>
</tr>
<tr>
<td>input</td>
<td>原字符串</td>
</tr>
<tr>
<td>groups</td>
<td>命名分组</td>
</tr>
</tbody></table>
<img src="正则表达式.assets/RegExp_1.png" alt="RegExp_1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let title &#x3D; &quot;&lt;h3&gt;Ashun阿顺&lt;&#x2F;h3&gt;&quot;;</span><br><span class="line">      let reg &#x3D; &#x2F;&lt;(h[0-9])&gt;(.+)&lt;\&#x2F;\1&gt;&#x2F;;</span><br><span class="line">      console.log(title.match(reg));</span><br><span class="line">      console.log(reg.exec(title));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(as.match(/fan(nao)\.(com)/));</span><br><span class="line">//[&quot;fannao.com&quot;, &quot;nao&quot;, &quot;com&quot;, index: 7, input: &quot;Ashuntefannao.com&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>



<p>下面使用原子组匹配标题元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let content = `</span><br><span class="line">        &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">        &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">        &lt;h2&gt;Ashun&lt;/h2&gt;</span><br><span class="line">      `;</span><br><span class="line"></span><br><span class="line">        console.table(content.match(/&lt;(h[1-6])[\s\S]*&lt;\/\1&gt;/g));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，在匹配标签对内容时，匹配的是任意字符，但是这样在同级别标题连续时，就会出错。</p>
<p>会将<code>&lt;h1&gt;阿顺特烦恼&lt;/h1&gt; \n &lt;h1&gt;ashun&lt;/h1&gt;</code>视为<code>&lt;h1&gt;阿顺……ashun&lt;/h1&gt;</code>，两个标签的匹配结果只有一项</p>
<ul>
<li>应该排除换行符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let content &#x3D; &#96;</span><br><span class="line">        &lt;h1&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;Ashuntefannao&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;span&gt;阿顺&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;h2&gt;Ashun&lt;&#x2F;h2&gt;</span><br><span class="line">      &#96;;</span><br><span class="line"></span><br><span class="line">        console.table(content.match(&#x2F;&lt;(h[1-6])[\s\S]*&lt;\&#x2F;\1&gt;&#x2F;g));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;标签内容应该排除换行符</span><br><span class="line">        console.table(content.match(&#x2F;&lt;(h[1-6]).*&lt;\&#x2F;\1&gt;&#x2F;g));</span><br><span class="line">        console.table(content.match(&#x2F;^\s*&lt;(h[1-6]).*&lt;\&#x2F;\1&gt;\s*$&#x2F;gm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测 <code>0~100</code> 的数值，使用 <code>parseInt</code> 将数值转为10进制</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(/^(\d&#123;1,2&#125;|100)$/.test(parseInt(09, 10)));</span><br></pre></td></tr></table></figure>



<h4 id="邮箱匹配"><a href="#邮箱匹配" class="headerlink" title="邮箱匹配"></a>邮箱匹配</h4><p>下面使用原子组匹配邮箱</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let email = &quot;2300071698@qq.com&quot;;</span><br><span class="line">let reg = /^[\w\-]+@[\w\-]+\.(com|org|cn|cc|net)$/i;</span><br><span class="line">console.dir(email.match(reg));</span><br></pre></td></tr></table></figure>

<p>如果邮箱是以下格式 <code>Ashuntefannao@as.com.cn</code> 上面规则将无效，需要定义以下方式</p>
<ul>
<li>将<code>xxx.</code>这样的后缀，封装为分子组，匹配一个或多个</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let email = `admin@Ashun.com.cn`;</span><br><span class="line">let reg = /^[\w-]+@([\w-]+\.)+(org|com|cc|cn)$/;</span><br><span class="line">console.log(email.match(reg));</span><br></pre></td></tr></table></figure>





<h4 id="引用原子组"><a href="#引用原子组" class="headerlink" title="引用原子组"></a>引用原子组</h4><ul>
<li><code>\number</code> 在<strong>匹配</strong>时引用第<code>number</code>个原子组匹配的数据</li>
<li><code>$number</code> 在<strong>替换</strong>时引用第<code>number</code>个原子组匹配的数据。</li>
</ul>
<p>下面将 标题标签 替换为 <code>p</code>标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let content = `</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">  &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;SHUN&lt;/h2&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /&lt;(h[1-6])&gt;(.*)&lt;\/\1&gt;/gi;</span><br><span class="line">console.log(content.replace(reg, `&lt;p&gt;$2&lt;/p&gt;`));</span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title="? :"></a>? :</h4><p>如果希望原子组<strong>只参与匹配，不返回到结果当中</strong>，可使用 <code>?:</code> 处理。<code>:?</code>置于原子组头部。</p>
<p>下面是获取所有域名的示例</p>
<ul>
<li>由于下面第二层嵌套的原子组都使用<code>?:</code>处理，则在返回结果中，便没有了属性<code>2~n</code>，但有属性<code>1</code>返回第一层原子组匹配到的域名部分</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let webs = `</span><br><span class="line">  https://www.Ashuntefannao.com</span><br><span class="line">  http://Ashunwang.com</span><br><span class="line">  https://Ashun.com</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /https?:\/\/((?:\w+\.)?\w+\.(?:com|org|cn))/gi;</span><br><span class="line">while ((v = reg.exec(webs))) &#123;</span><br><span class="line">  console.dir(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="别名-lt-gt"><a href="#别名-lt-gt" class="headerlink" title="别名?&lt;&gt;"></a>别名?&lt;&gt;</h4><p>默认情况下，在不使用<code>g</code>模式时，并结合<code>str.match/reg.exec</code>方法时，各原子组匹配的结果将会存储到<code>1~n</code>属性中，但如果原子组过多，也就代表RegExp越复杂，就越不容易找到对应的原子组匹配结果。</p>
<p>如果希望返回的组数据更清晰，可以为原子组命名，结果将保存在返回的 <code>groups</code>字段中</p>
<ul>
<li>语法<code>?&lt;alia&gt;</code>,将其置于原子组头部即可</li>
</ul>
<img src="正则表达式.assets/RegExp_2.png" alt="RegExp_2" style="zoom:80%;" />

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let title = &quot;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&quot;;</span><br><span class="line">console.dir(title.match(/&lt;(?&lt;tag&gt;h[1-6])(?&lt;content&gt;.*)&lt;\/\1&gt;/));</span><br></pre></td></tr></table></figure>



<h5 id="引用别名原子组"><a href="#引用别名原子组" class="headerlink" title="引用别名原子组"></a>引用别名原子组</h5><p>别名不能在参与匹配时引用，若想引用对应原子组，还是通过<code>\number</code>进行引用</p>
<ul>
<li><code>\number</code>，参与匹配时引用</li>
<li><code>$&lt;alia&gt;</code>，参与替换时使用</li>
</ul>
<p>组别名使用 <code>?&lt;&gt;</code> 形式定义，下面将标签替换为<code>p</code>标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let txt = `</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">  &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;SHUN&lt;/h2&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /&lt;(?&lt;tag&gt;h[1-6])&gt;(?&lt;content&gt;[\s\S]*)&lt;\/\1&gt;/gi;</span><br><span class="line">console.log(txt.replace(reg, `&lt;p&gt;$&lt;content&gt;&lt;/p&gt;`));</span><br></pre></td></tr></table></figure>

<p>获取链接与网站名称组成数组集合</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;a href=&quot;https://astfn.github.io&quot;&gt;AshunBlog&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://www.hdcms.com&quot;&gt;hdcms&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://www.sina.com.cn&quot;&gt;新浪&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   let body = document.body;</span><br><span class="line">   let reg = /^\s*&lt;a.+href=.*(?&lt;link&gt;https?:\/\/([-\w]+\.)+(?:cn|com|org|cc|github|io)).*&gt;(?&lt;name&gt;.*)&lt;\/a&gt;\s*$/gim;</span><br><span class="line">    let arr = [];</span><br><span class="line">    while ((exec = reg.exec(body.innerHTML))) &#123;</span><br><span class="line">      arr.push(exec[&quot;groups&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>如果要重复匹配一些内容时我们要使用重复匹配修饰符，包括以下几种。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>重复匹配可以应用于:</p>
<ul>
<li>单个字符</li>
<li>原子表</li>
<li>原子组</li>
</ul>
<blockquote>
<p>因为正则最小单位是元字符，而我们很少只匹配一个元字符如a、b所以基本上重复匹配在每条正则语句中都是必用到的内容。</p>
</blockquote>
<p>默认情况下,重复选项对单个字符进行重复匹配，是贪婪匹配，一只匹配到不重复为止。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;assshun&quot;;</span><br><span class="line">console.log(as.match(/as+/i)); //asss</span><br></pre></td></tr></table></figure>

<p>使用原子组后则对整个组重复匹配</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;ashunAshuntefannao&quot;;</span><br><span class="line">console.log(as.match(/(ashun)+/i)); //ashunAshun</span><br></pre></td></tr></table></figure>

<p>下面是验证坐机号的正则</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tell = &quot;010-12345678&quot;;</span><br><span class="line">console.log(/^0\d&#123;2,3&#125;-\d&#123;7,8&#125;$/.exec(tell));</span><br></pre></td></tr></table></figure>

<p>验证用户名只能为3~8位的字母或数字，并以字母开始</p>
<ul>
<li>像这种严格约束的正则，需要用<code>^…$</code>进行约束，若不使用其进行约束，那么如果用户名符合字母\数字，但是位数超过8位，也能匹配成功，只不过只返回前8位。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#123;</span><br><span class="line">        let input = document.querySelector(&quot;[name=&#x27;username&#x27;]&quot;);</span><br><span class="line">        let reg = /^[a-zA-Z](\d|[a-zA-Z])&#123;2,7&#125;$/;</span><br><span class="line">        input.addEventListener(&quot;input&quot;, function () &#123;</span><br><span class="line">          console.log(reg.test(this.value) ? &quot;正确&quot; : &quot;错误&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>验证密码必须包含大写字母并在5~10位之间</p>
<ul>
<li>多种验证组合，可以将regexp置于数组中，遍历数组过程中对str进行判断</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let input = document.querySelector(`[name=&quot;password&quot;]`);</span><br><span class="line">input.addEventListener(&quot;keyup&quot;, e =&gt; &#123;</span><br><span class="line">  const value = e.target.value.trim();</span><br><span class="line">  const regs = [/^[a-zA-Z0-9]&#123;5,10&#125;$/, /[A-Z]/];</span><br><span class="line">  let state = regs.every(v =&gt; v.test(value));</span><br><span class="line">  console.log(state ? &quot;正确！&quot; : &quot;密码必须包含大写字母并在5~10位之间&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="禁止贪婪"><a href="#禁止贪婪" class="headerlink" title="禁止贪婪"></a>禁止贪婪</h4><p>正则表达式在进行重复匹配时，<strong>默认是贪婪匹配模式</strong>，也就是说会尽量匹配更多内容，但是有的时候我们并不希望他匹配更多内容，这时可以通过 <strong><code>?</code></strong> 对 重复匹配语法 进行修饰，会尽可能的少匹配。</p>
<table>
<thead>
<tr>
<th>使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>0个或多个，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>1个或多个，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>0个或1个，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>n~m个，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>&gt;=n个，但尽可能少重复</td>
</tr>
</tbody></table>
<p>下面是禁止贪婪的语法例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let str &#x3D; &quot;assshun&quot;;</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as+?&#x2F;;      &#x2F;&#x2F;as</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as*?&#x2F;;      &#x2F;&#x2F;a</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as??&#x2F;;      &#x2F;&#x2F;a</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as&#123;2,&#125;?&#x2F;;   &#x2F;&#x2F;ass</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as&#123;2,3&#125;?&#x2F;;  &#x2F;&#x2F;ass</span><br><span class="line"></span><br><span class="line">     console.log(str.match(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有span更换为<code>h5</code> 并描红，并在内容前加上 <code>阿顺-</code></p>
<ul>
<li>之前我们提到过，在匹配标签时，标签对的内容要忽略换行符，为了避免同名标签连续时，合并匹配的情况</li>
<li>其实我们也可使用禁止贪婪，来进行约束，并且禁止贪婪情况下，也就不必使用<code>m</code>模式配合<code>^$</code>进行严格约束了。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;span&gt;ashunwang&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;ashun.com&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;ashuntefannao.com&lt;/span&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg = /&lt;span&gt;([\s\S]+?)&lt;\/span&gt;/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(reg, (v, p1) =&gt; &#123;</span><br><span class="line">    console.log(p1);</span><br><span class="line">    return `&lt;h4 style=&quot;color:red&quot;&gt;后盾人-$&#123;p1&#125;&lt;/h4&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是使用禁止贪婪查找页面中的标题元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">      ashuntefannao</span><br><span class="line">      &lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;ASHUN&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#123;</span><br><span class="line">        let body = document.body.innerHTML;</span><br><span class="line">        let reg = /&lt;(h[1-6])&gt;[\s\S]*?&lt;\/\1&gt;/gi;</span><br><span class="line">        // let reg = /^\s*?&lt;(h[1-6])&gt;[\s\S]*?&lt;\/\1&gt;\s*?$/gim;</span><br><span class="line">        console.table(body.match(reg));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="细节返回"><a href="#细节返回" class="headerlink" title="细节返回"></a>细节返回</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>通过之前的使用，我们知道<code>str.match</code>方法：</p>
<ul>
<li>在非<code>g</code>全局匹配模式下，只返回一个匹配结果，并且包含匹配细节参数</li>
<li>在<code>g</code>模式下，返回一个包含所有匹配内容的Array，但是每个元素不包含匹配细节</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function elem(tag) &#123;</span><br><span class="line">    const reg = new RegExp(`&lt;($&#123;tag&#125;).*&gt;.+?&lt;/\\1&gt;`, &quot;g&quot;);</span><br><span class="line">    return document.body.innerHTML.match(reg);</span><br><span class="line">  &#125;</span><br><span class="line">  console.table(elem(&quot;h1&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll"></a>matchAll</h4><p>在<strong>新版本浏览器</strong>中支持使用 <code>matchAll</code> 操作，并返回迭代对象</p>
<blockquote>
<p>需要添加 <code>g</code> 修饰符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let str &#x3D; &quot;as&quot;;</span><br><span class="line">     let reg &#x3D; &#x2F;.&#x2F;g;</span><br><span class="line">     let iterator &#x3D; str.matchAll(reg);</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:Array(1), done:false &#125;</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:Array(1), done:false &#125;</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:undefined, done:true &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可迭代对象可使用<code>for/of</code>遍历</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao&quot;;</span><br><span class="line">let reg = /[a-z]/ig;</span><br><span class="line">for (const iterator of str.matchAll(reg)) &#123;</span><br><span class="line">  console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原型定义 <code>matchAll</code>方法，用于在旧浏览器中工作，不需要添加<code>g</code> 模式运行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        String.prototype.matchAll = function (reg) &#123;</span><br><span class="line">          let match = this.match(reg);</span><br><span class="line">          if (match) &#123;</span><br><span class="line">            let str = this.replace(reg, &quot;^&quot;.repeat(match[0].length));</span><br><span class="line">            let matchArr = str.matchAll(reg) || [];</span><br><span class="line">            return [match, ...matchArr];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        let reg = /a/;</span><br><span class="line">        console.log(&quot;ashuna&quot;.matchAll(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>使用 <code>g</code> 模式修正符并结合 <code>exec</code> 循环操作可以获取结果和匹配细节</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;Ashun.com&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function search(string, reg) &#123;</span><br><span class="line">    const matchs = [];</span><br><span class="line">    while ((data = reg.exec( string))) &#123;</span><br><span class="line">      matchs.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">    return matchs;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(search(document.body.innerHTML, /&lt;(h[1-6]).*?&gt;[\s\S]+?&lt;\/\1&gt;/gi));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用上面定义的函数来检索字符串中的网址</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sites = `https://ashunwang.com  </span><br><span class="line">https://www.sina.com.cn</span><br><span class="line">https://astfn.github.io`;</span><br><span class="line"></span><br><span class="line">let res = search(sites, /https?:\/\/(\w+\.)?(\w+\.)+(com|cn|io)/gi);</span><br><span class="line">console.dir(res);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>下面介绍的方法是 <code>String</code> 提供的支持正则表达式的方法</p>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p><code>search(str/reg)</code> 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索，返回值为索引位置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(str.search(&quot;.com&quot;));</span><br></pre></td></tr></table></figure>

<p>使用正则表达式搜索</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(str.search(/\.com/i));</span><br></pre></td></tr></table></figure>

<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>直接使用字符串搜索</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(str.match(&quot;com&quot;));</span><br></pre></td></tr></table></figure>

<p>使用正则获取内容，下面是简单的搜索字符串, 非<code>g</code>模式下，只匹配一次，且返回详细参数信息。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao&quot;;</span><br><span class="line">let res = as.match(/a/i);</span><br><span class="line">console.log(res);</span><br><span class="line">console.log(res[0]); //匹配的结果</span><br><span class="line">console.log(res[index]); //出现的位置</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>g</code> 修饰符时，就不会有结果的详细信息了（可以使用exec），下面是获取所有h1~6的标题元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let body = document.body.innerHTML;</span><br><span class="line">let result = body.match(/&lt;(h[1-6]).*?&gt;[\s\S]+?&lt;\/\1&gt;/g);</span><br><span class="line">console.table(result);</span><br></pre></td></tr></table></figure>

<h4 id="matchAll-1"><a href="#matchAll-1" class="headerlink" title="matchAll"></a>matchAll</h4><p>在新浏览器中支持使用 <code>matchAll</code> 结合<code>g</code>模式操作，并返回迭代对象</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao&quot;;</span><br><span class="line">let reg = /[a-z]/ig;</span><br><span class="line">for (const iterator of str.matchAll(reg)) &#123;</span><br><span class="line">  console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>用于使用字符串或正则表达式分隔字符串，下面是使用字符串分隔日期</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;2023-02-12&quot;;</span><br><span class="line">console.log(str.split(&quot;-&quot;)); //[&quot;2023&quot;, &quot;02&quot;, &quot;12&quot;]</span><br></pre></td></tr></table></figure>

<p>如果日期的连接符不确定，那就要使用正则操作了</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;2023/02-12&quot;;</span><br><span class="line">console.log(str.split(/-|\//));</span><br></pre></td></tr></table></figure>



<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><code>replace</code> 方法不仅可以执行基本字符替换，也可以进行正则替换，下面替换日期连接符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;2023/02/12&quot;;</span><br><span class="line">console.log(str.replace(/\//g, &quot;-&quot;)); //2023-02-12</span><br></pre></td></tr></table></figure>

<p>替换字符串可以插入下面的特殊变量名：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$$</td>
<td>插入一个 “$”。</td>
</tr>
<tr>
<td>$&amp;</td>
<td>插入匹配的结果。</td>
</tr>
<tr>
<td>$`</td>
<td>插入当前匹配的子串左边的内容。</td>
</tr>
<tr>
<td>$’</td>
<td>插入当前匹配的子串右边的内容。</td>
</tr>
<tr>
<td>$n</td>
<td>假如第一个参数是 <code>RegExp</code> ，并且 n 是个小于100的非负整数，则<code>$n</code>意为：插入第 n 个原子组匹配的字符串。提示：索引是从1开始</td>
</tr>
<tr>
<td>$&lt;alia&gt;</td>
<td>与<code>$n</code>类似，也是插入原子组匹配的内容，但<code>$&lt;alia&gt;</code>是通过别名锁定对应原子组</td>
</tr>
</tbody></table>
<p>在”阿顺”前后再分别添加2个<code>=</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let as = &quot;=阿顺=&quot;;</span><br><span class="line">console.log(as.replace(/阿顺/g, &quot;$`$`$&amp;$&#x27;$&#x27;&quot;)); // ===阿顺===</span><br></pre></td></tr></table></figure>

<p>把电话号用 <code>-</code> 连接</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tell = &quot;(010)99999999 (020)8888888&quot;;</span><br><span class="line">console.log(tell.replace(/\((\d&#123;3,4&#125;)\)(\d&#123;7,8&#125;)/g, &quot;$1-$2&quot;));</span><br></pre></td></tr></table></figure>

<p>把所有<code>阿顺</code>关键字加上链接 <code>https://www.Ashuntefannao.com</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const body = document.body;</span><br><span class="line">  body.innerHTML = body.innerHTML.replace(</span><br><span class="line">    /阿顺/g,</span><br><span class="line">    `&lt;a href=&quot;https://www.Ashuntefannao.com&quot;&gt;$&amp;&lt;/a&gt;`</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a><strong>回调函数</strong></h5><p>replace 支持回调函数操作，用于处理复杂的替换逻辑，回调函数参数与<code>str.match\str.matchAll\reg.exec</code>返回的详细参数是对应的。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>代表的值</th>
</tr>
</thead>
<tbody><tr>
<td><code>str</code></td>
<td>匹配的子串。（对应于上述的$&amp;。）</td>
</tr>
<tr>
<td><code>p1,p2, ...</code></td>
<td>假如replace()方法的第一个参数是一个 <code>RegExp</code> ，则代表第n个原子组匹配的字符串。</td>
</tr>
<tr>
<td><code>index</code></td>
<td>匹配到的子字符串在原字符串中的索引。（比如，如果原字符串是 <code>&#39;abcd&#39;</code>，匹配到的子字符串是 <code>&#39;bc&#39;</code>，那么这个参数将会是 1）</td>
</tr>
<tr>
<td><code>source</code></td>
<td>被匹配的原字符串。</td>
</tr>
<tr>
<td>NamedCaptureGroup</td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<p>将关于ashun的链接协议全部置为<code>https</code> ，并补全 <code>www.</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;a style=&quot;color: red&quot; href=&quot;http://www.ashun.com&quot;&gt; 阿顺 &lt;/a&gt;</span><br><span class="line">    &lt;a id=&quot;l1&quot; href=&quot;http://Ashuntefannao.com&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://yahoo.com&quot;&gt;雅虎&lt;/a&gt;</span><br><span class="line">    &lt;h4&gt;http://www.ashun.com&lt;/h4&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#123;</span><br><span class="line">        let reg = /(&lt;a.*?)(http)?(:\/\/)(www\.)?(Ashuntefannao|ashun)/g;</span><br><span class="line">        let body = document.body;</span><br><span class="line">        body.innerHTML = body.innerHTML.replace(reg, (val, ...args) =&gt; &#123;</span><br><span class="line">          args[1] = &quot;https&quot;;</span><br><span class="line">          args[3] = args[3] || &quot;www.&quot;;</span><br><span class="line">          return args.slice(0, 5).join(&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(body.innerHTML.match(reg));</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将标题标签全部替换为 <code>p</code> 标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const reg = /&lt;(h[1-6])&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line">  const body = document.body.innerHTML;</span><br><span class="line">  const html = body.replace(reg, function(str, tag, content) &#123;</span><br><span class="line">    return `&lt;p&gt;$&#123;content&#125;&lt;/p&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">  document.body.innerHTML = html;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>删除页面中的 <code>h1~h6</code> 标签</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const reg = /&lt;(h[1-6])&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line">  const body = document.body.innerHTML;</span><br><span class="line">  const html = body.replace(reg, &quot;&quot;);</span><br><span class="line">  document.body.innerHTML = html;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用回调函数将 <code>阿顺</code> 添加上链接</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼,阿顺讨厌烦恼</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  content.innerHTML = content.innerHTML.replace(&quot;阿顺&quot;, function(</span><br><span class="line">    search,</span><br><span class="line">    index,</span><br><span class="line">    source</span><br><span class="line">  ) &#123;</span><br><span class="line">    return `&lt;a href=&quot;https://www.Ashuntefannao.com&quot;&gt;$&#123;search&#125;&lt;/a&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>为所有标题添加上 <code>hot</code> 类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  	&lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  	&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  let reg = /&lt;(h[1-6])(.*?)&gt;([\s\S]*?)&lt;\/\1&gt;/gi;</span><br><span class="line">  content.innerHTML = content.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    (</span><br><span class="line">      search, //匹配到的字符</span><br><span class="line">      p1, //第一个原子组</span><br><span class="line">      p2, //第二个原子组</span><br><span class="line">      p3, //第三个原子组</span><br><span class="line">      index, //索引位置</span><br><span class="line">      source //原字符</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      return `</span><br><span class="line">    &lt;$&#123;p1&#125;$&#123;p2&#125; class=&quot;hot&quot;&gt;$&#123;p3&#125;&lt;/$&#123;p1&#125;&gt;</span><br><span class="line">    `;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h3><p>下面是 <code>RegExp</code> 正则对象提供的操作方法</p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>reg.test(str)</code>用于判断str是否符合匹配条件，返回Boolean</p>
<p>检测输入的邮箱是否合法</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let email = document.querySelector(`[name=&quot;email&quot;]`);</span><br><span class="line">  email.addEventListener(&quot;keyup&quot;, e =&gt; &#123;</span><br><span class="line">    console.log(/^\w+@\w+\.\w+$/.test(e.target.value));</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="exec-1"><a href="#exec-1" class="headerlink" title="exec"></a>exec</h4><p>配合 <code>g</code> 模式使用时，<code>reg.exec(str)</code>可以循环调用直到全部匹配完。</p>
<ul>
<li>配合 <code>g</code> 模式使用时，应一直操作同一个正则，即把正则定义为变量使用，这样才能够不断的向后匹配</li>
<li>使用 <code>g</code> 修饰符最后匹配不到时返回 <code>null</code></li>
</ul>
<p>计算内容中阿顺出现的次数</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼	--阿顺</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  let reg = /(?&lt;tag&gt;阿顺)/g;</span><br><span class="line">  let num = 0;</span><br><span class="line">  while ((result = reg.exec(content.innerHTML))) &#123;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`阿顺共出现$&#123;num&#125;次`);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="断言匹配"><a href="#断言匹配" class="headerlink" title="断言匹配"></a>断言匹配</h3><p>断言虽然写在扩号中但<code>它不是组</code>，所以<strong>不会在匹配结果中保存</strong>，可以将断言理解为<code>正则中的条件</code>。</p>
<table>
<thead>
<tr>
<th>断言匹配语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>(?=exp)</td>
<td>将其放置于匹配内容的后面，用于约束后面的匹配内容</td>
</tr>
</tbody></table>
<h4 id="exp"><a href="#exp" class="headerlink" title="(?=exp)"></a>(?=exp)</h4><p><strong>零宽先行断言</strong> <code>(?=exp)</code> 匹配后面为 <code>exp</code> 的内容</p>
<p>把后面内容为<code>特烦恼</code> 的<code>阿顺</code>加上链接.</p>
<ul>
<li>断言匹配的结果不会返回到内容当中，以下replace接收到的第一个参数只有<code>阿顺</code></li>
<li>断言匹配，只是一个约束条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼。</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main &#x3D; document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg &#x3D; &#x2F;阿顺(?&#x3D;特烦恼)&#x2F;gi;</span><br><span class="line">  main.innerHTML &#x3D; main.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    v &#x3D;&gt; &#96;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;Ashuntefannao.com&quot;&gt;$&#123;v&#125;&lt;&#x2F;a&gt;&#96;</span><br><span class="line">  );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是将价格后面 添加上 <code>.00</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let lessons = `</span><br><span class="line">    js,200元,300次</span><br><span class="line">    php,300.00元,100次</span><br><span class="line">    node.js,180元,260次</span><br><span class="line">  `;</span><br><span class="line">  let reg = /(\d+)(.00)?(?=元)/gi;</span><br><span class="line">  lessons = lessons.replace(reg, (v, ...args) =&gt; &#123;</span><br><span class="line">    args[1] = args[1] || &quot;.00&quot;;</span><br><span class="line">    return args.splice(0, 2).join(&quot;&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用断言验证用户名必须为五位，下面正则体现断言是不是组，并且不在匹配结果中记录</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document</span><br><span class="line">    .querySelector(`[name=&quot;username&quot;]`)</span><br><span class="line">    .addEventListener(&quot;keyup&quot;, function() &#123;</span><br><span class="line">      let reg = /^(?=[a-z]&#123;5&#125;$)/i;</span><br><span class="line">      console.log(reg.exec(this.value));</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="lt-exp"><a href="#lt-exp" class="headerlink" title="(?&lt;=exp)"></a>(?&lt;=exp)</h4><p><strong>零宽后行断言</strong> <code>?&lt;=exp</code> 匹配前面为 <code>exp</code> 的内容</p>
<p>匹配前面是<code>Ashuntefannao</code> 的数字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao789Ashun666&quot;;</span><br><span class="line">let reg = /(?&lt;=Ashuntefannao)\d+/i;</span><br><span class="line">console.log(str.match(reg)); //789</span><br></pre></td></tr></table></figure>

<p>匹配前后都是数字的内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let str = &quot;Ashuntefannao789Ashun123&quot;;</span><br><span class="line">        let reg = /(?&lt;=\d)[a-z]+(?=\d)/gi;</span><br><span class="line">        // let reg = /(?&lt;=\d&#123;3&#125;).+(?=\d&#123;3&#125;)/g;</span><br><span class="line">        console.log(str.match(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有a标签的超链接替换为<code>Ashuntefannao.com</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;a href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://yahoo.com&quot;&gt;雅虎&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const body = document.body;</span><br><span class="line">  let reg = /(?&lt;=&lt;a.*href=([&#x27;&quot;])).+?(?=\1)/gi;</span><br><span class="line">  // console.log(body.innerHTML.match(reg));</span><br><span class="line">  body.innerHTML = body.innerHTML.replace(reg, &quot;https://Ashuntefannao.com&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>把前面内容为<code>阿顺</code> 的<code>特烦恼</code>加上链接.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼。</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg = /(?&lt;=阿顺)特烦恼/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    v =&gt; `&lt;a href=&quot;https://Ashuntefannao.com&quot;&gt;$&#123;v&#125;&lt;/a&gt;`</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将电话的后四位模糊处理</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let users = `</span><br><span class="line">  阿顺电话: 12345678901</span><br><span class="line">  客服电话: 98745675603</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /(?&lt;=\d&#123;7&#125;)\d+\s*/g;</span><br><span class="line">users = users.replace(reg, str =&gt; &#123;</span><br><span class="line">  return &quot;*&quot;.repeat(4);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(users); //阿顺电话: 1234567**** 客服电话: 9874567****</span><br></pre></td></tr></table></figure>

<p>获取标题中的内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let th = `&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;`;</span><br><span class="line">let reg = /(?&lt;=&lt;h1.*?&gt;).*(?=&lt;\/h1&gt;)/g;</span><br><span class="line">console.log(th.match(reg));</span><br></pre></td></tr></table></figure>



<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="(?!exp)"></a>(?!exp)</h4><p><strong>零宽负向先行断言</strong> 后面<font color="#16a085">不能出现</font> <code>exp</code> 指定的内容</p>
<p>使用 <code>(?!exp)</code>字母后面不能为两位数字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashun12&quot;;</span><br><span class="line">let reg = /[a-z]+(?!\d&#123;2&#125;)$/i;</span><br><span class="line">console.table(reg.exec(str));</span><br></pre></td></tr></table></figure>

<p>下例为用户名中不能出现<code>阿顺</code></p>
<ul>
<li>下例中，<code>(?!exp)</code>前面什么也没有，即<code>&quot;&quot;</code>后面不准出现阿顺，也就是任意一个地方后面不能出现阿顺</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const input = document.querySelector(`[name=&quot;username&quot;]`);</span><br><span class="line">  input.addEventListener(&quot;keyup&quot;, function() &#123;</span><br><span class="line">    const reg = /^(?!.*阿顺)[(\w)(\p&#123;sc=Han&#125;)]&#123;5,6&#125;$/iu;</span><br><span class="line">    console.log(this.value.match(reg));</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="lt-exp-1"><a href="#lt-exp-1" class="headerlink" title="(?&lt;!exp)"></a>(?&lt;!exp)</h4><p><strong>零宽负向后行断言</strong> 前面<font color="#16a085">不能出现</font>exp指定的内容</p>
<p>获取前面不是数字的字符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Ashun99shun&quot;;</span><br><span class="line">let reg = /(?&lt;!\d)[a-z]+/i;</span><br><span class="line">console.log(reg.exec(str)); //Ashun</span><br></pre></td></tr></table></figure>

<p>把所有不是以 <code>https://oss.Ashuntfn.com</code> 开始的静态资源替换为新网址</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.Ashuntfn.com/1.jpg&quot;&gt;1.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://oss.Ashuntfn.com/2.jpg&quot;&gt;2.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://cdn.Ashuntfn.com/2.jpg&quot;&gt;3.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://Ashuntfn.com/2.jpg&quot;&gt;3.jpg&lt;/a&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  let reg = /https:\/\/(?&lt;!oss\.).+?(?=\/)/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(reg, v =&gt; &#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">    return &quot;https://oss.Ashuntfn.com&quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="阿顺特烦恼"
      src="/images/headPortrait.jpg">
  <p class="site-author-name" itemprop="name">阿顺特烦恼</p>
  <div class="site-description" itemprop="description">阿顺特烦恼,希望大家没有烦恼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/astfn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;astfn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/ashuntefannao" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;ashuntefannao" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Gitee</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fab fa-adn"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿顺特烦恼</span>
</div>
  <div class="powered-by">
     <!-- 外部引入 访客计数器-->
      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span><br/>
      
      <strong style="color:#ccc">ASHUNTEFANNAO</strong><br/>
      <span style="color:#ccc;font-size:13px">博客文章版权归作者 阿顺特烦恼 所有</span><br/>
      <span style="color:#ccc;font-size:13px">欢迎转载 但未经作者同意 必须保留此段声明</span><br/>
  </div>
  
  <!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  -->



<!-- 外部脚本 -->

<!--以下部分脚本依赖jquery-->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<!--浏览器搞笑标题 //实测会影响图标-->
	<!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js"></script>-->

	<!-- 🌸飘落 -->
		<!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js"></script>-->

	<!-- 雪花飘落 -->
	  <!-- <script async src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js"></script> -->

	<!-- // 文字 -->
    <!--<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js"></script>-->

<!-- // 烟花 -->
	<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
	<script async type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
	<script async src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/fireworks.js"></script>

<!-- // 星星跟随坠落 -->
	<script async src="https://cdn.jsdelivr.net/gh/cungudafa/cdn@2.1.2/js/cursor.js"></script>

<!-- // 连线 -->
	<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>
	<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

<!-- 样式二（飘动的彩带） -->
	<script async src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js" type="text/javascript"></script>

<!--背景切换-->
  <!--<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>-->



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
