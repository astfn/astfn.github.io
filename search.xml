<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test admin</title>
    <url>/2021/04/25/testDir/test-admin/</url>
    <content><![CDATA[<h1 id="test-Admin"><a href="#test-Admin" class="headerlink" title="test Admin"></a>test Admin</h1><p>use Admin create markdown 😀</p>
]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2021/05/04/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%94%9F%E6%B4%BB/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[ <style>
      span.ashun {
        color: #d35400;
        font-weight: bold;
      }
      .active {
        display: inline-block;
        animation: active 0.8s 2 linear;
        letter-spacing: 0.4rem;
      }
      @keyframes active {
        25% {
          color: #ecf0f1;
          transform: scale(1.2);
        }
        40% {
          color: #9b59b6;
          transform: scale(1.5);
        }
        50% {
          color: #546de5;
          transform: scale(2);
        }
        60% {
          color: #e67e22;
          transform: scale(1.5);
        }
        80% {
          color: pink;
          transform: scale(1.2);
        }
      }
       strong.Ashun{
     font-size:20px;
     display:block;
     text-align:center;
       }
    </style><body>




<p>   <strong class="Ashun">无论我怎样改变，都是那个少年</strong></p>
<script>let div = document.querySelector("strong.Ashun");let text = div.innerText;[...text].reduce((pre, val) => {pre == 0 && (div.innerHTML = "");let span = document.createElement("span");span.classList.add("ashun");span.innerText = val;div.append(span);span.addEventListener("mouseenter", (e) => {e.target.classList.add("active");});span.addEventListener("animationend", (e) => {e.target.classList.remove("active");});}, 0);</script></body>

<iframe src="//player.bilibili.com/player.html?aid=672756810&bvid=BV1CU4y1b7Sx&cid=332877650&page=1&danmaku=0" scrolling="no" style="border-radius:15px;" frameborder="no" framespacing="0" allowfullscreen="false"> </iframe>

]]></content>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/BFC/BFC/</url>
    <content><![CDATA[<img src="BFC.assets/首图.png" alt="首图"/>

<p>记住首图，后面要考(带你理解BFC)🐾</p>
<h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><p>BFC 全称为<code>block formating context</code>（块级格式化上下文），它有什么作用呢？</p>
<p>​    若一个元素触发了BFC，则这个元素就可以被视为一个与外界隔离的独立容器，在该容器内的布局规则不会影响到外部的布局。</p>
<p>什么？不好理解？我形象的给大家比喻一下：</p>
<p>​    在孩童时代，调皮的小孩子都会给桌子刻下一条<strong>三八线</strong>，用于和可爱的同桌井水不犯河水 😄，这条三八线将桌子一分为二，左边是我的，右边是你的，而且我的地盘东西想怎么摆就怎么摆，我也不会影响到你的地盘。BFC元素和这种情况是一模一样的，桌子的左右部分都可视为一个BFC。</p>
<h2 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h2><p>上文我们讲明了什么是BFC，那要怎么触发呢？下面我将方法列举出来：</p>
<ol>
<li>根元素 （html）</li>
<li>设置浮动 （<code>float</code>不为<code>none</code>默认值）</li>
<li>溢出处理 （<code>overflow</code>不为<code>visible</code>默认值）</li>
<li>确切定位 （<code>position</code>不为<code>static</code>默认值、<code>relative</code>、<code>sticky</code>）</li>
<li>陈列方式 （<code>display</code>设为 <code>inline-block</code>、<code>inline-flex</code>、<code>inline-grid</code>、<code>table</code>）</li>
</ol>
<h2 id="BFC有何作用"><a href="#BFC有何作用" class="headerlink" title="BFC有何作用"></a>BFC有何作用</h2><p>上文讲明BFC是什么，也阐述了触发条件，那BFC到底有什么作用呢？我们为什么要使用它？</p>
<p>BFC可以解决一些实际布局上的问题，这也是它的特点（自身为单独隔离的元素，自身内部布局不会影响外界），下面介绍BFC能解决的一些问题。</p>
<h3 id="浮动重叠"><a href="#浮动重叠" class="headerlink" title="浮动重叠"></a>浮动重叠</h3><p>如果一个浮动元素后面跟着一个非浮动的元素，那么浮动元素就会覆盖非浮动元素，可以利用这个特性来做自适应的两栏布局，但在一般网页中，我们可能不希望出现这种情况，这时就可以通过触发BFC解决。</p>
<p><strong>让非浮动元素触发BFC</strong>，从而不影响外部的布局。</p>
<p>示例:</p>
<p>未触发BFC：</p>
<img src="BFC.assets/浮动重叠1.png" alt="浮动重叠1" style="zoom:80%;" />

<p>触发BFC后：</p>
<img src="BFC.assets/浮动重叠2.png" alt="浮动重叠2" style="zoom:80%;" />

<ul>
<li>默认情况下，浮动元素会覆盖非浮动元素如图一</li>
<li>给非浮动元素触发BFC，解决问题，如图二</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#34495e</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .first &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .second &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#2980b9</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/* float: left; */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span>非浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="多个子元素浮动影响父元素高度"><a href="#多个子元素浮动影响父元素高度" class="headerlink" title="多个子元素浮动影响父元素高度"></a>多个子元素浮动影响父元素高度</h3><p>若存在多个浮动的子元素，则父元素高度将不会将浮动的子元素计算进去。这时也可以通过触发BFC解决。</p>
<p><strong>让父级元素触发BFC</strong></p>
<p>示例:</p>
<p>未触发BFC：</p>
<img src="BFC.assets/浮动影响父级高度1.png" alt="浮动影响父级高度1" style="zoom:80%;" />

<p>触发BFC后：</p>
<img src="BFC.assets/浮动影响父级高度2.png" alt="浮动影响父级高度2" style="zoom:80%;" />

<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-tag">main</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/* display: inline-block; */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* position: absolute; */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* overflow: auto; */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  .first &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .second &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#2980b9</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span>: left;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>​    <code>外边距塌陷</code>也称为<code>外边距合并</code>，这种现象是指：在正常文档流中两个相邻（兄弟或父子关系）的块级元素的外边距，组合在一起变成单个外边距。</p>
<p>​    <strong>值得注意的是</strong>：只有上下外边距才会有塌陷，左右外边距不会出现这种问题。</p>
<h4 id="父子塌陷"><a href="#父子塌陷" class="headerlink" title="父子塌陷"></a>父子塌陷</h4><p>下面通过示例讲解：</p>
<p>未触发BFC：</p>
<img src="BFC.assets/父子塌陷1.png" alt="父子塌陷1" style="zoom:80%;" />

<p>触发BFC后：<strong>让父级元素触发BFC解决</strong></p>
<img src="BFC.assets/父子塌陷2.png" alt="父子塌陷2." style="zoom:80%;"/>

<ul>
<li>子级元素(红色box)与父级元素(黑色box)相邻，会发生外边距塌陷，当为红色box设置<code>margin-top</code>时，我们预想的是红色box相对于父级元素产生顶部边距，但事实并非这样，实际上会将二者的外边距合二为一，出现图一的效果。</li>
<li>若要解决这个问题，只需要为将父级元素(黑色box)设置为BFC即可，这样内部的布局将不会影响外部，达到图二预想的效果</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .max &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css">    <span class="comment">/* display: inline-block; */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .first &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .second &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#2980b9</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;max&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="兄弟塌陷"><a href="#兄弟塌陷" class="headerlink" title="兄弟塌陷"></a>兄弟塌陷</h4><p>下面通过示例讲解：</p>
<p>未触发BFC：</p>
<img src="BFC.assets/兄弟塌陷1.png" alt="兄弟塌陷1" style="zoom:80%;" />

<p>触发BFC后：</p>
<img src="BFC.assets/兄弟塌陷2.png" alt="兄弟塌陷2." style="zoom:80%;"/>

<ul>
<li>同级元素(红色box)与(蓝色box)相邻，会发生外边距塌陷，当为 红色box设置<code>margin-bottom</code>、蓝色box设置<code>margin-top</code>时，我们预想的是外边距为二者之合，但事实并非这样，实际上会将二者的外边距合二为一，出现图一的效果。</li>
<li>若要解决这个问题，只需要将其中之一设置为BFC即可，这样内部的布局将不会影响外部，达到图二预想的效果</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#34495e</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-tag">main</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .first &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .second &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#2980b9</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* display: inline-block; */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* position: absolute; */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* overflow: auto; */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFC 全称为<code>block formating context</code>（块级格式化上下文），若一个元素触发了BFC，则这个元素就可以被视为一个与外界隔离的独立容器，在该容器内的布局规则不会影响到外部的布局。</p>
<p>触发BFC的条件：</p>
<ol>
<li>  根元素 （html）</li>
<li>（<code>float</code>不为<code>none</code>默认值）</li>
<li>（<code>overflow</code>不为<code>visible</code>默认值）</li>
<li>（<code>position</code>不为<code>static</code>默认值、<code>relative</code>、<code>sticky</code>）</li>
<li>（<code>display</code>设为 <code>inline-block</code>、<code>inline-flex</code>、<code>inline-grid</code>、<code>table</code>）</li>
</ol>
<p>BFC解决的问题：</p>
<ol>
<li>非浮动元素紧跟浮动元素导致重叠<ul>
<li>非浮动元素触发BFC解决</li>
</ul>
</li>
<li>多个子元素浮动，影响父元素高度<ul>
<li>父级元素触发BFC解决</li>
</ul>
</li>
<li>上下外边距塌陷<ol>
<li>父子元素塌陷<ul>
<li>让父级元素触发BFC解决</li>
</ul>
</li>
<li>兄弟元素塌陷<ul>
<li>其一触发BFC</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>SEO</title>
    <url>/2021/05/05/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/SEO/SEO/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>SEO</code>(Search Engine Optimization),即搜索引擎优化。SEO是随着<code>搜索引擎</code>的出现而来的。搜索引擎会根据网站的一些<code>特点</code>进行收录，从而提高网站在搜索引擎中的排名。</p>
<p>既然搜索引擎要收录网站的<code>特点</code>，就需要对网站的信息进行抓取，搜索引擎会使用<code>Spider(蜘蛛)</code>完成这个工作，那么我们要做的就是：<strong>尽量让Spider识别网站的特点</strong>，从而正确收录，提高网站排名。</p>
<p><code>SEO</code>手段分为两大类：黑帽、白帽SEO，本文主要讲解<code>白帽SEO</code>。</p>
<blockquote>
<p>黑帽：就是采用搜索引擎禁止的方式优化网站，影响搜索引擎对网站排名的合理和公正性。</p>
</blockquote>
<h2 id="白帽SEO"><a href="#白帽SEO" class="headerlink" title="白帽SEO"></a>白帽SEO</h2><p>白帽SEO，主要是通过前端的一些合理操作，从而让<code>Spider</code>能够高效收录信息，其主要手段有👇：</p>
<h3 id="突出重要内容"><a href="#突出重要内容" class="headerlink" title="突出重要内容"></a>突出重要内容</h3><p>对网站的<code>title</code>、<code>keywords</code>、<code>description</code>等信息的合理设置。</p>
<h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p><code>    title</code>即网站标题，是SEO及其重要的一员，用户在浏览器进行搜索时，首先展示的就是网站的<code>title</code>。对于title的设置，我们要做到：</p>
<ul>
<li>贴切站内容</li>
<li>简明扼要</li>
</ul>
<p>代码配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;AshunBlog&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>

<h4 id="decription"><a href="#decription" class="headerlink" title="decription"></a>decription</h4><p>用户在浏览器进行搜索时，首先展示的是网站的<code>title</code>，其次为<code>description</code>，是对该页面的描述信息。值得注意的是：</p>
<ul>
<li>每个页面所设置的描述不要重复。</li>
<li>description 的值要尽可能表述清楚页面的内容</li>
<li>内容不要太长</li>
</ul>
<p>代码配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;这是Ashun的博客网站，用于记录自己的学习过程，同时将其进行分享，欢迎大家共同学习、交流、进步！&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h4><p><code>keywords</code>主要为搜索引擎提供当前页面的关键词信息，<code>keywords</code>可以设置多个，多个关键词之间用<code>,</code>间隔。建议不要设置太多，不利于<code>Spider</code>的收录。</p>
<p>代码配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;Ashun,阿顺,Blog,博客网站&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="h1标签"><a href="#h1标签" class="headerlink" title="h1标签"></a>h1标签</h4><p>​    从h1标签的默认样式(字体大小、加粗)，可得知其是非常醒目、重要的，同样地，搜索引擎的<code>Spider</code>也会认为其非常重要，会将其收录为网站重要信息的一部分，因此我们要合理的使用h1标签。</p>
<ul>
<li>正文的标题要使用h1标签</li>
<li>首页的logo可以添加上h1标签</li>
</ul>
<p>值得注意的是：logo为图片时应该添加上<code>alt</code>和<code>title</code>属性，即使图片未能正常显示时，用户也能看到提示文字，且<code>alt</code>属性是搜索引擎判断图片与文字是否相关的重要依据。</p>
<hr>
<h3 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h3><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>H5的语义化标签，在项目足够大时，越能体现其优势，能够让开发者便捷、高效的认出对应的结构部分，从而提高可维护性。</p>
<p>当然，一些搜索引擎也支持更好地识别语义标签，从而提高信息的收录量。</p>
<h4 id="尽量简单"><a href="#尽量简单" class="headerlink" title="尽量简单"></a>尽量简单</h4><p>网站的层级结构要尽量简单，不要嵌套太多，因为<code>Spider</code>在不断爬取数据时，层级越多，爬取速度越慢，不利于信息的收录。</p>
<hr>
<h3 id="加载速度优化"><a href="#加载速度优化" class="headerlink" title="加载速度优化"></a>加载速度优化</h3><p>​    一个网站的加载速度越快，也会更加利于搜索引擎抓取数据进行收录，因此我们尽量对加载的速度进行优化。</p>
<ol>
<li>lazyLoad</li>
<li>可以对频繁触发请求的时间，做防抖处理</li>
<li>精灵图的应用</li>
<li>合理应用浏览器缓存</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/04/22/%E5%85%B3%E4%BA%8E%E6%88%91/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Ashuntefannao"><a href="#Ashuntefannao" class="headerlink" title="Ashuntefannao"></a>Ashuntefannao</h1><blockquote>
<p>这是我的第一个博客项目,时间原因，后续持续更新……</p>
</blockquote>
<iframe src="//player.bilibili.com/player.html?aid=50256015&bvid=BV1jb411G7Ks&cid=88079872&page=1&danmaku=0" scrolling="no" style="border-radius:15px;" frameborder="no" framespacing="0" allowfullscreen="false"> </iframe>

<p>test</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&quot;Ashuntefannao&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="string">&quot;Const&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">args=&#123;name,age&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.arguments=args</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.arguments.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is a test String&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>第一篇博客</tag>
      </tags>
  </entry>
  <entry>
    <title>盒模型</title>
    <url>/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%9B%92%E6%A8%A1%E5%9E%8B/%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="盒模子型"><a href="#盒模子型" class="headerlink" title="盒模子型"></a>盒模子型</h1><p>​    在写这篇文章之前，我也阅读了其他文章，但我有个习惯：总想自己测试一遍，并记下笔记，从而更好的理解。也就是在这个过程中，我发现网上大部分博客阐述内容有一些问题，与实际测试并不相复合，下面我将详解这个过程。</p>
<h2 id="什么是盒子模型？"><a href="#什么是盒子模型？" class="headerlink" title="什么是盒子模型？"></a>什么是盒子模型？</h2><p>​    展示在页面上的每一个元素都可以视为一个盒模型，且本质上都是一个矩形盒子，盒模型总共分为两种，分别为：<code>W3C标准盒模型</code>、<code>IE盒模型</code>。</p>
<p>​    之所以分为两类，是因为二者在性质上有些不同，具体来说是在<strong>计算宽高时</strong>的差异。</p>
<p>​    页面中的矩形盒子宽高可以通过<code>width</code>、<code>heitht</code>属性进行配置，但这只是设置了<strong>content</strong>内容部分的宽高，除此之外，盒子宽高还受<code>padding</code>、<code>border</code>两个属性的影响。</p>
<p>​    <code>W3C标准盒模型</code>、<code>IE盒模型</code>两种盒子类型，也就是因为对<code>padding</code>、<code>border</code>两个属性处理的形式不同，从而划分为两类的。</p>
<h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><p><code>W3C标准盒模型</code>在计算盒子宽高时，为<code>width/height</code>、<code>padding</code>、<code>border</code>四个属性相加。</p>
<p>实际也就是 <code>content+padding+border</code>，因为我们通过css设置<code>width/height</code>属性就是用来定义盒子<strong>内容</strong>宽高的。</p>
<p>实际操作：</p>
<img src="盒模型.assets/W3CBox1.png" alt="W3CBox1" style="zoom:77%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">article</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#16a085</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .box &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#f39c12</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: white;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box W3CBox&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>W3CBox<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们通过控制台工具，看看盒子宽高到底是不是上文讲的那样： <code>content+padding+border</code></p>
<img src="盒模型.assets/W3CBox2.png" alt="W3CBox2" style="zoom:77%;" />

<p>现在来分析一下：</p>
<p><img src="/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%9B%92%E6%A8%A1%E5%9E%8B/%E7%9B%92%E6%A8%A1%E5%9E%8B/%E7%9B%92%E6%A8%A1%E5%9E%8B.assets/W3CBox3.png" alt="image-20210613205341103"></p>
<ol>
<li><strong>content：</strong>content= width/height =  100 * 100 (px)</li>
<li><strong>padding：</strong>在content的基础上设置padding为10px<ul>
<li>此时盒子宽度 width+paddingLeft/Right =100 + 20 (px)</li>
<li>此时盒子高度 width+paddingTop/Bottom =100 + 20 (px)</li>
</ul>
</li>
<li><strong>border：</strong>在上面的基础上又对盒子宽高产生了影响<ul>
<li>此时盒子宽度 width+paddingLeft/Right + borderLeft/Right =100 + 20 + 20(px)</li>
<li>此时盒子高度 width+paddingTop/Bottom + borderTop/Bottom =100 + 20 + 20(px)</li>
</ul>
</li>
</ol>
<p>整体计算下来，盒子宽高为 <code>140 *140 (px)</code>，完全符合上述结论。</p>
<p>值得注意的是：网上好多博客文章都将<code>margin</code>算入了盒子的宽高，虽然在视觉上，盒子最外层的确有了间隙，但这只是影响了布局，<strong>并没有影响盒子本身的尺寸</strong>，若盒子尺寸包含了<code>margin</code>，那最后得到的盒子尺寸应为 150 * 150 (px)，但事实并不是这样。</p>
<h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><p><code>IE盒模型</code>在计算盒子宽高时，只包含<code>width/height</code>即内容<strong>content</strong>部分。但值得注意的是，这content包含了<code>padding</code>、<code>border</code>两个属性。</p>
<p>也即是说，盒子最终的宽高，就是我们设置的<code>width/height</code>,若我们又设置了<code>padding</code>、<code>border</code>两个属性，则这两个属性不会对宽高造成影响，而是包含在了设置的<code>width/height</code>中。</p>
<p>实际操作：</p>
<img src="盒模型.assets/IEBox1.png" alt="IEBox1" style="zoom:80%;" />

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.IEBox</span> &#123; <span class="attribute">box-sizing</span>: border-box; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box IEBox&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>IEBox<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以发现，其他配置相同，只是改变了盒子模型，但尺寸却差了好多，我们通过控制台工具，看看盒子宽高到底为多少？</p>
<img src="盒模型.assets/IEBox2.png" alt="IEBox2" style="zoom:80%;" />

<p><img src="/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%9B%92%E6%A8%A1%E5%9E%8B/%E7%9B%92%E6%A8%A1%E5%9E%8B/%E7%9B%92%E6%A8%A1%E5%9E%8B.assets/IEBox3.png" alt="image-20210613205445687"></p>
<p>通过结果来看，完全符合上述结论，盒子的尺寸只包含<strong>content</strong>部分，也就是我们定义的 <code>width/height</code>属性。之后定义的<code>padding</code>、<code>border</code>都会被包含到<strong>content</strong>中。</p>
<h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>上面两个例子已经让我们清晰的发现两种盒模型的差异，那我们怎么切换两种盒子模型呢，其实上文已经使用过了，也就是<code>box-sizing</code>属性。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-sizing: content-box|border-box|inherit;</span><br></pre></td></tr></table></figure>

<ul>
<li>content-box<ul>
<li>默认值，设置为W3C标准盒模型</li>
</ul>
</li>
<li>border-box<ul>
<li>设置为IE盒模型</li>
</ul>
</li>
<li>inherit<ul>
<li>继承父级盒子类型</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>W3C标准盒模型</code>在计算盒子宽高时，为<code>width/height</code>、<code>padding</code>、<code>border</code>四个属性相加。</li>
<li><code>IE盒模型</code>在计算盒子宽高时，只包含<code>width/height</code>即内容<strong>content</strong>部分，且content包含了<code>padding</code>、<code>border</code>。</li>
<li><code>margin</code> 并不会影响盒子的尺寸，该属性影响的是布局。</li>
<li>可通过<code>box-sizing</code>改变盒子类型。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>盒子模型虽然非常基础，但也包含一些细节，导致我们认知模糊，这篇文章希望能帮到读者。</p>
<p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>圣杯双飞翼布局</title>
    <url>/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>​    在详细介绍<code>圣杯</code>、<code>双飞翼</code>布局前，我们先要了解两种布局方式具体要实现什么效果：</p>
<ul>
<li>三列布局：left、center、right</li>
<li>left、right 宽度固定</li>
<li>center 宽度自适应窗口大小</li>
</ul>
<p><code>圣杯</code>、<code>双飞翼</code>布局就是用来实现上述效果的，但其对应的实现形式却不相同，因此被划分为两类。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局实现效果的主要思路为：</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>将left、center、right 统一放在一个box中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center float&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left float&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right float&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ol>
<li>center 宽度设为 <code>100%</code>，并设置 <code>paddingLeft</code>、<code>paddingRight</code>，为两侧预留位置</li>
<li>left、center、right 都要设置浮动 <code>float:left</code></li>
<li>设置 left 位置<ul>
<li>设置 <code>margin-left: -100%</code> 相对于父级宽度距离移动，从而移动到center的起始位置</li>
<li>再设置 <code>position: relative; left: -selfWidth </code>相对于自身向左移动自身宽度距离，达到最左侧</li>
</ul>
</li>
<li>设置 right 位置 <ol>
<li>方法1<ul>
<li>设置<code>margin-left: -selfWidth</code>，移动到center末尾处</li>
<li>再设置 <code>position: relative; left: selfWidth </code>相对于自身向右移动自身宽度距离，达到最右侧</li>
</ul>
</li>
<li>方法二<ul>
<li>直接设置<code>margin-right: -selfWidth</code>，相对于右侧向左移动自身宽度，即可达到正确位置。</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#636e72</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#d63031</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00b894</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">150px</span>;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  margin-left: -150px;</span></span><br><span class="line"><span class="comment">  position: relative;</span></span><br><span class="line"><span class="comment">  left: 150px;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdcb6e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局实现效果的主要思路为：</p>
<h3 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h3><p>将center单独使用一个盒子包裹起来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;float&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left float&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right float&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><ol>
<li>设置 center 的父级盒子main：宽度设为 <code>100%</code></li>
<li>设置 center 的 <code>marginLeft</code>、 <code>marginRight</code>为两侧预留位置</li>
<li>left、main、right 都要设置浮动 <code>float:left</code></li>
<li>设置 left 位置<ul>
<li>设置 <code>margin-left: -100%</code>相对于父级宽度距离移动，从而移动到最左侧</li>
</ul>
</li>
<li>设置 right 位置 <ul>
<li>设置<code>margin-left: -selfWidth</code>，相对于左侧向左移动自身宽度，即可达到正确位置。</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#636e72</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#d63031</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00b894</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdcb6e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.assets/%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.gif" alt="圣杯双飞翼布局"></p>
<h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><p>圣杯布局实现关键：</p>
<p><strong>HTML</strong>：main 包裹 left、center、right</p>
<p><strong>CSS</strong>：</p>
<ul>
<li>main: paddingLeft、paddingRight</li>
<li>left、center、right三者浮动</li>
<li>left: marginLeft、relative、left</li>
<li>right: marginRight</li>
</ul>
<p>优点： HTML结构更加清晰，但css代码较多一点</p>
<p>双飞翼布局实现关键：</p>
<p><strong>HTML</strong>：main 包裹 left、center、right</p>
<p><strong>CSS</strong>：</p>
<ul>
<li>main设置 width:100%</li>
<li>left、center、right三者浮动</li>
<li>center 设置左右margin</li>
<li>left不用定位移动，直接margin-left:-100%</li>
<li>right设置margin-left，不同于圣杯的margin-right</li>
</ul>
<p>优点：css代码较少，但 HTML结构不如圣杯布局清晰。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有的小伙伴就要问了，这种布局的形式我是用其他形式也能够实现，上述圣杯、双飞翼布局到底有什么优势呢？</p>
<p><strong>杯布局与双飞翼布局的优点：利用布局，可优先渲染主要部分</strong></p>
<p>​    细心的同学可能已经发现了，这两种布局形式都将 <strong>center</strong>也就是主要内容部分放在了当前结构的最开始位置。这样的好处就是能够优先加载<strong>center</strong>部分，如果遇到网络不佳情况也能够优先加载主要内容。</p>
<p>​    如果使用其他形式，比如flex，展示顺序和html结构是相关的，就做不到优先展示<strong>center</strong>部分。</p>
<p>但我们可以使用<code>grid</code>布局实现，下面贴出代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">header</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-tag">footer</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#95a5a6</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">main</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">    grid-template-rows: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .center &#123;</span><br><span class="line"><span class="css">    grid-column: <span class="number">2</span>/<span class="number">3</span>;</span></span><br><span class="line">    /* </span><br><span class="line"><span class="css">    grid-column-start: <span class="number">2</span>;</span></span><br><span class="line"><span class="css">    grid-column-end: <span class="number">3</span>; </span></span><br><span class="line">    */</span><br><span class="line"><span class="css">    grid-row: <span class="number">1</span>/<span class="number">2</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#e74c3c</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line"><span class="css">    grid-column: <span class="number">1</span>/<span class="number">2</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#1abc9c</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line"><span class="css">    grid-column: <span class="number">3</span>/<span class="number">4</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>封装类express服务</title>
    <url>/2021/04/25/%E5%90%8E%E7%AB%AF%E8%AF%AD%E8%A8%80/Nodejs/%E5%8E%9F%E7%94%9Fnode/%E5%B0%81%E8%A3%85%E7%B1%BBexpress%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>之前我们完成了以下功能，并做了抽离</p>
<ul>
<li>响应各种类型的文件</li>
<li>路由业务的扩展</li>
<li>404处理</li>
</ul>
<p>但是缺点还是很多的，比如</p>
<ul>
<li>没有对不同的请求类型进行分类处理</li>
<li>业务逻辑不够清晰</li>
<li>代码冗余</li>
</ul>
<p>我们可以基于之前的功能，封装一个类express的服务，这样管理起来就比较方便，并且按不同的请求类型进行了分类。</p>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>既然要封装类express服务，就要先了解express的基本使用方法。</p>
<p>路由处理<font size="2">（在真正使用express时，下面的app为express实例）</font>：</p>
<ul>
<li><code>app.get(&quot;path&quot;,(req,res)=&gt;&#123;……&#125;)</code></li>
<li><code>app.post(&quot;path&quot;,(req,res)=&gt;&#123;……&#125;)</code></li>
<li>其他请求处理在此省略</li>
</ul>
<p>扩展API：</p>
<ul>
<li><code>req.body</code>获取post请求传参</li>
<li><code>res.send(data)</code>向Browser响应信息<ul>
<li>下文讲述的封装，将此API压入app内</li>
</ul>
</li>
</ul>
<h2 id="封装版本1"><a href="#封装版本1" class="headerlink" title="封装版本1"></a>封装版本1</h2><p>​    外部使用<code>app.get/post</code>时，会传入对应的处理函数，我们会根据 <code>请求类型、pathName</code> 压入到内置<code>Global</code>变量的对应属性中，在接收请求时，再根据 <code>请求类型、pathName</code> 找到并执行对应的处理函数即可。</p>
<ul>
<li><p>当请求类型为<code>POST</code>时，涉及到参数的接收，以及API的配置。</p>
</li>
<li><p>向app添加静态方法<code>get/post</code>，供外部使用。</p>
</li>
<li><p>我们将封装的功能抽离到外部<code>./modules/expressServe.js</code></p>
</li>
</ul>
<p>以下为<code>./modules/expressServe.js</code>代码👇</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&quot;public&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> defaultMimePath = <span class="string">`./modules/mime.json`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileType</span>(<span class="params">pathName, mimePath = defaultMimePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mime = <span class="built_in">JSON</span>.parse(_fs.readFileSync(mimePath));</span><br><span class="line">  <span class="keyword">let</span> extName = _path.extname(pathName);</span><br><span class="line">  <span class="keyword">return</span> mime[extName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultServe</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reqUrl = req.url == <span class="string">&quot;/&quot;</span> ? <span class="string">&quot;/index.html&quot;</span> : req.url;</span><br><span class="line">  <span class="keyword">let</span> pathName = _url.parse(reqUrl).pathname;</span><br><span class="line">  <span class="keyword">let</span> fileType = getFileType(pathName);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reqUrl != <span class="string">&quot;/favicon.ico&quot;</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`<span class="subst">$&#123;fileType&#125;</span>;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">      <span class="keyword">let</span> data = _fs.readFileSync(staticPath + pathName);</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expressServe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> G = &#123; <span class="attr">_get</span>: &#123;&#125;, <span class="attr">_post</span>: &#123;&#125;, staticPath &#125;;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    defaultServe(req, res);					<span class="comment">//创建默认服务读取文件信息。</span></span><br><span class="line">    <span class="keyword">let</span> pathName = _url.parse(req.url).pathname;</span><br><span class="line">    <span class="keyword">let</span> reqMethod = req.method.toLowerCase();</span><br><span class="line">		<span class="comment">//类express服务处理</span></span><br><span class="line">    <span class="keyword">if</span> (G[<span class="string">`_<span class="subst">$&#123;reqMethod&#125;</span>`</span>][pathName]) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((reqMethod = <span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">        G[<span class="string">`_get`</span>][pathName](req, res);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((reqMethod = <span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> postData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        req.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">          postData += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          req.body = postData;</span><br><span class="line">          G[<span class="string">`_post`</span>][pathName](req, res);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">      res.write(<span class="string">`&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;/head&gt;`</span>);</span><br><span class="line">      res.end(<span class="string">&quot;没有找到该资源!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//API</span></span><br><span class="line">  app.get = <span class="function">(<span class="params">pathName, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    G[<span class="string">&quot;_get&quot;</span>][pathName] = callback;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.post = <span class="function">(<span class="params">pathName, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    G[<span class="string">&quot;_post&quot;</span>][pathName] = callback;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.send = <span class="function">(<span class="params">req, res, content</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">    res.write(<span class="string">`&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;/head&gt;`</span>);</span><br><span class="line">    res.end(content);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = expressServe();</span><br></pre></td></tr></table></figure>

<p>入口文件使用：👇</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&quot;public&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> _ejs = <span class="built_in">require</span>(<span class="string">&quot;ejs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&quot;./modules/createDefaultServer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8086</span>;</span><br><span class="line">_http.createServer(app).listen(port); <span class="comment">//异步执行，下面的请求已经被压入到封装方法的G中</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> Params = &#123;</span><br><span class="line">    content: <span class="string">&quot;Ashuntefannao&quot;</span>,</span><br><span class="line">    list: [<span class="string">&quot;login&quot;</span>, <span class="string">&quot;testEjs&quot;</span>, <span class="string">&quot;Ashun&quot;</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  _ejs.renderFile(<span class="string">&quot;./views/login.ejs&quot;</span>, Params, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&#x27;utf-8&#x27;`</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/main.html&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;/main.html send POST Request&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<h2 id="封装版本2"><a href="#封装版本2" class="headerlink" title="封装版本2"></a>封装版本2</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上述封装的<code>express基本服务版本1</code>，其实有一些问题，细心的同学可能会留意到。</p>
<p>问题概述：</p>
<p><code>版本1</code>会导致一些文件不能读取成功，具体原因是什么？我们走一遍对应的逻辑即可</p>
<ul>
<li>首先执行<code>defaultServe</code>创建最基本的服务，读取文件信息，如果文件读取不成功并不会立即抛出错误，而是选择交由外部处理，这样才能进行路由业务的扩张</li>
<li>然后执行<code>express服务</code>的逻辑</li>
</ul>
<p>表面上好像没什么问题，其实不然，问题产生的关键就在于：<strong>发送的任何请求都会将<code>express服务</code>走一遍</strong></p>
<p>网站肯定要展示信息给用户，展示过程即 <code>defaultServe</code>读取文件的过程，但 <code>defaultServe</code>执行完毕后又会直接执行<code>express服务</code>，而这些读取文件的基本服务我们都是交给<code>defaultServe</code>处理的，在<code>入口文件</code>中并没有使用<code>app.get/post</code>处理，也就不会被压入<code>Global变量</code>的对应属性中。就会执行下述代码，产生报错信息。</p>
<p>但这些报错信息并不会导致页面显示<code>没有找到该资源!</code>，而是某些资源不能正常展示，这些报错会反映在服务端，原因是：</p>
<ul>
<li> 经过了<code>defaultServe</code>读取文件，要使用<code>res.end</code>响应，而在这里又直接使用了<code>res.write</code>,而使用<code>res.end</code>以后就代表该次响应结束了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (G[<span class="string">`_<span class="subst">$&#123;reqMethod&#125;</span>`</span>][pathName]) &#123;</span><br><span class="line">     ……</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">      res.write(<span class="string">`&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;/head&gt;`</span>);</span><br><span class="line">      res.end(<span class="string">&quot;没有找到该资源!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有的同学就会提问了：我们在外部使用<code>app.get/post</code>配置这些路由不就好了吗？</p>
<p>我们不可能对这些基本的服务依次配置，原因有以下两点：</p>
<ul>
<li>实际开发请求是非常非常多的，而且还涉及到动态路由。</li>
<li>如果依次配置，封装也就没有意义了</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>我们需要判断<code>defaultServe</code>的状态，如果其正常读取文件，则不执行<code>express服务</code>部分。</p>
<p>反之，<code>defaultServe</code>不能正常读取，就轮到了扩展路由业务部分，再执行<code>express服务</code>。</p>
<p>我们定义一个开关变量即可，对应代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">let</span> FLAG = <span class="literal">true</span>;	<span class="comment">//全局定义开关变量</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultServe</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    FLAG = <span class="literal">false</span>;		<span class="comment">//基本服务不能正常执行，置为false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expressServe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> G = &#123; <span class="attr">_get</span>: &#123;&#125;, <span class="attr">_post</span>: &#123;&#125;, staticPath &#125;;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    defaultServe(req, res);</span><br><span class="line">    <span class="keyword">let</span> pathName = _url.parse(req.url).pathname;</span><br><span class="line">    <span class="keyword">let</span> reqMethod = req.method.toLowerCase();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!FLAG) &#123;	<span class="comment">//若基本服务不能正常执行，再执行express服务部分</span></span><br><span class="line">      ……</span><br><span class="line">      FLAG = <span class="literal">true</span>; <span class="comment">//最后要置为初始值,让下个请求依旧正常逻辑执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = expressServe();</span><br></pre></td></tr></table></figure>



<h2 id="封装版本3"><a href="#封装版本3" class="headerlink" title="封装版本3"></a>封装版本3</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>上述封装的<code>express基本服务版本2</code>，虽然能让资源正常的加载，但还不够完美。</p>
<p>问题概述：</p>
<p>​    如果我想要在执行<code>defaultServe</code>读取文件的同时，又要在外部使用<code>express服务</code>部分进行一些拦截，要怎么实现呢？</p>
<p>​    这个功能是非常有必要实现的，因为我们往往要完成的不只是展示，通常还要做一些操作。</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>​    这里我将思路重新整理了一下，之前都是先执行<code>defaultServe</code>，再执行<code>express服务</code>部分，但既然我们有可能要使用路由拦截，就不如将执行顺序调换一下，当然不只是简单的调换，还要做一些处理，保证逻辑能够正常执行。</p>
<ol>
<li>由于要先执行<code>express服务</code>部分，所以在执行对应路由操作之前，先判断有没有这个callback</li>
<li>把<code>express服务</code>部分中最外层的<code>else</code>取消掉。</li>
<li><code>defaultServe</code>默认服务的<code>catch</code>部分，要对错误进行处理，因为是放在<code>express服务</code>后执行，所以不再像原来一样，将错误交给<code>express服务</code>,这也就是为什么要把 <code>express服务</code>部分的<code>else</code>取消掉 的原因</li>
<li>由于调换了执行顺序，此时也就不需要版本二的<code>FLAG</code>开关了。</li>
</ol>
<p>整体代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&quot;public&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> defaultMimePath = <span class="string">`./modules/mime.json`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileType</span>(<span class="params">pathName, mimePath = defaultMimePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mime = <span class="built_in">JSON</span>.parse(_fs.readFileSync(mimePath));</span><br><span class="line">  <span class="keyword">let</span> extName = _path.extname(pathName);</span><br><span class="line">  <span class="keyword">return</span> mime[extName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultServe</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reqUrl = req.url == <span class="string">&quot;/&quot;</span> ? <span class="string">&quot;/index.html&quot;</span> : req.url;</span><br><span class="line">  <span class="keyword">let</span> pathName = _url.parse(reqUrl).pathname;</span><br><span class="line">  <span class="keyword">let</span> fileType = getFileType(pathName);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reqUrl != <span class="string">&quot;/favicon.ico&quot;</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`<span class="subst">$&#123;fileType&#125;</span>;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">      <span class="keyword">let</span> data = _fs.readFileSync(staticPath + pathName);</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">  	<span class="comment">//defaultServe最后执行，要对错误进行处理</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">    res.write(<span class="string">`&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;/head&gt;`</span>);</span><br><span class="line">    res.end(<span class="string">&quot;没有找到该资源!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expressServe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> G = &#123; <span class="attr">_get</span>: &#123;&#125;, <span class="attr">_post</span>: &#123;&#125;, staticPath &#125;;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pathName = _url.parse(req.url).pathname;</span><br><span class="line">    <span class="keyword">let</span> reqMethod = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (G[<span class="string">`_<span class="subst">$&#123;reqMethod&#125;</span>`</span>][pathName]) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((reqMethod = <span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">        G[<span class="string">`_get`</span>][pathName] &amp;&amp; G[<span class="string">`_get`</span>][pathName](req, res);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((reqMethod = <span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> postData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        req.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">          postData += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          req.body = postData;</span><br><span class="line">          G[<span class="string">`_post`</span>][pathName] &amp;&amp; G[<span class="string">`_post`</span>][pathName](req, res);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defaultServe(req, res);	<span class="comment">//默认服务</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//API</span></span><br><span class="line">  app.get = <span class="function">(<span class="params">pathName, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    G[<span class="string">&quot;_get&quot;</span>][pathName] = callback;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.post = <span class="function">(<span class="params">pathName, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    G[<span class="string">&quot;_post&quot;</span>][pathName] = callback;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.send = <span class="function">(<span class="params">req, res, content</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">`text/html;charset=&quot;utf-8&quot;`</span> &#125;);</span><br><span class="line">    res.write(<span class="string">`&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;/head&gt;`</span>);</span><br><span class="line">    res.end(content);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = expressServe();</span><br></pre></td></tr></table></figure>

<p>入口文件使用：👇</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; extname &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5505</span>;</span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&quot;public&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&quot;./modules/expressServe&quot;</span>);</span><br><span class="line"></span><br><span class="line">_http.createServer(app).listen(port);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/main.html&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`/main.html路由映射的服务`</span>);		<span class="comment">//能够进行拦截操作</span></span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/ashun&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  app.send(req, res, <span class="string">&quot;Ashuntefannao&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
]]></content>
      <categories>
        <category>后台语言</category>
        <category>Node.js</category>
        <category>原生node</category>
      </categories>
  </entry>
  <entry>
    <title>transition过渡动画</title>
    <url>/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/CSS/transition%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/transition%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h2><p>​    css中实现动画有两种方式：<code>transition</code>过渡动画、 <code>animation</code>自定义动画。</p>
<p>​    本文主要讲解<code>transition</code>过渡动画的使用，若要了解<code>animation</code>动画请前往<a href="##">animation自定义动话</a>。</p>
<p>​    在不使用<code>transition</code>时，若通过用户的交互直接改变<code>css样式属性</code>，呈现的形式是立刻转变，但有时我们希望这个变化是有过渡效果的，这时就可应用<code>transition</code>过渡动画了。</p>
<p>我们先来简单了解下<code>transition</code>族属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>指定使用过渡效果的css属性</td>
</tr>
<tr>
<td>transition-duration</td>
<td>设置过渡动画持续时间</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>设置动画的时间函数。</td>
</tr>
<tr>
<td>transition-delay</td>
<td>设置动画的延迟时间</td>
</tr>
</tbody></table>
<p>下面详细介绍各个属性👇</p>
<h2 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h2><p><code>transition-property </code>: 用于指定使用过渡效果的css属性，默认值为<code>all</code>。</p>
<p>案例展示：</p>
<img src="transition过渡动画.assets/transition1.gif" alt="transition1" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition-property: all;</span><br><span class="line">    transition-duration: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  .box::after &#123;</span><br><span class="line">    content: &quot;★&quot;;</span><br><span class="line">    color: rgba(255, 255, 255, 0.8);</span><br><span class="line">    width: inherit;</span><br><span class="line">    height: inherit;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    transition-duration: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  .box:hover &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">  &#125;</span><br><span class="line">  .box:hover::after &#123;</span><br><span class="line">    content: &quot;♥&quot;;</span><br><span class="line">    font-size: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>为了使动画有过渡效果，必须设置过渡时间，这也是过渡动画的基本要素，所以上述具有动画的元素都设置了<code>transition-duration</code>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="transition-property的默认值"><a href="#transition-property的默认值" class="headerlink" title="transition-property的默认值"></a>transition-property的默认值</h4><p>​    上述案例在触发<code>hover</code>时,我只改变了文字和大小，可实际效果却影响了文字的布局（文字移动），产生的原因就是忽略了<code>transition-property</code>的默认值。</p>
<p>​    我们已经多次提及了transition-property的默认值，上述代码给<code>.box</code>的伪类<code>::after</code>只添加了一个<code>transition-duration</code>，而没有设置<code>transition-property</code>,所以会应用其默认值<code>all</code>，也就是说：<strong>所有能够被transition支持的属性都会有过渡效果</strong>。</p>
<p>我们来具体分析一下，为什么会产生变动：</p>
<p>​    <code>.box</code>伪类<code>::after</code>的宽高是继承父级的，由于在触发<code>hover</code>时，父级宽高发生改变，所以伪类宽高也会跟随改变，从而影响了布局。</p>
<p>​    为了更清晰的看到原因，我们可以为伪类添加一个背景</p>
<img src="transition过渡动画.assets/transition1.1.gif" alt="transition1.1" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box::after &#123;</span><br><span class="line">  ……</span><br><span class="line">  background-color: rgba(0, 0, 0, 0.3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们只想让文字大小产生过渡效果，只需要明确指定<code>transition-property:font-size</code>即可。</p>
<h4 id="transition不能支持的过渡"><a href="#transition不能支持的过渡" class="headerlink" title="transition不能支持的过渡"></a>transition不能支持的过渡</h4><p>​    上述动画中可发现，文字内容是突变的，当然还有其他transition不支持过渡的选项，也都很好理解:</p>
<ul>
<li><code>z-index</code></li>
<li><code>display</code></li>
</ul>
<h2 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h2><p><code>transition-duration</code>定义动画的过渡时间，默认值为<code>0s</code>,也就是说，如果不设置该属性，默认是没有过渡效果的。</p>
<h2 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h2><p>定义动画事件函数，<code>animation</code>族属性中也有该属性，该属性可以改变动画的执行速率以及轨迹。</p>
<p>其值对应<code>animation-timing-function</code></p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">动画从头到尾的速度是相同的。</td>
</tr>
<tr>
<td align="left">ease（缓解）</td>
<td align="left">**<code>默认值</code>**：动画以低速开始，然后加快，在结束前变慢。</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">动画以低速开始。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">动画以低速结束。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">动画以低速开始和结束。</td>
</tr>
<tr>
<td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">贝塞尔曲线（自定义数值），可到<a href="https://cubic-bezier.com/">相关网站</a>可视化设置。</td>
</tr>
</tbody></table>
<p>案例展示：</p>
<img src="transition过渡动画.assets/transition2.gif" alt="transition2" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  transition-property: all;</span><br><span class="line">  transition-duration: 0.8s;</span><br><span class="line">  transition-timing-function: cubic-bezier(0.49, 1.59, 0.46, -0.21);</span><br><span class="line">&#125;</span><br><span class="line">.box:hover &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  transform: rotate(360deg);</span><br><span class="line">  background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h2><p><code>transition-delay</code>用于设置动画延迟时间，单位为<code>s</code></p>
<p>下例动画：触发<code>hover</code>于<code>1s</code>后执行，<strong>离开元素后也会延时1s再过渡</strong></p>
<img src="transition过渡动画.assets/transition3.gif" alt="transition3" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  main &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    min-height: 300px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    transform: perspective(500px) rotateY(50deg);</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    background-color: #ddd;</span><br><span class="line">    font-size: 24px;</span><br><span class="line">  &#125;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition-property: all;</span><br><span class="line">    transition-duration: 0.8s;</span><br><span class="line">    transition-delay: 1s;</span><br><span class="line">    transform-origin: center;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  main:hover .box &#123;</span><br><span class="line">    width: 70px;</span><br><span class="line">    height: 70px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    transform: rotateY(90deg) translateZ(180px);</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    &#x2F;* transition-delay: 0s; *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;p&gt;跨过这堵墙&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>若我们想要立即触发动画，只在恢复时延迟过渡，该怎么办呢？</p>
<p>我们只需要在动画触发时，重新设置<code>transition-delay: 0s </code>即可，动画一旦出发就会应用对应的样式表，这时重置延时为<code>0s</code>，动画执行完毕，恢复原来样式，而原来样式表中<code>transition-delay: 1s</code>设置延时为<code>1s</code>，恢复时就会延时1s。</p>
<p>我们只需要在原有代码基础上添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:hover .box &#123;</span><br><span class="line">	……</span><br><span class="line">	transition-delay: 0s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加之后效果：</p>
<img src="transition过渡动画.assets/transition3.1.gif" alt="transition3.1" style="zoom:67%;" />

<p>当同时使用多个动画时，这个属性使用频率非常高，可依次定义每个动画的延迟执行时间，区分开每个动画。</p>
<p>当然其实也可分别设置每个动画的其它transition族属性，后面会详细介绍多动画累加。</p>
<h2 id="多属性累加"><a href="#多属性累加" class="headerlink" title="多属性累加"></a>多属性累加</h2><p>​    我们知道，当<code>transition-property</code>属性值为<code>all</code>，则所有transition能够支持的属性发生改变时，都会触发过渡效果，但能不能对每个属性的过渡分别进行设置呢？</p>
<p>答案是当然可以，之前介绍的transition族属性都可以设置多个值，各个值之间使用<code>,</code>隔开，从而分别设置各个属性的过渡效果。</p>
<p>值得注意的是：其它transition族属性在设置多个值时，要与<code>transition-property</code>定义的各个属性对应起来，才能准确对目标属性定制过渡效果。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition-property: width, heitht, color ;</span><br><span class="line">trnasition-duration: 1s, 1.5s, 2s ;</span><br><span class="line">transition-timing-function: ease, linear, ease-in-out ;</span><br><span class="line">transition-delay: 0s, 1s, 0s ;</span><br></pre></td></tr></table></figure>

<p>当然，也可使用<code>transition综合属性</code>:</p>
<p>定义顺序分别为：</p>
<ul>
<li>transition-property</li>
<li>transition-duration</li>
<li>transition-timing-function</li>
<li>transition-delay</li>
</ul>
<p>下面代码与上例效果相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition: width 1s ease ,heitht 1.5s linear 1s, color 2s ease-in-out ;</span><br></pre></td></tr></table></figure>



<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
<p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>CSS</category>
        <category>transition过渡动画</category>
      </categories>
  </entry>
  <entry>
    <title>transform变形</title>
    <url>/2021/05/08/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/CSS/transform%E5%8F%98%E5%BD%A2/transform%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h2><p>​    如果说CSS3的灵魂在于美妙的动画，那在实现炫酷动画过程中，就一定少不了<code>transform</code>变形，在<code>transform</code>中我们可以设置移动、旋转、缩放等效果，同时transform也为我们提供了一些族属性，来应对不同的场景，只要你敢想就能设计出不同的动效。</p>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>transform的属性如下：</p>
<h4 id="translate："><a href="#translate：" class="headerlink" title="translate："></a>translate：</h4><table>
<thead>
<tr>
<th>translate相关</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>translate(x,y)</td>
<td>可同时设置沿(x,y)轴的移动长度</td>
</tr>
<tr>
<td>translateX(x)</td>
<td>只设置x轴移动长度</td>
</tr>
<tr>
<td>translateY(y)</td>
<td>只设置y轴移动长度</td>
</tr>
<tr>
<td>translateZ(z)</td>
<td>只设置z轴移动长度，只有在3D场景下，该属性才能体现</td>
</tr>
<tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>可分别设置沿(x,y,z)轴的移动长度</td>
</tr>
</tbody></table>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><table>
<thead>
<tr>
<th>rotate相关</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>rotate(<code>n</code>deg)</td>
<td>与rotateZ相同。</td>
</tr>
<tr>
<td>rotateX(<code>n</code>deg)</td>
<td>只设置x轴旋转角度，在3d场景尤为明显</td>
</tr>
<tr>
<td>rotateY(<code>n</code>deg)</td>
<td>只设置y轴旋转角度，在3d场景尤为明显</td>
</tr>
<tr>
<td>rotateZ(<code>n</code>deg)</td>
<td>只设置z轴旋转角度</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>，<code>n</code>deg)</td>
<td>可分别设置沿(x,y,z)轴的旋转角度，前三个参数值为<code>0</code>或<code>1</code>,意为是否设置某个轴的旋转。</td>
</tr>
</tbody></table>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><table>
<thead>
<tr>
<th>scale相关</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>scale(<em>x</em>,<em>y</em>)</td>
<td>分别定义(<em>x</em>,<em>y</em>)轴的缩放比例，值为<code>0~n</code>，若只传入一个值，则(<em>x</em>,<em>y</em>)轴都应用这个值。</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>只设置x轴缩放。</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>只设置y轴缩放。</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>只设置z轴缩放</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>可分别设置沿(x,y,z)轴的缩放倍数。</td>
</tr>
</tbody></table>
<h4 id="skew"><a href="#skew" class="headerlink" title="skew"></a>skew</h4><table>
<thead>
<tr>
<th>scale相关</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>skew(<em>x</em>,<em>y</em>)</td>
<td>分别定义(<em>x</em>,<em>y</em>)轴的倾斜角度，单位<code>deg</code>,若只传入一个值，则(<em>x</em>,<em>y</em>)轴都应用这个值。</td>
</tr>
<tr>
<td>skewX(<em>x</em>)</td>
<td>只设置x轴倾斜角度。</td>
</tr>
<tr>
<td>skewY(<em>y</em>)</td>
<td>只设置y轴倾斜角度。</td>
</tr>
</tbody></table>
<h4 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h4><p>​    <code>transform: perspective(arg)</code>,参数单位为<code>px</code>，规定3D场景的<strong>视角距离</strong>，该属性可设置在3D盒子本身，也可设置在父级元素，都能成功显示视口距离效果。</p>
<p>​    还有一个全局属性<code>perspective: arg</code>,用法与<code>transform: perspective(arg)</code>相同，不过值得注意的是：这个全局属性必须设置在想要展示3D效果盒子的<strong>父级</strong>元素上，才能正常显示视角距离效果。</p>
<hr>
<h3 id="族属性"><a href="#族属性" class="headerlink" title="族属性"></a>族属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>transform-origin</td>
<td>设置transform变换的基点</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示。</td>
</tr>
</tbody></table>
<h3 id="其它相关"><a href="#其它相关" class="headerlink" title="其它相关"></a>其它相关</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>perspective</td>
<td>设置3D场景的视角距离</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>设置3D场景的视角基点</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>设置元素背面是否可见，可设置<code>visible</code>、<code>hidden</code>。</td>
</tr>
</tbody></table>
<ul>
<li><p>perspective，要注意其与<code>transform: perspective(arg)</code>的区别，其只能设置在3d盒子的父级元素上</p>
</li>
<li><p>backface-visibility<br>这个属性在做旋转卡片时很重要，因为旋转卡片要展示两面，默认情况下正面卡片在旋转后，其背面也会透视显示，从而影响背面卡片的显示，所以要设置两张卡片背面不可见。</p>
<p>示例：</p>
<p>未设置：</p>
<img src="transform变形.assets/backface-visibility1.gif" alt="backface-visibility1" style="zoom:50%;" />

<p>设置后：</p>
<img src="transform变形.assets/backface-visibility2.gif" alt="backface-visibility2" style="zoom:50%;" /></li>
</ul>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>了解了变形的基本操作，就可以利用这些属性随意发挥想象力了，下面示例将会运用transform实现。</p>
<p>一、表单效果</p>
<img src="transform变形.assets/translate表单.gif" alt="translate表单" style="zoom:75%;" />

<p>值得注意的是：<code>input[type=&quot;text&quot;]</code>不能添加伪类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  main &#123;</span><br><span class="line">    width: 80%;</span><br><span class="line">  &#125;</span><br><span class="line">  form &#123;</span><br><span class="line">    width: inherit;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">    background: #2c3e50;</span><br><span class="line">  &#125;</span><br><span class="line">  span &#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    display: inline-flex;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">    letter-spacing: 2px;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">  label &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    min-height: 50px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  .inputBox &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 150px;</span><br><span class="line">    min-height: 30px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    margin-left: 8px;</span><br><span class="line">    background: white;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  input &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    min-height: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">  .after &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0px;</span><br><span class="line">    left: 0px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 2.1px;</span><br><span class="line">    border-radius: 2px;</span><br><span class="line">    background: linear-gradient(</span><br><span class="line">      to right,</span><br><span class="line">      white,</span><br><span class="line">      #e74c3c,</span><br><span class="line">      #e67e22,</span><br><span class="line">      #f1c40f,</span><br><span class="line">      #bdc3c7,</span><br><span class="line">      #1abc9c,</span><br><span class="line">      #3498db,</span><br><span class="line">      #9b59b6,</span><br><span class="line">      white</span><br><span class="line">    );</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">    transition: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  .inputBox:hover &#123;</span><br><span class="line">    transform: scale(1.1);</span><br><span class="line">  &#125;</span><br><span class="line">  .inputBox:hover .after &#123;</span><br><span class="line">    transform: translateX(0);</span><br><span class="line">  &#125;</span><br><span class="line">  button &#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    color: white;</span><br><span class="line">    background: transparent;</span><br><span class="line">    border: 2px solid white;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    position: relative;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  button &gt; span &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    z-index: 1;</span><br><span class="line">    background: transparent;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line">  button::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    width: 98%;</span><br><span class="line">    height: inherit;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    background: transparent;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    transition: 0.8s;</span><br><span class="line">  &#125;</span><br><span class="line">  button:hover &#123;</span><br><span class="line">    transform: scale(1.1);</span><br><span class="line">  &#125;</span><br><span class="line">  button:hover:after &#123;</span><br><span class="line">    transform: skewX(45deg) translate(-10px, -50%);</span><br><span class="line">    background: #e74c3c;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;#&quot;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;span&gt;用户名:&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;inputBox&quot;&gt;</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;after&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;span&gt;密码:&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;inputBox&quot;&gt;</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;after&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;button&gt;&lt;span&gt;Login&lt;&#x2F;span&gt;&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>


<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><p>对于3D效果，我们就需要进行一些预设，只有配置了这些预设，才能够有视觉效果。</p>
<h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p><code>transform-style</code>: 规定被嵌套元素如何在 3D 空间中显示。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>flat</td>
<td>子元素将不保留其 3D 位置。</td>
</tr>
<tr>
<td>preserve-3d</td>
<td>子元素将保留其 3D 位置。</td>
</tr>
</tbody></table>
<p>当我们设置<code>transform-style: preserve-3d</code>时，后期改变元素位置，才会有视口距离效果。</p>
<p>当然，我们还要配置视口距离👇。</p>
<h3 id="perspective-1"><a href="#perspective-1" class="headerlink" title="perspective"></a>perspective</h3><p>我们可以使用两种方式定义视口距离，单位都为<code>px</code>：</p>
<ol>
<li><code>perspective: arg</code></li>
<li><code>transform: perspective(arg)</code></li>
</ol>
<p>但值得注意的是二者的区别，上文已经说明，这里不再赘述，但在实际使用时，用哪个比较好呢？</p>
<p>个人推荐使用<code>perspective</code>,不使用<code>transform: perspective(arg)</code>的原因如下:</p>
<p>​    <strong>当触发选项很多时</strong>，为了保证具有视口效果，在触发时的样式表中还要重复配置<code>transform: perspective(arg)</code>。</p>
<p>​    因为动画被触发时，应用的是触发时的样式表，若此时不配置<code>transform: perspective(arg)</code>,则会出现：动画触发前还有视口效果，触发后却没有了。</p>
<p>​    而我们为了避免这种情况，只需要在其父级盒子上设置<code>perspective</code>即可，因为其不属于<code>transform</code>, 所以在后期触发时，不用考虑transform重新配置的问题。</p>
<hr>
<p>当我们做好了前期的预设，后面就可以顺利展示3d效果了：</p>
<ul>
<li><p>（<em>z</em>）轴相关特效得以体现</p>
</li>
<li><p>一些（<em>x</em>,<em>y</em>）轴的特效会更加明显</p>
</li>
</ul>
<p>让我们来对比一下：</p>
<p>一、未配置预设时的translateZ效果</p>
<p>​    没错！没有效果，由于没有保留元素3d位置，所以Z轴效果不能够得到体现。</p>
<img src="transform变形.assets/3D对比-未设置.gif" alt="3D对比-未设置.gif" style="zoom:50%;" />

<p>二、配置预设后</p>
<img src="transform变形.assets/3D对比-设置.gif" alt="3D对比-设置.gif" style="zoom:50%;" />

<p>什么？效果不明显？让我们简单的旋转一下。</p>
<img src="transform变形.assets/3D效果1.gif" alt="3D效果1.gif" style="zoom:50%;" />

<p>​    </p>
<h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><p>下面让我们展示一个案例，更好的熟悉3D动画</p>
<img src="transform变形.assets/3D效果2.gif" alt="3D效果2.gif" style="zoom:55%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">  body &#123;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    min-height: 100vh;</span><br><span class="line">    background-color: #7f8c8d;</span><br><span class="line">  &#125;</span><br><span class="line">  main &#123;</span><br><span class="line">    width: inherit;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  section &#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 400px;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &#123;</span><br><span class="line">    width: inherit;</span><br><span class="line">    height: inherit;</span><br><span class="line">    border: 2px solid white;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    transform: perspective(900px) rotate3d(0, 1, 0, 45deg);</span><br><span class="line">    transition-duration: 1s;</span><br><span class="line">    transition-delay: 1s;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &gt; div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    transition: 1s;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &gt; div:nth-of-type(1) &#123;</span><br><span class="line">    background: #badc58;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &gt; div:nth-of-type(2) &#123;</span><br><span class="line">    background: #ff7979;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &gt; div:nth-of-type(3) &#123;</span><br><span class="line">    background: #ffbe76;</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D &gt; div:nth-of-type(4) &#123;</span><br><span class="line">    background: #22a6b3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .box3D:hover &#123;</span><br><span class="line">    transform: perspective(900px) rotate3d(0, 1, 1, 225deg);</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D:hover &gt; div:nth-of-type(1) &#123;</span><br><span class="line">    transform: translate3d(-50%, -50%, 100px);</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D:hover &gt; div:nth-of-type(2) &#123;</span><br><span class="line">    transform: translate3d(-50%, -50%, -200px);</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D:hover &gt; div:nth-of-type(3) &#123;</span><br><span class="line">    transform: translate3d(-50%, -50%, -100px);</span><br><span class="line">  &#125;</span><br><span class="line">  .box3D:hover &gt; div:nth-of-type(4) &#123;</span><br><span class="line">    transform: translate3d(-50%, -50%, 200px);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;box3D&quot;&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当然，我更推荐使用<code>perspective</code>来在3d盒子的<code>父级元素</code>中设置视口。</p>
</li>
<li><p>虽然该案例对于3d盒子(<code>.box3D</code>)来说，只有一个<code>hover</code>进行触发，但如果我希望click、表单提交时，等等场景下都触发该动画，无论在CSS还是在JS中，都需要重复配置<code>transform：perspective(900px)</code>。</p>
</li>
</ul>
<p>进行以下更改即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">section &#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 400px;</span><br><span class="line">    perspective: 900px; &#x2F;&#x2F;在父级元素配置视口</span><br><span class="line">&#125;</span><br><span class="line">.box3D &#123;</span><br><span class="line">   ……</span><br><span class="line">   transform: rotate3d(0, 1, 0, 45deg);  &#x2F;&#x2F;去掉transform:perspective(900px)</span><br><span class="line">   ……</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>之后再出发时，就不用重复配置<code>transform: perspective(900px)</code>选项了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box3D:hover &#123;</span><br><span class="line">    transform: rotate3d(0, 1, 1, 225deg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>效果和之前一样，还能减少代码冗余。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
<p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>CSS</category>
        <category>transform变形</category>
      </categories>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/JSON/</url>
    <content><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>json 是一种轻量级的数据交换格式，易于人阅读和编写。</li>
<li>使用<code>json</code> 数据格式是替换 <code>xml</code> 的最佳方式，主流语言都很好的支持<code>json</code> 格式。所以 <code>json</code> 也是前后台传输数据的主要格式。</li>
<li>json 标准中要求使用<code>双引号包裹属性名称</code>，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。</li>
</ul>
<p><strong>关于Javascript中的JSON</strong></p>
<ul>
<li><p>javacript中的json数据转化，主要依赖两个内置方法。</p>
</li>
<li><p>序列化</p>
<ul>
<li><code>JSON.stringify(obj,[...prop],num/str)</code></li>
<li>参数说明<ul>
<li>jsonObj</li>
<li>可选，如果只想得到个别属性，则可传入该参数</li>
<li>可选，为number时:控制缩进数，为string时:控制引导字符串</li>
</ul>
</li>
</ul>
</li>
<li><p>反序列化</p>
</li>
<li><p><code>JSON.parse(jsonStr,(key,val)=&gt;&#123;...&#125;)</code></p>
<ul>
<li>参数说明</li>
<li>josnStr<ul>
<li>可选，可在反序列化的过程中对数据进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let json = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  &quot;Controller&quot;: &#123;</span><br><span class="line">  	&quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(json.Controller.name);</span><br></pre></td></tr></table></figure>

<h5 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a><strong>数组结构</strong></h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &#x27;媒体查询响应式布局&#x27;,</span><br><span class="line">    &quot;category&quot;: &#x27;css&#x27;,</span><br><span class="line">    &quot;click&quot;: 199</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &#x27;FLEX 弹性盒模型&#x27;,</span><br><span class="line">    &quot;category&quot;: &#x27;css&#x27;,</span><br><span class="line">    &quot;click&quot;: 12</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &#x27;MYSQL多表查询随意操作&#x27;,</span><br><span class="line">    &quot;category&quot;: &#x27;mysql&#x27;,</span><br><span class="line">    &quot;click&quot;: 89</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(lessons[0].title);</span><br></pre></td></tr></table></figure>

<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化是将 <code>json对象</code> 转换为<code>字符串</code>，一般用来向其他语言传输使用。</p>
<ul>
<li><code>JSON.stringify(obj,[...props])</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  &quot;Controller&quot;: &#123;</span><br><span class="line">  	&quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(as));</span><br><span class="line">//&#123;&quot;title&quot;:&quot;阿顺特烦恼&quot;,&quot;url&quot;:&quot;Ashuntefannao.com&quot;,&quot;Controller&quot;:&#123;&quot;name&quot;:&quot;Ashun&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>根据第二个参数指定保存的属性</p>
<ul>
<li>可选，若不指定，则返回所有prop</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(JSON.stringify(as, [&#x27;title&#x27;, &#x27;url&#x27;]));</span><br><span class="line">//&#123;&quot;title&quot;:&quot;阿顺特烦恼&quot;,&quot;url&quot;:&quot;Ashuntefannao.com&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>第三个是参数用来控制TAB缩进数量，如果字符串则为前导字符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  &quot;Controller&quot;: &#123;</span><br><span class="line">  	&quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(as, null, 2));</span><br><span class="line">/*</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  &quot;Controller&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Ashun&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">console.log(JSON.stringify(as, null, &quot;-&quot;));</span><br><span class="line">/*</span><br><span class="line">&#123;</span><br><span class="line">-&quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">-&quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">-&quot;Controller&quot;: &#123;</span><br><span class="line">--&quot;name&quot;: &quot;Ashun&quot;</span><br><span class="line">-&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为数据添加 <code>toJSON</code> 方法来自定义返回格式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">    &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">    &quot;Controller&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;toJSON&quot;: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &quot;title&quot;: this.url,</span><br><span class="line">            &quot;name&quot;: this.Controller.name</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(as)); //&#123;&quot;title&quot;:&quot;Ashuntefannao.com&quot;,&quot;name&quot;:&quot;Ashun&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>使用 <code>JSON.parse</code> 将<code>josn字符串</code> 解析成<code>json对象</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  &quot;Controller&quot;: &#123;</span><br><span class="line">  	&quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let jsonStr = JSON.stringify(as);</span><br><span class="line">console.log(JSON.parse(jsonStr));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jsonStr&#x3D;&#96;</span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:&quot;Ashun&quot;,</span><br><span class="line">	&quot;age&quot;:18	</span><br><span class="line">&#125;</span><br><span class="line">&#96;;</span><br><span class="line">console.log(JSON.parse(jsonStr));</span><br></pre></td></tr></table></figure>

<p>使用第二个参数函数来对返回的数据二次处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  title: &quot;阿顺特烦恼&quot;,</span><br><span class="line">  url: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">  Controller: &#123;</span><br><span class="line">  	&quot;name&quot;: &quot;Ashun&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let jsonStr = JSON.stringify(as);</span><br><span class="line">console.log(</span><br><span class="line">  JSON.parse(jsonStr, (key, value) =&gt; &#123;</span><br><span class="line">    if (key == &quot;title&quot;) &#123;</span><br><span class="line">      return `$&#123;value&#125;-SHUN`;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">/*</span><br><span class="line">&#123;title: &quot;阿顺特烦恼-SHUN&quot;, url: &quot;Ashuntefannao.com&quot;, Controller: &#123;…&#125;&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>Map</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Map/</url>
    <content><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是一组<code>键值对</code>的结构，用于解决以往不能用对象做为键的问题</p>
<ul>
<li>具有极快的查找速度</li>
<li>Map的key可以为<code>任意类型</code></li>
</ul>
<h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p><code>接受一个数组作</code>为参数，该数组的<code>成员是一个表示键值对的数组</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">	[&quot;name&quot;, &quot;ashun&quot;],</span><br><span class="line">	[&quot;age&quot;, 18],</span><br><span class="line">]);</span><br><span class="line">console.log(map); 	//Map(2) &#123;&quot;name&quot; =&gt; &quot;ashun&quot;, &quot;age&quot; =&gt; 18&#125;</span><br></pre></td></tr></table></figure>

<p>使用构造函数<code>new Map</code>创建的原理如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = new Map();</span><br><span class="line">const arr = [[&quot;ashun&quot;, &quot;阿顺&quot;], [&quot;type&quot;, &quot;Controller&quot;]];</span><br><span class="line"></span><br><span class="line">arr.forEach(([key, value]) =&gt; &#123;</span><br><span class="line">  as.set(key, value);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>对于键是对象的<code>Map</code>， 键保存的是内存地址，值相同但内存地址不同的视为两个键。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;阿顺&quot;];</span><br><span class="line">const as = new Map();</span><br><span class="line">as.set(arr, &quot;Ashuntefannao.com&quot;);</span><br><span class="line">console.log(as.get(arr)); //&quot;Ashuntefannao.com</span><br><span class="line">console.log(as.get([&quot;阿顺&quot;])); //undefined</span><br></pre></td></tr></table></figure>



<h3 id="管理Map"><a href="#管理Map" class="headerlink" title="管理Map"></a>管理Map</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>使用<code>set(key,value)</code> 方法添加元素，支持链式操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name: &quot;Ashun&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.set(obj, &quot;Ashuntefannao.com&quot;).set(&quot;name&quot;, &quot;ashun&quot;);</span><br><span class="line"></span><br><span class="line">console.log(map.entries()); &#x2F;&#x2F;MapIterator &#123;&#123;…&#125; &#x3D;&gt; &quot;Ashuntefannao.com&quot;, &quot;name&quot; &#x3D;&gt; &quot;ashun&quot;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>使用<code>delete(key)</code>删除对应键和值。返回Boolean。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">        [&quot;name&quot;, &quot;ashun&quot;],</span><br><span class="line">        [&quot;age&quot;, 18],</span><br><span class="line">]);</span><br><span class="line">map.delete(&quot;age&quot;);</span><br><span class="line">console.log(map);	&#x2F;&#x2F;Map(1) &#123;&quot;name&quot; &#x3D;&gt; &quot;ashun&quot;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>使用<code>clear()</code>清空Map。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">        [&quot;name&quot;, &quot;ashun&quot;],</span><br><span class="line">        [&quot;age&quot;, 18],</span><br><span class="line">]);</span><br><span class="line">map.clear();</span><br><span class="line">console.log(map); 	&#x2F;&#x2F;Map(0) &#123;&#125;</span><br></pre></td></tr></table></figure>





<h4 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h4><p>由于Map数据类型是可迭代的，所以可以通过<code>for/of、forEach</code>或迭代器进行遍历。</p>
<p>使用 <code>keys()/values()/entries()</code> 都可以返回可遍历的迭代对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> let map = new Map([</span><br><span class="line">        [&quot;Ashun&quot;, &quot;阿顺&quot;],</span><br><span class="line">        [&quot;tefannao&quot;, &quot;特烦恼&quot;],</span><br><span class="line">]);</span><br><span class="line">console.log(map.keys()); //MapIterator &#123;&quot;Ashun&quot;, &quot;tefannao&quot;&#125;</span><br><span class="line">console.log(map.values()); //MapIterator &#123;&quot;阿顺&quot;, &quot;特烦恼&quot;&#125;</span><br><span class="line">console.log(map.entries()); //MapIterator &#123;&quot;Ashun&quot; =&gt; &quot;阿顺&quot;, &quot;tefannao&quot; =&gt; &quot;特烦恼&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>keys/values</code> 函数遍历键与值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = new Map([[&quot;Ashun&quot;, &quot;阿顺&quot;], [&quot;tefannao&quot;, &quot;特烦恼&quot;]]);</span><br><span class="line">for (const key of as.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">for (const value of as.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>for/of</code>遍历操作，直接遍历Map 等同于使用<code>entries()</code> 函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = new Map([</span><br><span class="line">        [&quot;Ashun&quot;, &quot;阿顺&quot;],</span><br><span class="line">        [&quot;tefannao&quot;, &quot;特烦恼&quot;],</span><br><span class="line">]);</span><br><span class="line">for (const [key, value] of as) &#123;</span><br><span class="line">		console.log(`$&#123;key&#125;=&gt;$&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">for (const [key, value] of as.entries()) &#123;</span><br><span class="line">		console.log(`$&#123;key&#125;=&gt;$&#123;value&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>forEach</code>遍历操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = new Map([[&quot;title&quot;, &quot;Ashuntefannao&quot;], [&quot;name&quot;, &quot;Ashun&quot;]]);</span><br><span class="line">as.forEach((value, key) =&gt; &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;=&gt;$&#123;value&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="has"><a href="#has" class="headerlink" title="has"></a>has</h4><p>使用<code>has(key)</code>查找是否有该元素。返回Boolean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">        [&quot;name&quot;, &quot;ashun&quot;],</span><br><span class="line">        [&quot;age&quot;, 18],</span><br><span class="line">]);</span><br><span class="line">console.log(map.has(&quot;as&quot;));	&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>使用<code>get(key)</code>读取对应的<code>Value</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">let map &#x3D; new Map();</span><br><span class="line">map.set(obj, &quot;SHUN&quot;);</span><br><span class="line"></span><br><span class="line">console.log(map.get(obj));	&#x2F;&#x2F;&quot;SHUN&quot;</span><br><span class="line">console.log(map.get(&#123; name: &quot;Ashun&quot; &#125;));&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>



<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>使用<code>size</code>属性，查看Map的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">        [&quot;name&quot;, &quot;ashun&quot;],</span><br><span class="line">        [&quot;age&quot;, 18],</span><br><span class="line">]);</span><br><span class="line">console.log(map.size); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>





<h3 id="节点集合"><a href="#节点集合" class="headerlink" title="节点集合"></a>节点集合</h3><p>map的key可以为任意类型，下面使用DOM节点做为键来记录DOM的desc属性。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div desc=&quot;阿顺特烦恼&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">	&lt;div desc=&quot;阿顺&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const divs = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">	let map = new Map();</span><br><span class="line"></span><br><span class="line">		divs.forEach((elem) =&gt; &#123;</span><br><span class="line">			map.set(elem, &#123; desc: elem.getAttribute(&quot;desc&quot;) &#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">		map.forEach((val, elem) =&gt; &#123;</span><br><span class="line">			elem.addEventListener(&quot;click&quot;, (_) =&gt; &#123;</span><br><span class="line">				alert(val.desc);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><p>当不接受协议、不符合条件时无法提交表单，并根据自定义信息提示用户。</p>
<ul>
<li>以下代码巧妙之处在于：灵活的转化了数据类型，利用数组的<code>every</code>方法返回的Boolean，判断是否满足所有条件，如果有一个不满足，返回false，表单数据也就不会提交。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">		&lt;form action=&quot;#&quot; onsubmit=&quot;return commmit()&quot;&gt;</span><br><span class="line">      &lt;label&gt;&lt;input type=&quot;checkbox&quot; message=&quot;请接受协议&quot; /&gt;接受&lt;/label&gt;</span><br><span class="line">      &lt;label&gt;&lt;input type=&quot;checkbox&quot; message=&quot;本网站只对学生开放&quot; /&gt;学生&lt;/label&gt;</span><br><span class="line">      &lt;button&gt;commit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> function commmit() &#123;</span><br><span class="line">        let map = new Map();</span><br><span class="line">        let checkboxs = document.querySelectorAll(&quot;[type=&#x27;checkbox&#x27;]&quot;);</span><br><span class="line">        checkboxs.forEach((v) =&gt; &#123;</span><br><span class="line">          map.set(v, &#123;message:v.getAttribute(&quot;message&quot;),isSelect:v.checked&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">       return [...map].every((item,index)=&gt;&#123;</span><br><span class="line">         let [elem,obj]=item;</span><br><span class="line">         obj.isSelect||alert(obj.message);</span><br><span class="line">         return obj.isSelect</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><strong>WeakMap</strong> 对象是一组键/值对的集</p>
<ul>
<li><p>键名必须是对象</p>
</li>
<li><p>WeaMap对<code>键名</code>是<code>弱引用</code>的，<code>键值</code>是<code>正常引用</code></p>
</li>
<li><p>垃圾回收不考虑WeaMap的<code>键名</code>，不会改变引用计数器，键在其他地方不被引用时即删除</p>
</li>
<li><p><strong>不可迭代</strong>，因为WeakMap 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach( )</code>遍历等操作</p>
</li>
<li><p>也是因为弱引用，WeaMap 结构没有keys( )，values( )，entries( )等方法和 size 属性</p>
</li>
<li><p>当键的外部引用删除时，希望自动删除数据时使用 <code>WeakMap</code></p>
</li>
</ul>
<h4 id="声明定义-1"><a href="#声明定义-1" class="headerlink" title="声明定义"></a>声明定义</h4><p>以下操作由于键不是对象类型将产生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new WeakMap([[&quot;ashun&quot;, &quot;tefannao&quot;]]); // TypeError: Invalid value used as weak map key</span><br></pre></td></tr></table></figure>

<p>将DOM节点保存到<code>WeakMap</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;ashuntefannao.com&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;Ashun&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const Wmap = new WeakMap();</span><br><span class="line">  document.querySelectorAll(&quot;div&quot;).forEach(item =&gt; Wmap.set(item, item.innerHTML));</span><br><span class="line">  console.log(as); //WeakMap &#123;div =&gt; &quot;ashuntefannao.com&quot;, div =&gt; &quot;Ashun&quot;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>下面是WeakMap的常用指令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const Wmap = new WeakMap();</span><br><span class="line">const arr = [&quot;ashun&quot;];</span><br><span class="line">//添加操作</span><br><span class="line">Wmap.set(arr, &quot;Ashuntefannao&quot;);</span><br><span class="line">console.log(Wmap.has(arr)); //true</span><br><span class="line"></span><br><span class="line">//删除操作</span><br><span class="line">Wmap.delete(arr);</span><br><span class="line"></span><br><span class="line">//检索判断</span><br><span class="line">console.log(Wmap.has(arr)); //false</span><br></pre></td></tr></table></figure>



<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>WakeMap的键名对象不会增加引用计数器，如果一个对象不被引用了会自动删除。</p>
<ul>
<li>下例当<code>as</code>删除时内存即清除，因为WeakMap是弱引用不会产生引用计数</li>
<li>当垃圾回收时因为对象被删除，这时WakeMap也就<code>没有记录了</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let map = new WeakMap();</span><br><span class="line">let as = &#123;&#125;;</span><br><span class="line">map.set(as, &quot;Ashun&quot;);</span><br><span class="line">as = null;</span><br><span class="line">console.log(map);		//WeakMap &#123;&#123;…&#125; =&gt; &quot;Ashun&quot;&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(map);	//WeakMap &#123;&#125;</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="选课案例"><a href="#选课案例" class="headerlink" title="选课案例"></a>选课案例</h4><img src="Map.assets/WeakMap.gif" alt="WeakMap.gif" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        width: 80%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-around;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: #eee;</span><br><span class="line">      &#125;</span><br><span class="line">      .left,</span><br><span class="line">      .right &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      .left &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">      .right &#123;</span><br><span class="line">        width: 43%;</span><br><span class="line">      &#125;</span><br><span class="line">      .l_top,</span><br><span class="line">      .r_top &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #0984e3;</span><br><span class="line">        color: white;</span><br><span class="line">        line-height: 30px;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">      ul,</span><br><span class="line">      .listBox &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        background-color: white;</span><br><span class="line">      &#125;</span><br><span class="line">      .listBox &#123;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        padding-bottom: 8px;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &#123;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        list-style: none;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &gt; li &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        display: grid;</span><br><span class="line">        grid-template-columns: 85% 15%;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &gt; li:nth-of-type(n + 2) &#123;</span><br><span class="line">        border-top: 2px solid #eee;</span><br><span class="line">      &#125;</span><br><span class="line">      .txt &#123;</span><br><span class="line">        padding: 10px 0px;</span><br><span class="line">      &#125;</span><br><span class="line">      .btn &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        margin: 2px 0px;</span><br><span class="line">        transition: 0.8s;</span><br><span class="line">      &#125;</span><br><span class="line">      .delete &#123;</span><br><span class="line">        background-color: #eb4d4b;</span><br><span class="line">      &#125;</span><br><span class="line">      .add &#123;</span><br><span class="line">        background-color: #6ab04c;</span><br><span class="line">      &#125;</span><br><span class="line">      .delete::before &#123;</span><br><span class="line">        content: &quot;-&quot;;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: #fff;</span><br><span class="line">      &#125;</span><br><span class="line">      .add::before &#123;</span><br><span class="line">        content: &quot;+&quot;;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: #fff;</span><br><span class="line">      &#125;</span><br><span class="line">      .list_item &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        padding: 3px 10px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        background-color: #00cec9;</span><br><span class="line">        margin: 8px 5px 0px 3px;</span><br><span class="line">        color: white;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;main&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;l_top&quot;&gt;课程列表&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;course&quot;&gt;</span><br><span class="line">          &lt;li class&#x3D;&quot;course_item&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;txt&quot;&gt;CSS3&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;btn add&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li class&#x3D;&quot;course_item&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;txt&quot;&gt;HTML5&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;btn add&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li class&#x3D;&quot;course_item&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;txt&quot;&gt;JavaScript&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;btn add&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li class&#x3D;&quot;course_item&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;txt&quot;&gt;Node.js&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;btn add&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;r_top&quot;&gt;共选了&lt;span class&#x3D;&quot;count&quot;&gt;0&lt;&#x2F;span&gt;门课程&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;article class&#x3D;&quot;listBox&quot;&gt;&lt;&#x2F;article&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Lesson &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">          this.course &#x3D; document.querySelectorAll(&quot;.course_item&quot;);</span><br><span class="line">          this.countDom &#x3D; document.querySelector(&quot;.count&quot;);</span><br><span class="line">          this.listBox &#x3D; document.querySelector(&quot;.listBox&quot;);</span><br><span class="line">          this.Wmap &#x3D; new WeakMap();</span><br><span class="line">          this.run();</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">          this.course.forEach((li, index) &#x3D;&gt; &#123;</span><br><span class="line">            let btn &#x3D; li.querySelector(&quot;.btn&quot;);</span><br><span class="line"></span><br><span class="line">            btn.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">              let isSelect &#x3D; btn.classList.contains(&quot;add&quot;);</span><br><span class="line">              if (isSelect) &#123;</span><br><span class="line">                btn.classList.remove(&quot;add&quot;);</span><br><span class="line">                btn.classList.add(&quot;delete&quot;);</span><br><span class="line">                this.Wmap.set(li, true);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                btn.classList.remove(&quot;delete&quot;);</span><br><span class="line">                btn.classList.add(&quot;add&quot;);</span><br><span class="line">                this.Wmap.delete(li);</span><br><span class="line">              &#125;</span><br><span class="line">              this.UpDate();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        UpDate() &#123;</span><br><span class="line">          this.listBox.innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">          let selectArr &#x3D; [...this.course].filter((v) &#x3D;&gt; this.Wmap.has(v));</span><br><span class="line">          selectArr.forEach((li) &#x3D;&gt; &#123;</span><br><span class="line">            let span &#x3D; document.createElement(&quot;span&quot;);</span><br><span class="line">            span.classList.add(&quot;list_item&quot;);</span><br><span class="line">            span.innerText &#x3D; li.querySelector(&quot;.txt&quot;).innerText;</span><br><span class="line">            this.listBox.append(span);</span><br><span class="line">          &#125;);</span><br><span class="line">          this.newCount(selectArr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        newCount(newNum) &#123;</span><br><span class="line">          this.countDom.innerText &#x3D; newNum;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      new Lesson();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>Set</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Set/</url>
    <content><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>new Set([item1,item2,…])</code>用于存储任何类型的<font color="#f39c12">唯一值</font >，无论是基本类型还是对象引用。</p>
<ul>
<li>以数组的形式，传入各个参数。使用<code>[]</code>包裹。</li>
<li>只能保存值<code>没有键名</code></li>
<li>严格类型检测<code>===</code>：如字符串数字不等于数值型数字</li>
<li>值是<font color="#f39c12">唯一</font>的，不重复的。</li>
<li>遍历顺序是添加的顺序，方便保存回调函数</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>特性的体现</strong></p>
<p>没有键名，通过迭代，keys、entries，返回的键值就是<code>value值</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([1, &quot;1&quot;, 1]);</span><br><span class="line">console.log(set.keys());		&#x2F;&#x2F;SetIterator &#123;1, &quot;1&quot;&#125;</span><br><span class="line">console.log(set.values());	&#x2F;&#x2F;SetIterator &#123;1, &quot;1&quot;&#125;</span><br><span class="line">console.log(set.entries());	&#x2F;&#x2F;SetIterator &#123;1 &#x3D;&gt; 1, &quot;1&quot; &#x3D;&gt; &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>值是唯一的，会自动剔除重复元素。判断重复的标准：是否严格类型等与<code>===</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([1, &quot;1&quot;, 1]);</span><br><span class="line">console.log(set);		&#x2F;&#x2F;Set(2) &#123;1, &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序是添加元素的顺序，Set可以使用<code>forEach</code>遍历。<font size="2">Set为可迭代数据类型，也可使用<font size="2" color="#f39c12">for/of</font>遍历</font>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set();</span><br><span class="line">set.add(&quot;Ashun&quot;);</span><br><span class="line">set.add(&quot;1&quot;);</span><br><span class="line">set.add(&quot;阿顺&quot;);</span><br><span class="line">set.add(1);</span><br><span class="line">set.forEach((v) &#x3D;&gt; console.log(v));&#x2F;&#x2F; Ashun &quot;1&quot; 阿顺 1</span><br></pre></td></tr></table></figure>

<h3 id="管理Set"><a href="#管理Set" class="headerlink" title="管理Set"></a>管理Set</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>通过<code>add(item)</code>方法，向Set添加元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set();</span><br><span class="line">set.add(&quot;Ashun&quot;);</span><br><span class="line">console.log(set.values()); &#x2F;&#x2F;SetIterator &#123;&quot;Ashun&quot;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><ul>
<li>通过<code>delete(item)</code>方法，删除Set<code>对应元素</code>。</li>
<li>返回值为<code>boolean</code>类型，删除成功：<code>true</code>，没有该元素:<code>false</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; new Set();</span><br><span class="line">as.add(&quot;ashun&quot;);</span><br><span class="line">as.add(&quot;Ashun&quot;);</span><br><span class="line"></span><br><span class="line">console.log(as.delete(&quot;ashun&quot;)); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">console.log(as.values());</span><br><span class="line">console.log(as.has(&quot;ashun&quot;)); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>通过<code>clear()</code>方法，<code>清空</code>Set。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([&quot;Ashun&quot;, &quot;ashun&quot;, &quot;Controller&quot;]);</span><br><span class="line">set.clear();</span><br><span class="line">console.log(set);	&#x2F;&#x2F;Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>通过<code>size</code>属性，获取Set的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([&#39;阿顺&#39;, &#39;ASHUN&#39;]);</span><br><span class="line">console.log(set.size); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>



<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul>
<li>可在遍历的过程中，操作数据<code>但不会更改Set的数据</code>。</li>
<li>可使用<code>forEach</code>遍历Set</li>
<li>Set为可迭代数据类型，也可使用<code>for/of</code>遍历。</li>
</ul>
<p>在遍历过程中操作Set元素，但是<code>不会更改Set本身</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([&quot;Ashun&quot;, &quot;ashun&quot;, &quot;Controller&quot;]);</span><br><span class="line"></span><br><span class="line">for (var val of set) &#123;</span><br><span class="line">	val &#x3D; val &#x3D;&#x3D; &quot;ashun&quot; ? &quot;阿顺&quot; : val;</span><br><span class="line">	console.log(val);		&#x2F;&#x2F;Ashun 阿顺 Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(set);	&#x2F;&#x2F;Set(3) &#123;&quot;Ashun&quot;, &quot;ashun&quot;, &quot;Controller&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可以定义新的Set，接收操作后的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([&quot;Ashun&quot;, &quot;ashun&quot;, &quot;Controller&quot;]);</span><br><span class="line">let newSet &#x3D; new Set();</span><br><span class="line"></span><br><span class="line">for (var val of set) &#123;</span><br><span class="line">	val &#x3D; val &#x3D;&#x3D; &quot;ashun&quot; ? &quot;阿顺&quot; : val;</span><br><span class="line">	newSet.add(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(newSet);&#x2F;&#x2F;Set(3) &#123;&quot;Ashun&quot;, &quot;阿顺&quot;, &quot;Controller&quot;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="has"><a href="#has" class="headerlink" title="has"></a>has</h4><p>通过<code>has(item)</code>属性，判断该元素是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; new Set();</span><br><span class="line">as.add(&#39;SHUN&#39;);</span><br><span class="line">console.log(as.has(&#39;SHUN&#39;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h3><p>String去重。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log([...new Set(str)].join(&quot;&quot;)); &#x2F;&#x2F;Ashuntefao</span><br></pre></td></tr></table></figure>

<p>Array去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[1,2,3,3,4,5];</span><br><span class="line">console.log([...new Set(arr)]);	&#x2F;&#x2F;[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<h3 id="实例体验"><a href="#实例体验" class="headerlink" title="实例体验"></a>实例体验</h3><p>实现搜索框<code>可排除重复内容</code>。</p>
<img src="Set.assets/Set.gif" alt="Set.gif" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;HTML</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;main&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;search&quot; &#x2F;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">        &lt;ul&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;CSS</span><br><span class="line">* &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      input &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      .list &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        list-style: none;</span><br><span class="line">        transition: 0.3s;</span><br><span class="line">        transform-origin: top center;</span><br><span class="line">        transform: scale(0);</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        border-radius: 7px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">      .active &#123;</span><br><span class="line">        transform: scale(1);</span><br><span class="line">      &#125;</span><br><span class="line">      li &#123;</span><br><span class="line">        min-height: 30px;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        color: white;</span><br><span class="line">      &#125;</span><br><span class="line">      li:nth-of-type(2n) &#123;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JavaScript</span><br><span class="line"></span><br><span class="line">let input &#x3D; document.querySelector(&quot;input&quot;);</span><br><span class="line">let ul &#x3D; document.querySelector(&quot;ul&quot;);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">	words: new Set(),</span><br><span class="line">	add(val) &#123;</span><br><span class="line">		input.value !&#x3D; &quot;&quot; &amp;&amp; this.words.add(val);</span><br><span class="line">	&#125;,</span><br><span class="line">	show() &#123;</span><br><span class="line">		ul.innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">		this.words.forEach((v) &#x3D;&gt; &#123;</span><br><span class="line">			let li &#x3D; document.createElement(&quot;li&quot;);</span><br><span class="line">			li.innerHTML &#x3D; v;</span><br><span class="line">			ul.append(li);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">input.addEventListener(&quot;focus&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">	obj.add(input.value);</span><br><span class="line">	obj.show();</span><br><span class="line">	ul.classList.add(&quot;active&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">input.addEventListener(&quot;blur&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">	ul.classList.remove(&quot;active&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="交-并-差集"><a href="#交-并-差集" class="headerlink" title="交,并,差集"></a>交,并,差集</h3><ul>
<li><p>在求并集时，使用Set类型比较简单，直接合并Array传入即可。</p>
</li>
<li><p>但是在求交集、差集时，若使用Set类型解决就比较麻烦，需要先转化为Array类型，再使用filter。</p>
</li>
<li><p>所以灵活、合理的转化数据类型，借助不同类的方法，能够高效的解决问题。</p>
</li>
</ul>
<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>数组解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 4];</span><br><span class="line">let arr1 &#x3D; [1, 2, 3, 5, 6];</span><br><span class="line"></span><br><span class="line">console.log(arr.filter((val, key) &#x3D;&gt; val &#x3D;&#x3D; arr1[key]));</span><br></pre></td></tr></table></figure>

<p>Set类型解决（转为Array，使用filter）e</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">let set1 &#x3D; new Set(arr);</span><br><span class="line">let set2 &#x3D; new Set(arr1);</span><br><span class="line">let newSet &#x3D; new Set([...set1].filter((item) &#x3D;&gt; set2.has(item)));</span><br><span class="line">console.log(newSet); 	&#x2F;&#x2F;Set(2) &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>数组解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 4];</span><br><span class="line">let arr1 &#x3D; [1, 2, 3, 5, 6];</span><br><span class="line"></span><br><span class="line">let subArr &#x3D; arr1.filter((v, i) &#x3D;&gt; v !&#x3D; arr[i]);</span><br><span class="line">let result&#x3D;arr.concat(subArr)</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<p>Set类型解决，直接合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">let set &#x3D; new Set(arr.concat(arr1));</span><br><span class="line">console.log([...set]);</span><br></pre></td></tr></table></figure>



<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>在a中出现，却不在b中出现的元素。</p>
<p>数组解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 4];</span><br><span class="line">let arr1 &#x3D; [1, 2, 3, 5, 6];</span><br><span class="line">console.log(arr1.filter((val, index) &#x3D;&gt; val !&#x3D; arr[index]));</span><br></pre></td></tr></table></figure>

<p>Set类型解决（转为Array，使用filter）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">let set &#x3D; new Set(arr);</span><br><span class="line">let set1 &#x3D; new Set(arr1);</span><br><span class="line">let newSet &#x3D; new Set([...set1].filter((item) &#x3D;&gt; !set.has(item)));</span><br><span class="line"></span><br><span class="line">console.log(newSet); &#x2F;&#x2F;Set(3) &#123;3, 5, 6&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet结构同样不会存储重复的值，它的成员<code>必须只能是引用类型</code>的值。WeakSet是一种<code>弱引用的、不可迭代</code>的数据结构。</p>
<ul>
<li>垃圾回收不用考虑WeakSet，即被WeakSet引用时引用计数器不加一，所以对象不被引用时不管WeakSet是否在使用都将删除</li>
<li><strong>不可迭代</strong>，因为WeakSet 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach()</code>遍历等操作</li>
<li>也是因为弱引用，WeakSet 结构没有keys( )，values( )，entries( )等方法和size属性</li>
<li>因为是弱引用，所以当外部的引用删除时，希望自动删除数据时使用 <code>WeakSet</code></li>
</ul>
<h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>以下操作由于数据不是对象类型将产生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new WeakSet(&quot;Ashun&quot;); //Invalid value used in weak set</span><br><span class="line">new WeakSet([&quot;as&quot;, &quot;Ashun&quot;]); //Invalid value used in weak set</span><br><span class="line"></span><br><span class="line">//传参的形式必须是数组形式，使用[]包裹各个items</span><br></pre></td></tr></table></figure>

<p>WeakSet的值必须为<code>引用类型</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new WeakSet([[&quot;Ashun&quot;], [&quot;Ashun1&quot;]]);</span><br><span class="line">new WeakSet([&#123;name:&quot;Ashun&quot;&#125;,&#123;name:&quot;ES6&quot;&#125;]);</span><br></pre></td></tr></table></figure>

<p>将DOM节点保存到<code>WeakSet</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">document.querySelectorAll(&quot;button&quot;).forEach(item =&gt; Wset.add(item));</span><br></pre></td></tr></table></figure>



<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>下面是WeakSet的常用指令:</p>
<ul>
<li><code>add(item)</code></li>
<li><code>delete(item)</code></li>
<li><code>has(item)</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = new WeakSet();</span><br><span class="line">const arr = [&quot;Ashun&quot;];</span><br><span class="line">//添加操作</span><br><span class="line">as.add(arr);</span><br><span class="line">console.log(as.has(arr));</span><br><span class="line"></span><br><span class="line">//删除操作</span><br><span class="line">as.delete(arr);</span><br><span class="line"></span><br><span class="line">//检索判断</span><br><span class="line">console.log(as.has(arr));</span><br></pre></td></tr></table></figure>



<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>WeaSet保存的引用类型<code>不会增加</code>引用计数器，如果一个对象不被引用了会自动删除。</p>
<ul>
<li>下例中的数组被 <code>arr</code> 引用了，引用计数器+1</li>
<li>数据又添加到了 as 的WeaSet中，引用计数还是1</li>
<li>当 <code>arr</code> 设置为null时，引用计数-1 此时对象引用为0</li>
<li>当垃圾回收时对象被删除，这时WakeSet也就没有记录了</li>
</ul>
<p><strong>什么是垃圾回收？</strong></p>
<p>​    大部分语言都有自身的垃圾回收机制，因为在语言中定义的各种变量，都会占用系统的内存。在JS中，如果一个对象不再被任何变量引用，则为无用的垃圾，JS引擎就会将其删除，释放内存空间。</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p> 普通的赋值，为强引用。</p>
<ul>
<li>a引用了obj，引用计数器+1</li>
<li>b通过a引用了obj，引用计数器+1</li>
<li>WeakSet引用了obj，引用计数器<code>不计数</code>,（弱引用）</li>
<li>a清除了对obj的引用，引用计数器-1</li>
<li>但是b并没有清除对obj的引用，引用计数器值为1，还可获取到obj的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">let b &#x3D; a;</span><br><span class="line">let wset &#x3D; new WeakSet();</span><br><span class="line">wset.add(a);</span><br><span class="line">a &#x3D; null;</span><br><span class="line">console.log(b);	&#x2F;&#x2F;&#123;name:&quot;Ashun&quot;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><ul>
<li>当没有变量引用obj时，JS内部就会进行垃圾回收，删除obj。</li>
<li>但垃圾回收不用考虑<code>WeakSet</code>，WeakSet对obj的弱引用，系统的引用计数器<code>不会+1</code>,所以当其它变量不再引用obj时，过一段时间系统会自动清除WeakSet中对应的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">let wSet &#x3D; new WeakSet();</span><br><span class="line"></span><br><span class="line">wSet.add(a);</span><br><span class="line">b &#x3D; a;</span><br><span class="line">a &#x3D; null;</span><br><span class="line">console.log(wSet);		&#x2F;&#x2F;WeakSet &#123;&#123; name: &quot;Ashun&quot; &#125;&#125;</span><br><span class="line">b &#x3D; null;</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">	console.log(wSet);	&#x2F;&#x2F;WeakSet &#123;&#125;</span><br><span class="line">&#125;, 6000);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="案例操作"><a href="#案例操作" class="headerlink" title="案例操作"></a>案例操作</h5><p><code>使用WeakSet管理TODO</code></p>
<img src="Set.assets/WeakSet.gif" alt="WeakSet.gif" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      input &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        transition: 0.8s;</span><br><span class="line">      &#125;</span><br><span class="line">      .list &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        list-style: none;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        border-radius: 7px;</span><br><span class="line">      &#125;</span><br><span class="line">      ul &gt; li &#123;</span><br><span class="line">        transition: 0.8s;</span><br><span class="line">        height: 30px;</span><br><span class="line">        margin-top: 8px;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: row;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">      input &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">        outline: none;</span><br><span class="line">        border: none;</span><br><span class="line">        margin-left: 2px;</span><br><span class="line">      &#125;</span><br><span class="line">      span &#123;</span><br><span class="line">        transition: 0.8s;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        width: 25px;</span><br><span class="line">        background: yellowgreen;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        color: white;</span><br><span class="line">      &#125;</span><br><span class="line">      li.delete &#123;</span><br><span class="line">        color: #ddd;</span><br><span class="line">        border: 1px solid #ddd;</span><br><span class="line">      &#125;</span><br><span class="line">      .delete &gt; span &#123;</span><br><span class="line">        background-color: #ddd;</span><br><span class="line">      &#125;</span><br><span class="line">      .delete &gt; input &#123;</span><br><span class="line">        color: #ddd;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;main&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;&lt;input type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;span&gt;×&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">			&lt;li&gt;&lt;input type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;span&gt;×&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">			&lt;li&gt;&lt;input type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;span&gt;×&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;&#x2F;ul&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Todo &#123;</span><br><span class="line">        constructor(listClass) &#123;</span><br><span class="line">          this.listDom &#x3D; document.querySelectorAll(listClass);</span><br><span class="line">          this.WSetList &#x3D; new WeakSet();</span><br><span class="line">          this.links &#x3D; [];</span><br><span class="line">          this.run();</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">          this.init();</span><br><span class="line">          console.log(this.WSetList);</span><br><span class="line">          this.addEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        init() &#123;</span><br><span class="line">          &#x2F;&#x2F;初始化，存储dom，</span><br><span class="line">          this.listDom.forEach((v) &#x3D;&gt; &#123;</span><br><span class="line">            this.WSetList.add(v);</span><br><span class="line">            this.links.push(v.querySelector(&quot;span&quot;));</span><br><span class="line">          &#125;);</span><br><span class="line">          console.log(this.links);</span><br><span class="line">        &#125;</span><br><span class="line">        addEvent() &#123;</span><br><span class="line">          &#x2F;&#x2F;添加事件</span><br><span class="line">          this.links.forEach((v) &#x3D;&gt;</span><br><span class="line">            v.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">              let parent &#x3D; e.target.parentElement;</span><br><span class="line">              if (!this.WSetList.has(parent)) &#123;</span><br><span class="line">                alert(&quot;已经删除此TODO&quot;);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                parent.classList.add(&quot;delete&quot;);</span><br><span class="line">                this.WSetList.delete(parent);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      new Todo(&quot;li&quot;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>Symbol</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Symbol/</url>
    <content><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol用于防止属性名冲突而产生的，比如向第三方对象中添加属性时。</p>
<p>Symbol 的值是唯一的，独一无二的不会重复的</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>Symbol</code>是一个基本类型，<code>没有构造函数</code>所以也就不能通过<code>new</code>关键字来进行实例化。而是直接使用<code>Symbol()</code>声明。既然其没有构造函数，所以不能够使用<code>instanceof</code>判断类型。可以使用typeof判断类型。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol();</span><br><span class="line">let edu = Symbol();</span><br><span class="line">console.log(as); //Symbol()</span><br><span class="line">console.log(as == edu); //false</span><br><span class="line"></span><br><span class="line">console.log(typeof as); //symbol</span><br></pre></td></tr></table></figure>

<p>Symbol 不可以添加属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol();</span><br><span class="line">as.name = &quot;ashun&quot;;</span><br><span class="line">console.log(as.name); //undefined</span><br></pre></td></tr></table></figure>

<h4 id="描述参数"><a href="#描述参数" class="headerlink" title="描述参数"></a>描述参数</h4><p>可传入字符串用于描述Symbol，方便在控制台分辨Symbol</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol(&quot;ashun&quot;);</span><br><span class="line">let sy = Symbol(&quot;Ashuntefannao&quot;);</span><br><span class="line"></span><br><span class="line">console.log(as); //Symbol(ashun)</span><br><span class="line">console.log(sy.toString()); //Symbol(Ashuntefannao)</span><br></pre></td></tr></table></figure>

<p>传入相同参数Symbol也是独立唯一的，因为参数只是描述而已，但使用 <code>Symbol.for</code>则不会</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let symbol1 = Symbol(&quot;ashun&quot;);</span><br><span class="line">let symbol2 = Symbol(&quot;ashun&quot;);</span><br><span class="line">console.log(symbol1 == symbol2); //false</span><br></pre></td></tr></table></figure>

<p>使用<code>description</code>可以获取传入的描述参数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.description); //阿顺</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h4><p>根据描述获取Symbol，如果不存在则新建一个Symbol</p>
<ul>
<li>使用Symbol.for会在系统中将Symbol登记</li>
<li>使用Symbol则不会登记</li>
</ul>
<p>由于Symbol.for会使得系统对Symbol做记录，所以只要<code>描述相同</code>，引用的就是同一个内存地址，即恒等。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol.for(&quot;ashun&quot;);</span><br><span class="line">let zs = Symbol.for(&quot;ashun&quot;);</span><br><span class="line">console.log(as === zs); //true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; Symbol.for();</span><br><span class="line">let zs &#x3D; Symbol.for();</span><br><span class="line">console.log(as &#x3D;&#x3D;&#x3D; zs); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h4><p><code>Symbol.keyFor(Symbol.for())</code> 根据使用<code>Symbol.for</code>登记的Symbol返回描述，如果找不到返回undefined 。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Symbol.for(&quot;ashun&quot;);</span><br><span class="line">console.log(Symbol.keyFor(as));//ashun</span><br><span class="line">console.log(Symbol.keyFor(Symbol.for()));//undefined</span><br><span class="line"></span><br><span class="line">let symbol=Symbol(&quot;Ashun&quot;);</span><br><span class="line">console.log(Symbol.keyFor(symbol))//undefined</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="设置obj属性"><a href="#设置obj属性" class="headerlink" title="设置obj属性"></a>设置obj属性</h4><p>Symbol 是独一无二的所以可以保证对象属性的唯一。</p>
<ul>
<li>Symbol 变量在作为对象属性声明和访问时，使用 <code>[]</code>（变量）形式操作</li>
<li>也不能使用 <code>.</code> 语法因为 <code>.</code>语法是操作字符串属性的。</li>
</ul>
<p>下面写法是错误的，会将<code>symbol</code> 当成字符串<code>symbol</code>处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let symbol = Symbol(&quot;ashun&quot;);</span><br><span class="line">let obj = &#123;</span><br><span class="line">	symbol: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);//&#123;symbol: &quot;Ashuntefannao.com&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>正确写法是以<code>[]</code> 变量形式声明和访问</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let symbol = Symbol(&quot;ashun&quot;);</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [symbol]: &quot;Ashuntefannao.com&quot;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);//&#123;Symbol(ashun): &quot;Ashuntefannao.com&quot;&#125;</span><br><span class="line">console.log(obj[symbol]); //Ashuntefannao.com</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><h5 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a><strong>缓存操作</strong></h5><p>使用<code>Symbol</code>可以解决在保存数据时由于名称相同造成的耦合覆盖问题。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Cache &#123;</span><br><span class="line">	static data = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	static get(key) &#123;</span><br><span class="line">		return data[key];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static set(val, key) &#123;</span><br><span class="line">		this.data[key] = val;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#123;</span><br><span class="line">	name: &quot;Ashun&quot;,</span><br><span class="line">	type: &quot;Controller&quot;,</span><br><span class="line">	key: Symbol(&quot;用户&quot;),</span><br><span class="line">&#125;;</span><br><span class="line">let cart = &#123;</span><br><span class="line">	name: &quot;ShoppingCart&quot;,</span><br><span class="line">	type: &quot;store&quot;,</span><br><span class="line">	key: Symbol(&quot;购物车&quot;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cache.set(user, user.key);</span><br><span class="line">Cache.set(cart, cart.key);</span><br><span class="line">console.log(Cache.data[Symbol(&quot;用户&quot;)]);	//undefined</span><br><span class="line">console.log(Cache.data[user.key]);		//&#123;name: &quot;Ashun&quot;, type: &quot;Controller&quot;, key: Symbol(用户)&#125;</span><br></pre></td></tr></table></figure>



<h5 id="遍历属性"><a href="#遍历属性" class="headerlink" title="遍历属性"></a>遍历属性</h5><p>Symbol作为属性名称：不能使用 <code>for/in</code>、<code>for/of</code> 遍历操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let symbol = Symbol(&quot;ashun&quot;);</span><br><span class="line">let obj = &#123;</span><br><span class="line">	 name: &quot;Ashun&quot;,</span><br><span class="line">	 type: &quot;Controller&quot;,</span><br><span class="line">	 [symbol]: &quot;Ashuntedannao.com&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let key in obj) &#123;</span><br><span class="line">console.log(key);   //name type</span><br><span class="line">&#125;</span><br><span class="line">for (let val of Object.values(obj)) &#123;</span><br><span class="line">console.log(val);		//Ashun Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>Object.getOwnPropertySymbols</code> 获取所有<code>Symbol</code>属性</p>
<ul>
<li><code>Object.getOwnPropertySymbols</code>返回的是一个包含所有Symbol类型属性名的Array</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">for (const key of Object.getOwnPropertySymbols(obj)) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertySymbols(obj));</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>Reflect.ownKeys(obj)</code> 获取所有属性包括<code>Symbol</code></p>
<ul>
<li>Reflect.ownKeys(obj)能够映射obj中的所有属性，包括<code>Symbol</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">for (const key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果对象属性不想被遍历，可以使用<code>Symbol</code>类型进行保护</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const site = Symbol(&quot;网站名称&quot;);</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">	this[site] = &quot;阿顺&quot;;</span><br><span class="line">	this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	getName() &#123;</span><br><span class="line">		return `$&#123;this[site]&#125;--$&#123;this.name&#125;`;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;Ashuntefannao.com&quot;);</span><br><span class="line">console.log(user.getName());</span><br><span class="line"></span><br><span class="line">for (let key in user) &#123;</span><br><span class="line">		console.log(key); //name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>任务轮询</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E8%BD%AE%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="任务轮询"><a href="#任务轮询" class="headerlink" title="任务轮询"></a>任务轮询</h2><p>JavaScript 语言的一大特点就是单线程，也就是说同一个时间只能处理一个任务。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，（事件循环）Event Loop方案营运而生。</p>
<p>JavaScript 处理任务是在等待任务、执行任务 、休眠等待新任务中不断循环中，也称这种机制为事件循环。</p>
<ul>
<li>主线程中的任务(同步代码)执行完后，才执行任务队列中的任务(异步代码)</li>
<li>有新任务到来时会将其放入队列，采取先进先执行的策略执行队列中的任务</li>
<li>比如多个 <code>setTimeout</code> 同时到时间了，就要依次执行</li>
</ul>
<p>任务包括 script(整体代码)、 setTimeout、setInterval、DOM渲染、DOM事件、Promise、XMLHTTPREQUEST等</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ul>
<li>立即执行主线程同步代码</li>
<li>所有主线程同步代码执行完毕后，先轮询异步微任务队列，将其中的微任务依次添加到主线程并执行。</li>
<li>微任务队列为空，轮询异步宏任务队列，将其中的异步宏任务依次添加到主线程并执行</li>
<li>所有的任务都是在主线程中执行的</li>
</ul>
<p>下面通过一个例子来详细分析宏任务与微任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Promise中的同步代码&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then((_) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise.then1&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((_) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise.then2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line"></span><br><span class="line"># 执行结果</span><br><span class="line">Ashuntefannao</span><br><span class="line">Promise中的同步代码</span><br><span class="line">阿顺特烦恼</span><br><span class="line">Promise.then1</span><br><span class="line">Promise.then2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<ol>
<li>立即执行最前面的主线程同步代码，打印结果</li>
<li>执行setTimeout，将其放入异步宏任务队列</li>
<li>立即执行后续同步代码，在Promise中</li>
<li>执行到第一个then，将其放入到异步微任务队列中</li>
<li>执行到第二个then，将其放入到异步微任务队列中</li>
<li>立即执行末尾的主线程同步代码，打印结果</li>
<li>所有主线程同步代码执行完毕，在微任务队列中取出第一个then代码块，放入主线程并执行</li>
<li>主线程同步代码执行完毕，继续轮询微任务队列，取出第二个then代码块并执行。</li>
<li>主线程代码执行完毕，微任务队列为空，轮询异步宏任务队列</li>
<li>取出setTimeout中的代码块，放入主线程，并执行</li>
<li>主线程同步代码执行完毕，微任务队列为空，异步宏任务队列为空</li>
</ol>
<img src="任务轮询.assets/EventLoop_1.png" alt="EventLoop_1" style="zoom:65%;" />



<h3 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h3><p>引擎在执行任务时不会进行DOM渲染，所以如果把<code>script</code> 定义在前面，要先执行完任务后再渲染DOM。</p>
<p>解决:</p>
<ol>
<li>将<code>script</code> 放在 BODY 结束标签前。</li>
<li>为<code>script</code>标签添加<code>type=&quot;module&quot;</code>,也会延迟解析执行</li>
<li>为<code>script</code>标签添加<code>defer=&quot;defer&quot;</code>属性</li>
<li>为<code>script</code>标签添加<code>async=&quot;async&quot;</code>属性</li>
</ol>
<ul>
<li><code>defer/async</code>属性，只对外部脚本引入生效，多次使用该属性引入其它外部脚本，不能够保证先后顺序，若引入的多个脚本之间存在依赖关系，需要注意。</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器会放入异步宏任务队列，需要等待同步任务、异步微任务执行完成后执行。</p>
<p>下面设置了 6 毫秒执行，如果主线程代码执行10毫秒，定时器要等主线程执行完才执行。</p>
<p>HTML标准规定最小时间不能低于4毫秒，有些异步操作如DOM操作最低是16毫秒，总之把时间设置大些对性能更好。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setTimeout(func,6);</span><br></pre></td></tr></table></figure>

<p>下面的代码会先输出 <code>Ashuntefannao</code> 之后输出 <code>阿顺特烦恼</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&quot;Ashuntefannao&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务一般由用户代码产生，微任务较宏任务执行优先级更高，<code>Promise.then</code> 是典型的微任务，实例化 Promise 时执行的代码是同步的，then注册的回调函数是异步微任务。</p>
<p>任务的执行顺序是同步任务、微任务、宏任务所以下面执行结果是 <code>1、2、3、4</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; console.log(4));</span><br><span class="line"></span><br><span class="line">new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;).then(_ &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br></pre></td></tr></table></figure>

<p>我们再来看下面稍复杂的任务代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;定时器&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;timeout timeout&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&quot;settimeout Promise&quot;);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;settimeout then&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&quot;Promise&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;then&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Promise</span><br><span class="line">阿顺特烦恼</span><br><span class="line">then</span><br><span class="line">定时器</span><br><span class="line">settimeout Promise</span><br><span class="line">settimeout then</span><br><span class="line">timeout timeout</span><br></pre></td></tr></table></figure>



<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><p>下面的定时器虽然都定时了一秒钟，但任务队列是按先进先出（先进先执行）原则，依次执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let i = 0;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(++i);</span><br><span class="line">  console.log(&quot;timeout1&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(++i);</span><br><span class="line">  console.log(&quot;timeout2&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">//一秒后打印结果</span><br><span class="line">1</span><br><span class="line">timeout1</span><br><span class="line">2</span><br><span class="line">timeout2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是一个进度条的示例，将每个数字放在一个任务中执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">    .loading &#123;</span><br><span class="line">      height: 30px;</span><br><span class="line">      background: yellowgreen;</span><br><span class="line">      width: 0;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let laodBox=document.querySelector(&quot;.loading&quot;);</span><br><span class="line">  function view() &#123;</span><br><span class="line">    let i = 0;</span><br><span class="line">    (function handle() &#123;</span><br><span class="line">      laodBox.innerHTML = i + &quot;%&quot;;</span><br><span class="line">      laodBox.style.width = i + &quot;%&quot;;</span><br><span class="line">      if (i++ &lt; 100) &#123;</span><br><span class="line">        setTimeout(handle, 20);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">  view();</span><br><span class="line">  console.log(&quot;定时器开始了...&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>一个比较耗时的任务可能造成游览器卡死现象，所以可以将任务拆分为多个异步小任务执行，暂时置于异步任务队列中，当主线程空闲时，在进行任务轮询。下面是一个数字统计的函数，我们会发现运行时间特别长</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        console.time(&quot;runtime&quot;);</span><br><span class="line">        function sub(num) &#123;</span><br><span class="line">          let count = 0;</span><br><span class="line">          for (let i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">            count += i;</span><br><span class="line">          &#125;</span><br><span class="line">          console.log(count);</span><br><span class="line">          console.timeEnd(&quot;runtime&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        let num = 987654321;</span><br><span class="line">        sub(num);</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;); //需要等待上面执行完才会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把任务分解成小块放入任务队列，游览器就不会出现卡死的现象了，也不会影响后续代码的执行</p>
<ul>
<li>执行run时，遇到第一个setTimeout，先将其添加到异步宏任务队列。</li>
<li>后面遇到同步代码，打印结果，又遇到异步宏任务，添加到任务队列中</li>
<li>同步代码执行完毕，取出第一个setTimeout到主线程并执行（运算for循环）</li>
<li>后面遇到同步代码，打印结果，又遇到异步宏任务，添加到任务队列中</li>
<li>同步代码执行完毕，取出第二个setTimeout到主线程并执行（调用run）</li>
<li>以此往复，任务轮询……</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let count = 0;</span><br><span class="line">        let num = 987654321;</span><br><span class="line">        function run() &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            for (let i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">              if (num &lt;= 0) break;</span><br><span class="line">              count += num--;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          if (num &gt; 0) &#123;</span><br><span class="line">            console.log(num);</span><br><span class="line">            setTimeout(run);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            console.log(num);</span><br><span class="line">            console.log(count);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交给微任务处理是更好的选择</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        async function run(num) &#123;</span><br><span class="line">          let res = await Promise.resolve().then((_) =&gt; &#123;</span><br><span class="line">            let count = 0;</span><br><span class="line">            for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">              count += num--;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">          &#125;);</span><br><span class="line">          console.log(res);</span><br><span class="line">        &#125;</span><br><span class="line">        run(987654321);</span><br><span class="line">        console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>作用域与闭包</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域有三种:</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>let\const 与 <code>&#123;&#125;</code> 形成的块级作用域</li>
</ul>
<p>变量引用规则</p>
<ul>
<li>编译器运行时会将变量定义在：当前所在的作用域</li>
<li>使用变量时会从当前作用域开始向上查找变量</li>
<li>作用域就像攀亲亲一样，晚辈总是可以向上辈要些东西</li>
<li>默认请况下：父级作用域不能够访问子级作用域的变量（使用闭包解决），但是子级作用域却可以访问祖先作用域的变量。</li>
</ul>
<h4 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h4><p>​    作用域链只向上查找，找到全局window即终止，应该尽量不要在全局作用域中添加变量。</p>
<p>函数被执行后其环境变量将从内存中删除。下面函数在每次执行后将删除函数内部的total变量。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">  let total = 0;</span><br><span class="line">&#125;</span><br><span class="line">count();</span><br></pre></td></tr></table></figure>

<p>函数<code>每次调用</code>都会创建一个新作用域</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let site = &#x27;阿顺&#x27;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  let as = &#x27;ashuntefannao.com&#x27;;</span><br><span class="line"></span><br><span class="line">  function b() &#123;</span><br><span class="line">      let cms = &#x27;Ashun.com&#x27;;</span><br><span class="line">      console.log(as);</span><br><span class="line">      console.log(site);</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>如果子函数被外部(window作用域)使用时，父级环境将被保留，因此在全局作用域能够<code>间接访问</code>函数内的变量。这就是<code>闭包</code>的特性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function as() &#123;</span><br><span class="line">  let n = 1;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let b = 1;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      console.log(++n);</span><br><span class="line">      console.log(++b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let a = as()();</span><br><span class="line">a(); //2,2</span><br><span class="line">a(); //3,3</span><br></pre></td></tr></table></figure>

<p>构造函数也是很好的环境例子，子函数被外部使用父级环境将被保留。</p>
<p>通过这两个例子可以发现，闭包可以保护某些变量，不被外部直接访问，而是让外部通过接口(子函数、方法)进行间接访问。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;</span><br><span class="line">  let a = 1;</span><br><span class="line">  this.show = function() &#123;</span><br><span class="line">    console.log(a++);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let a = new User();</span><br><span class="line">a.show(); //1</span><br><span class="line">a.show(); //2</span><br><span class="line">let b = new User();</span><br><span class="line">b.show(); //1</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h4><p>使用 <code>let/const</code> 可以将变量声明在块作用域中（放在新的环境中，而不是全局中）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let a = 9;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); //ReferenceError: a is not defined</span><br><span class="line">if (true) &#123;</span><br><span class="line">	var i = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//1</span><br></pre></td></tr></table></figure>

<p>也可以通过下面的定时器函数来体验</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中使用<code>let/const</code> 会在每一次迭代中重新生成不同的变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	arr.push((() =&gt; i));</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr[3]()); //3 如果使用var声明将是10</span><br></pre></td></tr></table></figure>

<p>在没有<code>let/const</code> 的历史中使用以下方式产生作用域</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//自行构建闭包</span><br><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  (function (a) &#123;</span><br><span class="line">      arr.push(()=&gt;a);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr[3]()); //3</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指子函数可以访问外部作用域变量的函数特性，即使在子函数所在的作用域外也可以访问。如果没有闭包那么在处理事件绑定，异步请求时都会变得困难。</p>
<ul>
<li>闭包一般在子函数本身作用域以外执行。</li>
<li>闭包一般的形式：函数套函数，在子函数中使用父级作用域的变量，将子函数return出去。</li>
<li>但闭包的形式并不是固定的，其本质是：**<code>当前作用域块存在对父级作用域块的引用</code>**</li>
</ul>
<h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><p>前面在讲作用域时已经在使用闭包特性了，下面再次重温一下闭包。</p>
<ul>
<li>以下三例代码虽然形式不同，但都实现了内部作用域的变量，间接的让外部访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function first() &#123;</span><br><span class="line">	let a &#x3D; 1;</span><br><span class="line">	return function second() &#123;</span><br><span class="line">		return ++a;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let func &#x3D; first();</span><br><span class="line">console.log(func());&#x2F;&#x2F;2</span><br><span class="line">console.log(func());&#x2F;&#x2F;3</span><br><span class="line">console.log(func());&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function first() &#123;</span><br><span class="line">	let a = 1;</span><br><span class="line">	function second() &#123;</span><br><span class="line">		return ++a;</span><br><span class="line">	&#125;</span><br><span class="line">	window.func = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">console.log(func());//2</span><br><span class="line">console.log(func());//3</span><br><span class="line">console.log(func());//4</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fuc;</span><br><span class="line">function first() &#123;</span><br><span class="line">  let a &#x3D; 0;</span><br><span class="line">  fuc &#x3D; function () &#123;</span><br><span class="line">    console.log(++a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">fuc();</span><br><span class="line">fuc();</span><br></pre></td></tr></table></figure>

<p>使用闭包返回数组区间元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [3, 2, 4, 1, 5, 6];</span><br><span class="line">function between(a, b) &#123;</span><br><span class="line">  return function(v) &#123;</span><br><span class="line">    return v &gt;= a &amp;&amp; v &lt;= b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.filter(between(3, 5)));</span><br></pre></td></tr></table></figure>

<p>下面是在回调函数中使用闭包，当点击按钮时显示当前点击的是第几个按钮。</p>
<ul>
<li>利用立即执行函数创建作用域，形成闭包</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button message=&quot;ashun&quot;&gt;button&lt;/button&gt;</span><br><span class="line">  &lt;button message=&quot;SHUN&quot;&gt;button&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">  for (let i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = (function(i) &#123;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        alert(`点击了第$&#123;i + 1&#125;个按钮`);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用普通函数结合call\apply</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">var btns &#x3D; document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">      for (let i &#x3D; 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">        btns[i].onclick &#x3D; function () &#123;</span><br><span class="line">          return function () &#123;</span><br><span class="line">            alert(&#96;点击了第$&#123;i + 1&#125;个按钮&#96;);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;.call(btns[i], i);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动动画"><a href="#移动动画" class="headerlink" title="移动动画"></a>移动动画</h4><p>计时器中使用闭包来获取独有变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button message=&quot;阿顺&quot;&gt;Ashun&lt;/button&gt;</span><br><span class="line">	&lt;button message=&quot;阿顺特烦恼&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">      btns.forEach(function (elem) &#123;</span><br><span class="line">        let checked = false;</span><br><span class="line">        let L = 0;</span><br><span class="line">        elem.addEventListener(&quot;click&quot;, function () &#123;</span><br><span class="line">          !checked &amp;&amp;</span><br><span class="line">            (checked = setInterval(function () &#123;</span><br><span class="line">              elem.style.marginLeft = ++L + &quot;px&quot;;</span><br><span class="line">            &#125;, 40));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="闭包排序"><a href="#闭包排序" class="headerlink" title="闭包排序"></a>闭包排序</h4><p>下例使用闭包按指定字段排序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;媒体查询响应式布局&quot;,</span><br><span class="line">    click: 89,</span><br><span class="line">    price: 12</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;FLEX 弹性盒模型&quot;,</span><br><span class="line">    click: 45,</span><br><span class="line">    price: 120</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;GRID 栅格系统&quot;,</span><br><span class="line">    click: 19,</span><br><span class="line">    price: 67</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;盒子模型详解&quot;,</span><br><span class="line">    click: 29,</span><br><span class="line">    price: 300</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">function order(field) &#123;</span><br><span class="line">  return (a, b) =&gt; (a[field] &gt; b[field] ? 1 : -1);</span><br><span class="line">&#125;</span><br><span class="line">console.table(lessons.sort(order(&quot;price&quot;)));</span><br></pre></td></tr></table></figure>

<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>闭包特性中上级作用域会为函数保存数据，从而造成的如下所示的内存泄漏问题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div desc=&quot;ashun&quot;&gt;阿顺&lt;/div&gt;</span><br><span class="line">  &lt;div desc=&quot;Ashuntefannao&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let divs = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">  divs.forEach(function(item) &#123;</span><br><span class="line">    item.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">      console.log(item.getAttribute(&quot;desc&quot;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面通过清除不需要的数据解决内存泄漏问题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let divs = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">divs.forEach(function(item) &#123;</span><br><span class="line">  let desc = item.getAttribute(&quot;desc&quot;);</span><br><span class="line">  item.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">    console.log(desc);</span><br><span class="line">  &#125;);</span><br><span class="line">  item = null;		//及时清空引用。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>基础知识</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="一、关于变量"><a href="#一、关于变量" class="headerlink" title="一、关于变量"></a>一、关于变量</h3><h4 id="1-1-弱类型"><a href="#1-1-弱类型" class="headerlink" title="1.1 弱类型"></a>1.1 弱类型</h4><p>​    JavaScript是一种弱类型语言，声明变量时不用指定变量的类型，变量类型由赋予的值所决定。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var web = &quot;ashun.com&quot;;</span><br><span class="line">console.log(typeof web); //string</span><br><span class="line">web = 99;</span><br><span class="line">console.log(typeof web); //number</span><br><span class="line">web = &#123;&#125;;</span><br><span class="line">console.log(typeof web); //object</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-变量提升"><a href="#1-2-变量提升" class="headerlink" title="1.2 变量提升"></a>1.2 变量提升</h4><p>​    代码在执行前会进行预解析，会把var形式的变量的声明提升到当前作用域(window、function)最前。</p>
<p>预解析示例:</p>
<p>​    我们知道<code>while</code>是js的关键字，是不能够作为变量名称的，下面代码在解析过程中发现<code>while</code>不能做为变量名，没有到执行环节就出错了，这是一个很好的预解析过程的体验。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">var web = &#x27;ashun&#x27;;</span><br><span class="line">console.log(web);</span><br><span class="line">let while = &#x27;ashuntefannao&#x27;; //Uncaught SyntaxError: Unexpected token &#x27;while&#x27;</span><br></pre></td></tr></table></figure>

<p>​    使用 <code>var</code> 声明代码会被提升到前面，按理来说，变量未定义就使用应该报错，但是由于变量提升的缘故，并不会报错。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(a); //undefined</span><br><span class="line">var a = 1;</span><br><span class="line">console.log(a);  //1</span><br><span class="line"></span><br><span class="line">//以上代码解析器执行过程如下</span><br><span class="line">var a;</span><br><span class="line">console.log(a); //1</span><br><span class="line">a = 1;</span><br><span class="line">console.log(a); //1</span><br></pre></td></tr></table></figure>

<p>下面是 <code>if(false)</code> 中定义的var也会发生变量提升，注释掉<code>if</code> 结果会不同</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var web = &quot;ashun&quot;;</span><br><span class="line">function as() &#123;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var web = &quot;阿顺&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(web);</span><br><span class="line">&#125;</span><br><span class="line">as();//undefined</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-TDZ"><a href="#1-3-TDZ" class="headerlink" title="1.3 TDZ"></a>1.3 TDZ</h4><p>​    TDZ 又称暂时性死区，指变量在作用域内已经存在，但必须在<code>let/const</code>声明后才可以使用。</p>
<p>TDZ可以让程序保持先声明后使用的习惯，让程序更稳定。</p>
<ul>
<li>变量要先声明后使用</li>
<li>建议使用let/const 而少使用var</li>
</ul>
<p>使用<code>let/const</code> 声明的变量在声明前存在临时性死区（TDZ）使用会发生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(x); // Cannot access &#x27;x&#x27; before initialization</span><br><span class="line">let x = 1;</span><br></pre></td></tr></table></figure>

<p>在<code>run</code>函数作用域中产生TDZ，不允许变量在未声明前使用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">as = &quot;Ashuntefannao&quot;;</span><br><span class="line">function run() &#123;</span><br><span class="line">  console.log(as);</span><br><span class="line">  let as = &quot;Ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

<p>函数参数的解析，自左向右，下面代码b没有声明赋值不允许直接使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function test(a = b, b = 3) &#123;&#125;</span><br><span class="line">test(); //Cannot access &#x27;b&#x27; before initialization</span><br></pre></td></tr></table></figure>

<p>因为a已经赋值，所以b可以使用a变量，下面代码访问正常</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function test(a = 2, b = a) &#123;&#125;</span><br><span class="line">test(); </span><br></pre></td></tr></table></figure>

<h3 id="二、块级作用域"><a href="#二、块级作用域" class="headerlink" title="二、块级作用域"></a>二、块级作用域</h3><p>​    var不具有块级作用域，ES6的let、const具有块级作用域。但是它们都具有函数、全局作用域。</p>
<h4 id="2-1-共同点"><a href="#2-1-共同点" class="headerlink" title="2.1 共同点"></a>2.1 共同点</h4><p>​    在父级作用域中声明的变量，能够被子级作用域访问，但子级作用域中的变量不能够被父级访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var as &#x3D; &quot;ashunte&quot;;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    var site &#x3D; &quot;ashuntefannao.com&quot;;</span><br><span class="line">    console.log(as);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();	&#x2F;&#x2F;ashunte</span><br><span class="line">onsole.log(site);&#x2F;&#x2F;Uncaught ReferenceError: site is not defined</span><br></pre></td></tr></table></figure>

<h4 id="2-2-let"><a href="#2-2-let" class="headerlink" title="2.2 let"></a>2.2 let</h4><p>​    <code>let</code>、<code>const</code>都具有块级作用域，会与<code>&#123; &#125;</code>形成一个作用域，块级作用域与全局、函数作用域一样：在父级作用域中声明的变量，能够被子级作用域访问，但子级作用域中的变量不能够被父级访问。</p>
<p>​    但<code>let</code>、<code>const</code>形成的块级作用域所定义的变量，不会污染全局, 并且<code>let</code>、<code>const</code>定义的变量全局不会添加到<code>window</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        let as &#x3D; &quot;ashun&quot;;</span><br><span class="line">        &#123;</span><br><span class="line">          console.log(as);&#x2F;&#x2F;ashun</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(as);&#x2F;&#x2F;Uncaught ReferenceError: as is not defined</span><br></pre></td></tr></table></figure>

<p>每一层都是独立作用域，里层作用域可以声明外层作用域同名变量，但不会改变外层变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function run() &#123;</span><br><span class="line">        let as &#x3D; &quot;Ashuntefannao&quot;;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">          let as &#x3D; &quot;Ashun&quot;;</span><br><span class="line">          console.log(as); &#x2F;&#x2F;Ashun</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(as); &#x2F;&#x2F;Ashuntefannao</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>



<p>–var不具有块级作用域，使用 <code>var</code> 声明的变量存在于最近的函数或全局作用域中。</p>
<p>没有块作用域很容易污染全局，下面函数中的变量污染了全局环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function run() &#123;</span><br><span class="line">    web &#x3D; &quot;ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br><span class="line">console.log(web); &#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>

<p>注意：上面示例的代码中，web变量没有使用var声明，如果使用var声明，就会报错。</p>
<p>使用var声明报错的原因:</p>
<p>​    如果使用var声明了web变量，证明web变量属于run函数的作用域。所以外部作用域不能访问该变量。</p>
<p>没有使用var声明:</p>
<p>​    证明使用的是全局变量，变量提升在全局作用域，因此在函数外部（全局作用域）能够访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var web;&#x2F;&#x2F;变量提升过程</span><br><span class="line">function run() &#123;</span><br><span class="line">web &#x3D; &quot;ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br><span class="line">console.log(web); &#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>

<p>这个问题虽然说出来很理所当然，但是在一开始可能很难get到这个点。</p>
<p>–没有块作用作用域时<code>var</code>在<code>for循环</code>中也会污染全局</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);	//10</span><br></pre></td></tr></table></figure>

<p>–<code>var</code> 全局声明的变量也存在于 <code>window</code>对象中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">var as = &quot;ashun&quot;;</span><br><span class="line">console.log(window.as); //ashun</span><br></pre></td></tr></table></figure>

<p>–使用<code>let、const</code>全局声明的变量不会添加到<code>window</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &quot;ashun&quot;;</span><br><span class="line">console.log(window.as); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="2-3-const"><a href="#2-3-const" class="headerlink" title="2.3 const"></a>2.3 const</h4><p>使用 <code>const</code> 用来声明常量，这与其他语言差别不大，比如可以用来声明后台接口的URI地址。</p>
<ul>
<li><p>常量名建议全部大写</p>
</li>
<li><p>const常量只能声明一次</p>
</li>
<li><p>声明时必须同时赋值</p>
</li>
<li><p>不允许再次全新赋值</p>
</li>
<li><p>拥有块、函数、全局作用域</p>
</li>
<li><p>可以修改<code>引用类型</code>变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const INFO &#x3D; &#123;</span><br><span class="line">  url: &#39;https:&#x2F;&#x2F;www.ashuntefannao.com&#39;,</span><br><span class="line">  port: &#39;8080&#39;</span><br><span class="line">&#125;;</span><br><span class="line">INFO.port &#x3D; &#39;443&#39;;</span><br><span class="line">console.log(INFO); &#x2F;&#x2F;443</span><br></pre></td></tr></table></figure>

<h5 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a><font color="yellowgreen">Object.freeze</font></h5><p>如果冻结变量后，变量也不可以修改了，若使用严格模式还会报出错误。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const INFO = &#123;</span><br><span class="line">	url: &quot;https://www.ashun.com&quot;,</span><br><span class="line">	port: &quot;8080&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(INFO);</span><br><span class="line">INFO.port = &quot;443&quot;; //Cannot assign to read only property</span><br><span class="line">console.log(INFO);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-4-重复定义"><a href="#2-4-重复定义" class="headerlink" title="2.4 重复定义"></a>2.4 重复定义</h4><ul>
<li>使用<code>var</code>定义变量，可在<code>同作用域</code>下定义同名变量进行覆盖。</li>
<li>使用<code>let、const</code>定义的变量，不可在<code>同作用域</code>下定义同名变量</li>
</ul>
<p>使用 var 可能造成不小心定义了同名变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//优惠价</span><br><span class="line">var price = 90;</span><br><span class="line">//商品价格</span><br><span class="line">var price = 100;</span><br><span class="line">console.log(`商品优惠价格是:$&#123;price&#125;`);//100</span><br></pre></td></tr></table></figure>

<p>使用<code>let</code> 可以避免上面的问题，因为let声明后的变量不允许在同一作用域中重新声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let web = &#x27;astfn.github.io&#x27;;</span><br><span class="line">let web = &#x27;阿顺&#x27;; //Identifier &#x27;web&#x27; has already been declared</span><br></pre></td></tr></table></figure>

<p>不同作用域可以重新声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let web = &quot;ashun.com&quot;;</span><br><span class="line">if (1) &#123;</span><br><span class="line">   let web = &quot;Ashun&quot;;</span><br><span class="line">   console.log(web);//Ashun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、-严格模式"><a href="#三、-严格模式" class="headerlink" title="三、 严格模式"></a>三、 严格模式</h3><p>​    严格模式(“use strict”)，可以定义在script标签对顶部定义（范围为该标签对内），也可以在函数体顶部定义（范围为该函数内部）。</p>
<p>​    严格模式的使用，可以使我们的代码更加的规范，所以强力推荐使用<code>&quot;use strict&quot;</code></p>
<h4 id="3-1-不同点"><a href="#3-1-不同点" class="headerlink" title="3.1 不同点"></a>3.1 不同点</h4><ul>
<li><p>变量必须<code>先定义后使用</code></p>
</li>
<li><p>函数形参名称不能重复</p>
</li>
<li><p>关键词不允许做变量使用</p>
</li>
<li><p>单独为函数设置严格模式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function strict()&#123;  </span><br><span class="line">  &quot;use strict&quot;;  </span><br><span class="line">  return &quot;严格模式&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">function notStrict() &#123;  </span><br><span class="line">  return &quot;正常模式&quot;;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>为了在多文件合并时，防止全局设置严格模式对其他没使用严格模式文件的影响，将脚本放在一个执行函数中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  url = &#x27;ashun.com&#x27;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>解构差异</p>
<p>非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明语法进行声明。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;name,url&#125; = &#123;name:&#x27;ashun&#x27;,url:&#x27;ashuntefannao.com&#x27;&#125;;</span><br><span class="line">console.log(name, url);	//ashun ashuntefannao.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">&#123;name,url&#125; &#x3D; &#123;name:&#39;ashun&#39;,url:&#39;ashuntefannao.com&#39;&#125;;</span><br><span class="line">console.log(name, url); &#x2F;&#x2F;Uncaught ReferenceError: age is not defined</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const &#123;name,url&#125; &#x3D; &#123;name:&#39;ashun&#39;,url:&#39;ashuntefannao.com&#39;&#125;;</span><br><span class="line">console.log(name, url);	&#x2F;&#x2F;ashun ashuntefannao.com</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="四、运算符与流程控制"><a href="#四、运算符与流程控制" class="headerlink" title="四、运算符与流程控制"></a>四、运算符与流程控制</h3><p>​    在JavaScript中，与其他语言一样，都具有常用的运算符、流程控制语法。这里不再对其进行赘述，只对比较特殊的运算符、流程控制语法进行详细的解释。</p>
<h4 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4.1 运算符"></a>4.1 运算符</h4><ul>
<li>赋值运算符（=）</li>
<li>算数运算符（+、-、*、/、%）</li>
<li>复合运算符（+=、-=、*=、/=、%=）</li>
<li>一元运算符（++、–）</li>
<li>比较运算符（&gt;、&gt;=、&lt;、&lt;=、==、===）</li>
<li>逻辑运算符（&amp;&amp;、||、！）</li>
</ul>
<h4 id="4-2-流程控制"><a href="#4-2-流程控制" class="headerlink" title="4.2 流程控制"></a>4.2 流程控制</h4><ul>
<li><p>if、else、else if</p>
</li>
<li><p>switch</p>
</li>
<li><p>while</p>
</li>
<li><p>do/while</p>
</li>
<li><p>for</p>
</li>
<li><p>break/continue</p>
</li>
<li><p>三元表达式</p>
</li>
<li><p>for/in</p>
<p>for/in循环能够遍历Array，Object的<code>key</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&quot;A&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;];</span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">	 console.log(i);		&#x2F;&#x2F;0~4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; baseURL: &quot;http:&#x2F;&#x2F;ashuntefannao.com&quot;, port: 8081 &#125;;</span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">	console.log(i);			&#x2F;&#x2F;baseURL port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>–遍历window对象的所有属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (name in window) &#123;</span><br><span class="line">		console.log(window[name]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>for/of</p>
<p>for/of,能够遍历所有的<code>可迭代</code>数据结构，例如：Dom元素、Array、String、Set、Map。</p>
<p><code>但是Object、WeakSet、WeakMap是不可迭代的，因此也就不能够使用for/in进行遍历</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3];</span><br><span class="line">for (const iterator of arr) &#123;</span><br><span class="line">console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;Ashun&#39;;</span><br><span class="line">for (const iterator of str) &#123;</span><br><span class="line">console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>--使用迭代特性遍历数组，后期在迭代器部分会详解。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let site &#x3D; [&quot;ashun&quot;, &quot;Ashuntefannao&quot;];</span><br><span class="line">for (const [key, value] of site.entries()) &#123;</span><br><span class="line">	console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;0 ashun 1 Ashuntefannao</span><br></pre></td></tr></table></figure>

<p>使用<code>for/of</code> 也可以用来遍历DOM元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let lis = document.querySelectorAll(&quot;li&quot;);</span><br><span class="line">	for (const li of lis) &#123;</span><br><span class="line">		li.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">		this.style.backgroundColor = &quot;red&quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>lable</p>
<p>标签(label) 为程序定义位置，可以使用<code>continue/break</code>跳到该位置。</p>
<p>下面取<code>i+n</code> 大于15时退出循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ashuntefan: for (let i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">ashun: for (let n &#x3D; 1; n &lt;&#x3D; 10; n++) &#123;</span><br><span class="line">	if (n % 2 !&#x3D; 0) &#123;</span><br><span class="line">		continue ashun;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(i, n);</span><br><span class="line">	if (i + n &gt; 15) &#123;</span><br><span class="line">		break ashuntefan;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>animation动画</title>
    <url>/2021/05/07/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/CSS/animation%E5%8A%A8%E7%94%BB/animation%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h2><p>css中实现动画有两种方式：<code>transition</code>过渡动画、 <code>animation</code>自定义动画。</p>
<p>本文主要讲解<code>animation</code>动画的使用，若要了解<code>transition</code>过渡动画请前往<a href="##">transition过渡动画</a>。</p>
<p>我们先简单了解下animation的一些语法和使用过程，后面会详细解说：</p>
<ol>
<li>通过<code>@keyframes</code>自定义关键帧动画并为动画命名，可以在其中对每一帧进行设置。</li>
<li>使用自定义动画的元素，需要通过<code>animation</code>相关属性进行配置<ul>
<li>animation-name</li>
<li>animation-duration</li>
<li>animation-timing-function</li>
<li>animation-delay</li>
<li>animation-iteration-count</li>
<li>animation-direction</li>
<li>animation-fill-mode</li>
<li>animation-play-state</li>
</ul>
</li>
</ol>
<p>我们还可在JavaScript中，通过驼峰式命名来访问/设置<code>animation</code>相关属性。</p>
<h2 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h2><p>keyframes(关键帧)，在css样式表中可以通过<code>@keyframes</code>来设置关键帧动画，并指定动画名称供使用者锁定。</p>
<p>其语法如下：</p>
<p>我们可以通过百分比来设置具体帧数的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes animateName&#123;</span><br><span class="line">    0%   &#123; width:50px; height:50px; &#125;	</span><br><span class="line">    50%  &#123; width:100px; height:100px; &#125;	</span><br><span class="line">    100% &#123; width:50px; height:50px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>0%</code>和<code>100%</code>代表<code>首尾帧</code>,也可分别使用<code>from</code>、<code>to</code>替代。下面代码与上述代码效果相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes animateName&#123;</span><br><span class="line">    from &#123; width:50px; height:50px; &#125;	</span><br><span class="line">    50%  &#123; width:100px; height:100px; &#125;	</span><br><span class="line">    to	 &#123; width:50px; height:50px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是： 若自定义动画<strong>未定义首尾帧</strong>，则首尾帧将会<strong>应用使用者的原有样式</strong></p>
<p>现在动画定义完毕，使用者需要配置<code>animation</code>相关属性对动画进行配置。</p>
<h2 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h2><p>若某个元素想要使用对应名称的动画，需要配置<code>animation-name: animateName</code>属性进行锁定。</p>
<p>下面以一个简单的动画为例：</p>
<img src="animation动画.assets/animate1.gif" alt="animate1" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    animation-name: test;</span><br><span class="line">    animation-duration: 1s;</span><br><span class="line">    animation-iteration-count: infinite;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes test &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      background-color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>这里为了让动画更加明显，使用了<code>animation-duration</code>与<code>animation-iteration-count</code>,这里简单介绍一下：</p>
<ul>
<li><code>animation-duration</code> 用于定义动画持续时间，默认<code>0s</code></li>
<li><code>animation-iteration-count</code> 用于定义动画迭代次数，也就是执行次数，默认为<code>1</code>。</li>
</ul>
<h2 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h2><p><code>animation-duration</code>顾名思义，用于设置动画持续时间.</p>
<p>​    需要注意的是：**默认值为<code>0s</code>**，也就是说，若不配置<code>animation-duration</code>则默认请况下是没有动画效果的，即便使用<code>animation-name</code>锁定了动画名称，由于动画持续时间为<code>0s</code>，所以没有效果。</p>
<h2 id="animation-timing-function："><a href="#animation-timing-function：" class="headerlink" title="animation-timing-function："></a>animation-timing-function：</h2><p><code>animation-timing-function</code>用于定义时间函数，通过这个选项，可配置动画随时间的运动速率和轨迹。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">动画从头到尾的速度是相同的。</td>
</tr>
<tr>
<td align="left">ease（缓解）</td>
<td align="left">**<code>默认值</code>**：动画以低速开始，然后加快，在结束前变慢。</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">动画以低速开始。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">动画以低速结束。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">动画以低速开始和结束。</td>
</tr>
<tr>
<td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">贝塞尔曲线（自定义数值），可到<a href="https://cubic-bezier.com/">相关网站</a>可视化设置。</td>
</tr>
</tbody></table>
<p>效果展示：</p>
<img src="animation动画.assets/animate2.gif" alt="animate2" style="zoom:65%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">  body &#123;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    align-items: center;</span><br><span class="line">    background-color: #34495e;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: row;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    list-style: none;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li &#123;</span><br><span class="line">    width: 40%;</span><br><span class="line">    margin: 0px 40px;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li &gt; .fa &#123;</span><br><span class="line">    font-size: 4em;</span><br><span class="line">    color: white;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    animation: test 2s infinite;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes test &#123;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: translateY(86vh);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(1) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: linear;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(2) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: ease;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(3) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: ease-in;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(4) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(5) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: ease-in-out;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li:nth-of-type(6) &gt; .fa &#123;</span><br><span class="line">    animation-timing-function: cubic-bezier(0.29, 1.69, 0.39, -0.05);</span><br><span class="line">  &#125;</span><br><span class="line">  li &gt; span &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    color: #f1c40f;</span><br><span class="line">  &#125;</span><br><span class="line">  strong &#123;</span><br><span class="line">    color: #e67e22;</span><br><span class="line">    margin: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;strong&gt;animatin-timing-function:&lt;&#x2F;strong&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;linear&lt;br &#x2F;&gt;线性&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;ease&lt;br &#x2F;&gt;默认。动画以低速开始，然后加快，在结束前变慢。&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;ease-in&lt;br &#x2F;&gt;以低速开始&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;ease-out&lt;br &#x2F;&gt;以低速结束&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;ease-in-out&lt;br &#x2F;&gt;以低速开始和结束&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;span&gt;cubic-bezier()&lt;br &#x2F;&gt;贝塞尔曲线（自定义数值）&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;👇&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p><code>animation-delay</code>用于设置动画延迟时间，单位为<code>s</code></p>
<p>下例动画将于<code>2s</code>后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  animation-name: test;</span><br><span class="line">  animation-duration: 1s;</span><br><span class="line">  animation-delay: 2s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes test &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当同时使用多个动画时，这个属性使用频率非常高，可依次定义每个动画的延迟执行时间，区分开每个动画。</p>
<p>当然其实也可分别设置每个动画的其它animation族属性，后面会详细介绍多动画累加。</p>
<h2 id="animation-iteration-count："><a href="#animation-iteration-count：" class="headerlink" title="animation-iteration-count："></a>animation-iteration-count：</h2><p><code>animation-iteration-count</code>用于设置动画执行的次数，默认值为<code>1</code>只执行一次。</p>
<p>其值可分为两种：</p>
<ul>
<li>具体number数值</li>
<li><code>infinite</code>:执行无限次</li>
</ul>
<h2 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h2><p><code>animation-direction</code>用于设置动画执行方向，具体来说可设置为以下值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值。动画按正常播放。</td>
</tr>
<tr>
<td>reverse</td>
<td>动画反向播放。</td>
</tr>
<tr>
<td>alternate（交替的）</td>
<td>动画正向交替执行（正向-&gt;反向）Loop。</td>
</tr>
<tr>
<td>alternate-reverse</td>
<td>动画反向交替执行（反向-&gt;正向）Loop。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。</td>
</tr>
</tbody></table>
<p>效果展示：</p>
<img src="animation动画.assets/animate3.gif" alt="animate3" style="zoom:65%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">  body &#123;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    background-color: #34495e;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: row;</span><br><span class="line">    list-style: none;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li &#123;</span><br><span class="line">    margin: 0px 40px;</span><br><span class="line">    &#x2F;* border: 2px solid #ddd; *&#x2F;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    color: #e74c3c;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  ul &gt; li &gt; .fa &#123;</span><br><span class="line">    animation: test 1.3s infinite;</span><br><span class="line">    font-size: 7em;</span><br><span class="line">  &#125;</span><br><span class="line">  ul li:nth-of-type(1) &gt; .fa &#123;</span><br><span class="line">    animation-direction: normal;</span><br><span class="line">  &#125;</span><br><span class="line">  ul li:nth-of-type(2) &gt; .fa &#123;</span><br><span class="line">    animation-direction: reverse;</span><br><span class="line">  &#125;</span><br><span class="line">  ul li:nth-of-type(3) &gt; .fa &#123;</span><br><span class="line">    animation-direction: normal;</span><br><span class="line">  &#125;</span><br><span class="line">  ul li:nth-of-type(4) &gt; .fa &#123;</span><br><span class="line">    animation-direction: reverse;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes test &#123;</span><br><span class="line">    100% &#123;</span><br><span class="line">      transform: scale(1.7);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">  &#125;</span><br><span class="line">  li &gt; span &#123;</span><br><span class="line">    font-size: 24px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">  body ul:nth-of-type(2) li:nth-of-type(1) &gt; .fa &#123;</span><br><span class="line">    animation-direction: alternate;</span><br><span class="line">  &#125;</span><br><span class="line">  body ul:nth-of-type(2) li:nth-of-type(2) &gt; .fa &#123;</span><br><span class="line">    animation-direction: alternate-reverse;</span><br><span class="line">  &#125;</span><br><span class="line">  strong &#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    color: white;</span><br><span class="line">    opacity: 0.76;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;animation-direction:&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;❤&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;normal&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;p&gt;默认值&#x2F;正向&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;❤&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;reverse&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;p&gt;反向进行动画&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;strong</span><br><span class="line">    &gt;可以利用默认值normal和reverse，交叉动画的效果，&lt;br &#x2F;&gt;也可以正反向反复交替如下。&lt;&#x2F;strong</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;❤&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;alternate&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;p&gt;反复交替（正向）&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;fa&quot;&gt;❤&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;alternate-reverse&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;p&gt;反复交替（反向）&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h2><p><code>animation-fill-mode</code>用于设置动画的填充模式，主要应用的属性值为：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">默认值。动画在动画执行前后，不会应用任何样式到目标元素。</td>
</tr>
<tr>
<td align="left">forwards</td>
<td align="left">在动画结束后（<strong>由 animation-iteration-count 决定</strong>），目标元素将保持应用<code>最后帧</code>动画。</td>
</tr>
<tr>
<td align="left">backwards</td>
<td align="left">在动画结束后（<strong>由 animation-iteration-count 决定</strong>），目标元素将保持应用<code>起始帧</code>动画。</td>
</tr>
</tbody></table>
<p>案例测试：</p>
<p>下例代码，在动画执行结束后，将会一直应用最后帧的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  animation-name: test;</span><br><span class="line">  animation-delay: 2s;</span><br><span class="line">  animation-duration: 1s;</span><br><span class="line">  animation-fill-mode: forwards;</span><br><span class="line">  &#x2F;* animation-iteration-count: infinite; *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes test &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：上述代码若添加<code>animation-iteration-count: infinite</code>，由于动画次数无限执行，不会结束，也就不会应用最后帧样式</p>
<h2 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h2><p>可设置动画的执行状态，通常通过JavaScript动态控制。</p>
<ul>
<li>默认值为：<code>running</code></li>
<li>设为<code>paused</code>(暂停)，动画将停止执行。</li>
</ul>
<p>下面动画将不会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  animation-name: test;</span><br><span class="line">  animation-delay: 2s;</span><br><span class="line">  animation-duration: 1s;</span><br><span class="line">  animation-play-state: paused; &#x2F;&#x2F;值为paused将不会执行</span><br><span class="line">&#125;</span><br><span class="line">@keyframes test &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过JavaScript动态控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    animation-name: test;</span><br><span class="line">    animation-duration: 1s;</span><br><span class="line">    animation-iteration-count: infinite;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes test &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      background-color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button onclick&#x3D;&quot;operation(&#39;running&#39;)&quot;&gt;开始&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;button onclick&#x3D;&quot;operation(&#39;paused&#39;)&quot;&gt;停止&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    function operation(mode) &#123;</span><br><span class="line">      document.querySelector(&quot;div&quot;).style.animationPlayState &#x3D; mode;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>



<h2 id="多动画累加"><a href="#多动画累加" class="headerlink" title="多动画累加"></a>多动画累加</h2><p>若元素应用多个动画，我们可以分别控制各个动画的一些属性，来达到区分各个动画的效果。</p>
<p>下面示例，给<code>animation</code>族属性分别设置多个值，来对不同的动画做不同的配置。</p>
<p><code>animation</code>族属性设置多个值时，各个值之间使用<code>,</code>隔开。</p>
<p>案例：</p>
<img src="animation动画.assets/animate4.gif" alt="animate4" style="zoom:65%;" />

<ol>
<li>首先使用<code>animation-name</code>来锁定使用的各个动画</li>
<li>之后使用其它的<code>animation</code>族属性，分别约束对应动画，且设置顺序与<code>animation-name</code>使用动画的顺序保持一致。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: #353b48;</span><br><span class="line">  &#125;</span><br><span class="line">  main &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    background-color: #487eb0;</span><br><span class="line">    animation-name: bgcolor, bodera, rotat;</span><br><span class="line">    animation-duration: 2s, 2s, 3s;</span><br><span class="line">    animation-iteration-count: 2, 2, 1;</span><br><span class="line">    animation-direction: reverse, normal, normal;</span><br><span class="line">    animation-fill-mode: forwards, forwards, forwards;</span><br><span class="line">  &#125;</span><br><span class="line">  main::after &#123;</span><br><span class="line">    content: &quot;阿顺特烦恼&quot;;</span><br><span class="line">    color: white;</span><br><span class="line">    animation: opcity 2s;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    font-size: 1.5em;</span><br><span class="line">    animation-fill-mode: forwards;</span><br><span class="line">    animation-delay: 4s;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes opcity &#123;</span><br><span class="line">    25% &#123;</span><br><span class="line">      opacity: 0.2;</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">      opacity: 0.6;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">      opacity: 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes bgcolor &#123;</span><br><span class="line">    25% &#123;</span><br><span class="line">      background-color: #fbc531;</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">      background-color: #8c7ae6;</span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">      background-color: #f5f6fa;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">      background-color: #e84118;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes bodera &#123;</span><br><span class="line">    25% &#123;</span><br><span class="line">      border-radius: 10%;</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">      border-radius: 25%;</span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">      border-radius: 38%;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes rotat &#123;</span><br><span class="line">    25% &#123;</span><br><span class="line">      transform: rotate(30deg);</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">      transform: rotate(60deg);</span><br><span class="line">    &#125;</span><br><span class="line">    75% &#123;</span><br><span class="line">      transform: rotate(120deg);</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">      transform: rotate(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;&lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>关键代码解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">   display: flex;</span><br><span class="line">   justify-content: center;</span><br><span class="line">   align-items: center;</span><br><span class="line">   width: 100vw;</span><br><span class="line">   height: 100vh;</span><br><span class="line">   background-color: #487eb0;</span><br><span class="line">   animation-name: bgcolor, bodera, rotat;</span><br><span class="line">   animation-duration: 2s, 2s, 3s;</span><br><span class="line">   animation-iteration-count: 2, 2, 1;</span><br><span class="line">   animation-direction: reverse, normal, normal;</span><br><span class="line">   animation-fill-mode: forwards, forwards, forwards;</span><br><span class="line"> &#125;</span><br><span class="line"> main::after &#123;</span><br><span class="line">   content: &quot;阿顺特烦恼&quot;;</span><br><span class="line">   color: white;</span><br><span class="line">   animation: opcity 2s;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   font-size: 1.5em;</span><br><span class="line">   animation-fill-mode: forwards;</span><br><span class="line">   animation-delay: 4s;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里为了让文字在其他动画都执行完毕后再显示，为文字动画设置了<code>animation-delay</code>延迟执行，但我们要确定之前动画结束的时间，怎么计算呢？</p>
<p>我们知道，当应用多个动画时，它们也都是并发执行的，所以我们只要知道执行时间最长的那个动画即可。</p>
<p>我们需要分析这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-duration: 2s, 2s, 3s;</span><br><span class="line">animation-iteration-count: 2, 2, 1;</span><br></pre></td></tr></table></figure>

<p>执行次数×单次执行时间=动画总时间。因此最大时间=max(2×2 ,2×2, 3×1)=4s</p>
<p>因此，文字动画延迟4s。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
<p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>CSS</category>
        <category>animation动画</category>
      </categories>
  </entry>
  <entry>
    <title>background相关</title>
    <url>/2021/05/06/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/CSS/background%E7%9B%B8%E5%85%B3/background%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>​    <code>background族属性</code>是我们经常会用到的css属性，用于控制背景样式，但其实background还有很多细节性的东西，让我们来了解一下吧。</p>
<p>首先我们先简单介绍一下background族属性都包含哪些：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
<th align="left">CSS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">background-color</td>
<td align="left">设置背景颜色。</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">background-position</td>
<td align="left">设置<code>bg-image</code>的位置。</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">background-size</td>
<td align="left">设置<code>bg-image</code>的尺寸。</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">background-repeat</td>
<td align="left">规定如何重复、是否重复<code>bg-image</code>。</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">background-origin</td>
<td align="left">设置<code>bg-image</code>的定位基点。</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">background-clip</td>
<td align="left">限制**<code>整个背景</code>**的绘制区域。</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">background-attachment</td>
<td align="left">规定<code>bg-image</code>是否跟随页面滚动。</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">background-image</td>
<td align="left">设置要使用的背景图像。</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>​    当然，<code>background</code>是一个复合属性，可以一次性配置以上介绍的所有属性。但要注意的是有一些配置项的单位相同，为了能让浏览器识别，在使用符合属性<code>background</code>同时配置<code>bg-position</code>和<code>bg-size</code>时，应遵循以下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: positionX positionY &#x2F; width height</span><br></pre></td></tr></table></figure>

<p>​    例如<code>background: 0px 0px / 100px 100px</code>，意为：背景定位于左上角(默认基于内边距盒子)，尺寸为宽高100px。</p>
<p>下面详细介绍各个<code>background</code>族属性👇</p>
<h2 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h2><p><code>background-color</code>设置背景颜色:</p>
<ul>
<li>其值可为：英文单词、rgb、rgba、#开头的6位十六进制</li>
<li>层级低于<code>background-image</code></li>
</ul>
<p>下例同时设置<code>bg-color</code>与<code>bg-img</code>，可发现：<code>bg-img</code>覆盖在<code>bg-color</code>之上。</p>
<img src="background相关.assets/bg-color.png" alt="bg-color.png" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 400px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border: 8px dashed white;</span><br><span class="line">  color: white;</span><br><span class="line">  background-color: #5758bb;</span><br><span class="line">  background-image: url(&quot;.&#x2F;imagePath&#x2F;xxx.png&quot;);</span><br><span class="line">  background-size: 80px;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-position: left bottom;</span><br><span class="line">  background-clip: content-box;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;p&gt;Ashuntefannao&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;Ashun&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><p><code>background-position </code>用于设置<code>bg-image</code>的位置。<strong>默认值</strong>：0% 0%。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>top center bottom   </code>/<code> left right center</code></td>
<td align="left">若只设置了一个关键词，那么第二个值将是”center”。</td>
</tr>
<tr>
<td align="left">x% y%</td>
<td align="left">第一个值是水平位置，第二个值是垂直位置。左上角是 0% 0%。右下角是 100% 100%。若只设置了一个值，另一个值将是 50%。</td>
</tr>
<tr>
<td align="left">xpos ypos</td>
<td align="left">第一个值是水平位置，第二个值是垂直位置。左上角是 0 0。单位是像素 (0px 0px) 或任何其他的 CSS 单位。若只设置了一个值，另一个值将是50%。</td>
</tr>
</tbody></table>
<p>值得注意的是：</p>
<ul>
<li>三种值类型可混合使用</li>
<li>可搭配<code>background-origin</code>操控定位的基点，进行定位</li>
</ul>
<h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p><code>background-size</code>用于控制<code>background-image</code>的尺寸大小。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>width height</code></td>
<td align="left">分别设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。单位可为<code>px %</code>，若为<code>%</code>则是相对于父级元素宽高。</td>
</tr>
<tr>
<td align="left">cover</td>
<td align="left">把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</td>
</tr>
<tr>
<td align="left">contain</td>
<td align="left">把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</td>
</tr>
</tbody></table>
<p>如图示例：</p>
<p><img src="background相关.assets/bg-size-具体宽高.png" alt="bg-size-具体宽高" style="zoom:40%;" /><img src="background相关.assets/bg-size-contain.png" alt="bg-size-contain" style="zoom: 40%;" /><img src="background相关.assets/bg-size-cover.png" alt="bg-size-cover" style="zoom: 40%;" /></p>
<p>为了让其更加直观，应用了<code>background-repeat: no-repeat</code>,下面具体讲解👇</p>
<h2 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h2><p> <code>background-repeat</code>规定如何重复、是否重复<code>bg-image</code>，其具体值如下：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">repeat</td>
<td align="left"><strong>默认</strong>。背景图像将在垂直方向和水平方向重复。</td>
</tr>
<tr>
<td align="left">repeat-x</td>
<td align="left">背景图像将在水平方向重复。</td>
</tr>
<tr>
<td align="left">repeat-y</td>
<td align="left">背景图像将在垂直方向重复。</td>
</tr>
<tr>
<td align="left">no-repeat</td>
<td align="left">背景图像将仅显示一次。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 background-repeat 属性的设置。</td>
</tr>
</tbody></table>
<p>默认情况下，即应用默认值<code>repeat</code>时：</p>
<ul>
<li>当<code>bg-image</code>的尺寸小于盒子尺寸时，将会自动显示出重复效果。</li>
<li>若<code>bg-image</code>的尺寸大于盒子尺寸时，通过<code>bg-position</code>，也可观察出重复效果。<ul>
<li>例如盒子宽高为200px，背景图像宽高400px，设置<code>bg-position: 1200px 1200px</code>,虽然定位效果已经远远超出了背景图的宽高，但由于默认是<code>repeat</code>模式，背景图依然能够显示。</li>
</ul>
</li>
</ul>
<h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p>可通过该属性，改变<code>background-position </code>的定位基点，具体来说其值如下：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">padding-box</td>
<td align="left"><strong>默认</strong>。背景图像相对于内边距框来定位。</td>
</tr>
<tr>
<td align="left">border-box</td>
<td align="left">背景图像相对于边框盒来定位。</td>
</tr>
<tr>
<td align="left">content-box</td>
<td align="left">背景图像相对于内容框来定位。</td>
</tr>
</tbody></table>
<p>示例：</p>
<p>基础代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border: 8px dashed #718093;</span><br><span class="line">  color: white;</span><br><span class="line">  background-color: #40739e;</span><br><span class="line"> 	background-image: url(&quot;.&#x2F;imagePath&#x2F;xxx.png&quot;);</span><br><span class="line">  background-size: 100px;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  </span><br><span class="line">  background-position: 0px 0px;。</span><br><span class="line">  padding: 40px;</span><br><span class="line">  &#x2F;&#x2F;设置内边距体现background-origin: content-box 效果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>background-origin: padding-box</code>    </li>
</ul>
<img src="background相关.assets/bg-origin-paddingBox.png" alt="bg-origin-paddingBox" style="zoom:75%;" />

<ul>
<li><p><code>background-origin: border-box</code></p>
<img src="background相关.assets/bg-origin-borderBox.png" alt="bg-origin-borderBox" style="zoom:75%;" /></li>
<li><p><code>background-origin: content-box</code></p>
<img src="background相关.assets/bg-orgin-contentBox.png" alt="bg-orgin-contentBox" style="zoom:75%;" /></li>
</ul>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p><code>background-clip</code>: 限制**<code>整个背景</code>**的绘制区域，其值具体来说有以下几种：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">border-box</td>
<td align="left">（<strong>默认值</strong>）整个背景被裁剪到边框盒。</td>
</tr>
<tr>
<td align="left">padding-box</td>
<td align="left">整个背景被裁剪到内边距框。</td>
</tr>
<tr>
<td align="left">content-box</td>
<td align="left">整个背景被裁剪到内容框。</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">整个背景被裁剪到文字区域的上方。</td>
</tr>
</tbody></table>
<p>值得注意的是：</p>
<ul>
<li><code>background-origin</code>是对<code>bg-image</code>的限制，而不会影响<code>bg-color</code>。</li>
<li>但<code>background-clip</code>会限制**<code>整个背景</code>**的绘制区域，也就是说设置了该属性，将会影响所有的背景元素，包括<code>bg-color</code>与<code>bg-image</code></li>
</ul>
<p>示例：</p>
<img src="background相关.assets/bg-clip1.png" alt="bg-clip1" style="zoom:60%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  border: 8px dashed #00cec9;</span><br><span class="line">  color: white;</span><br><span class="line">  background-color: #40739e;</span><br><span class="line">  background-image: url(&quot;.&#x2F;imagePath&#x2F;xxx.png&quot;);</span><br><span class="line">  background-size: 100%;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  background-repeat: repeat-y;</span><br><span class="line">  &#x2F;* background-clip: content-box; *&#x2F; </span><br><span class="line">  background-origin: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，不仅有背景图片的显示，还有背景颜色，因为<code>background-origin</code>只是对<code>bg-image</code>的定位约束，所以看到背景图片两端有空隙，从而显示出<code>bg-color</code>。</p>
<p>如果将注释代码取消，也就是设置<code>background-clip: content-box</code>，则是对整个背景区域的约束，<code>bg-color</code>也就不再显示（被<code>bg-image</code>覆盖）。</p>
<img src="background相关.assets/bg-clip2.png" alt="bg-clip2" style="zoom:60%;" />

<p><strong><code>background-clip: text</code></strong></p>
<p>这是个有意思的属性值，可以用它将背景裁剪到文字上方，且只在文字展示，其余部分不会展示背景，可以用它完成下例特效：</p>
<img src="background相关.assets/bg-clip3.gif" alt="bg-clip3" style="zoom:70%;" />

<p>关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color: transparent;</span><br><span class="line">background-clip: text;</span><br><span class="line">-webkit-background-clip: text;</span><br></pre></td></tr></table></figure>



<h2 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h2><p><code>background-attachment</code>用于设置<code>background-image</code>的附件模式，即<code>bg-image</code>是否随<strong>整个页面</strong>滚动而滚动，而不是相对自身元素。</p>
<p>其属性值可以为：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">scroll</td>
<td align="left">默认值。背景图像会随着页面其余部分的滚动而移动。</td>
</tr>
<tr>
<td align="left">fixed</td>
<td align="left">当页面的其余部分滚动时，背景图像不会移动。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 background-attachment 属性的设置。</td>
</tr>
</tbody></table>
<ul>
<li><p>下例左图设置<code>background-attachment: fixed</code>的效果，可发现，<code>bg-image</code>不随页面滚动而滚动，相当于：相对<code>body</code>绝对定位。</p>
</li>
<li><p>右图为默认值<code>scroll</code>，也就是我们常见的效果，<code>bg-image</code>随页面滚动而滚动，相当于：相对<code>body</code>进行<code>fixed</code>定位。</p>
</li>
</ul>
<p>​    <img src="background相关.assets/bg-attachment1.gif" alt="bg-attachment1" style="zoom:45%;" /><img src="background相关.assets/bg-attachment2.gif" alt="bg-attachment2" style="zoom:45%;" /></p>
<h2 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h2><p>上文介绍的很多书性，都是控制<code>background-image</code>的，这个主角终于登场了，实际开发时，我们可能只会使用其基本功能(设置背景图片)，但其实该属性还能完成渐变色效果。</p>
<p>其属性值可为以下几种：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">默认值。不显示背景图像。</td>
</tr>
<tr>
<td align="left">url(“imagePath”)</td>
<td align="left">指向图像的路径。</td>
</tr>
<tr>
<td align="left">linear-gradient()</td>
<td align="left">创建一个线性渐变的 “图像”，(默认方向:<code>自上而下</code>)</td>
</tr>
<tr>
<td align="left">radial-gradient()</td>
<td align="left">创建径向渐变 “图像”。 (默认方向:<code>中心到边缘</code>)</td>
</tr>
<tr>
<td align="left">repeating-linear-gradient()</td>
<td align="left">创建重复的线性渐变 “图像”。</td>
</tr>
<tr>
<td align="left">repeating-radial-gradient()</td>
<td align="left">创建重复的径向渐变 “图像”。</td>
</tr>
</tbody></table>
<p><strong>值得注意的是</strong>：</p>
<p>​    <code>background-image</code>可以设置多个值，且以上属性值可混合、重复配置，配置的背景图像都可展示出来，<strong>层级高低随配置的顺序依次递减</strong>，也就是说，距离用户最近的那一层是<code>background-image</code>的第一个属性值。</p>
<p>​    若配置了多个属性值，且第一层图像没有透明度，则下层的图像将不能展示，这个很好理解，相当于第一层图像挡住了后面层级的图像。</p>
<p>我们可利用这个特性，展示出不同有意思的效果：</p>
<img src="background相关.assets/bg-image1.png" alt="bg-image1" style="zoom:60%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  border: 8px dashed rgba(162, 155, 254, 1);</span><br><span class="line">  color: white;</span><br><span class="line">  background-image: repeating-linear-gradient(	&#x2F;&#x2F;第一层图像</span><br><span class="line">      rgba(255, 255, 255, 0.8),</span><br><span class="line">      rgba(250, 177, 160, 0.8),</span><br><span class="line">      rgba(85, 239, 196, 0.8),</span><br><span class="line">      rgba(116, 185, 255, 0.8) 20px</span><br><span class="line">    ),</span><br><span class="line">    url(&quot;.&#x2F;imagePath&#x2F;xxx.png&quot;);		&#x2F;&#x2F;第二层图像</span><br><span class="line"></span><br><span class="line">  background-size: 100%;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  background-repeat: repeat-y;</span><br><span class="line">  background-clip: content-box;</span><br><span class="line">  background-origin: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再添加一层：</p>
<img src="background相关.assets/bg-image2.png" alt="bg-image2" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: repeating-linear-gradient(		&#x2F;&#x2F;第一层图像</span><br><span class="line">           rgba(255, 255, 255, 0.8),</span><br><span class="line">           rgba(250, 177, 160, 0.8),</span><br><span class="line">           rgba(85, 239, 196, 0.8),</span><br><span class="line">           rgba(116, 185, 255, 0.8) 1px</span><br><span class="line">         ),</span><br><span class="line">         repeating-radial-gradient(						&#x2F;&#x2F;第二层图像</span><br><span class="line">           rgba(0, 0, 0, 1),</span><br><span class="line">           rgba(250, 177, 160, 1),</span><br><span class="line">           rgba(85, 239, 196, 0.1),</span><br><span class="line">           rgba(116, 185, 255, 0.1) 4px</span><br><span class="line">         ),</span><br><span class="line">         url(&quot;.&#x2F;imagePath&#x2F;xxx.png&quot;);						&#x2F;&#x2F;第三层图像</span><br></pre></td></tr></table></figure>

<p>下面我们详细介绍各个属性👇 </p>
<h3 id="url-“imagePath”"><a href="#url-“imagePath”" class="headerlink" title="url(“imagePath”)"></a>url(“imagePath”)</h3><p>通过该属性可设置具体的背景图片，只需要传入图片的路径即可。</p>
<ul>
<li>设置多层图片时，要注意图片是否具有透明度，否则会覆盖下层图片</li>
</ul>
<h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient()"></a>linear-gradient()</h3><p>创建一个线性渐变的 “图像” (默认方向:<code>自上而下</code>)，通过传入各个颜色，并可设置每个颜色的终止位置，实现渐变效果。</p>
<p>其语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: linear-gradient(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>direction可取值：</strong></p>
<ol>
<li><code>to direction</code><ul>
<li>以<code>to </code>开头，后面紧接渐变方向</li>
<li>渐变方向为:<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>。且可两两组合进行倾斜方向的渐变</li>
<li>例如：<code>to bottom</code>(默认值)、<code>to top right </code>（自左下至右上）</li>
</ul>
</li>
<li><code>deg</code><ul>
<li>设置具体渐变的角度，例如：<code>45deg</code></li>
</ul>
</li>
</ol>
<p><strong>color-stop可取值：</strong></p>
<p>该参数分为两部分：<code>颜色</code> 和 <code>终止位置</code>。终止位置：该颜色结束的位置，也是开始渐变下个颜色的位置。</p>
<ul>
<li>颜色可取值：英文单词、rgb、rgba、#开头的六位16进制。</li>
<li>终止位置可取值<ul>
<li>可具体到像素<code>px</code></li>
<li>可设置百分比<code>%</code>，相对于盒子的尺寸</li>
<li>当不设置终止位置时，将自动均分各色块</li>
</ul>
</li>
</ul>
<p>例如：</p>
<p>渐变方向为自左向右，起使颜色为<code>pink</code>,末尾颜色为<code>red</code>且终止于盒子末尾。</p>
<img src="background相关.assets/linear-gradient1.png" alt="linear-gradient1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: linear-gradient(to right, pink, red 100%);</span><br></pre></td></tr></table></figure>

<p>再复杂的线性渐变情况，也符合上面所讲的逻辑，只需简单分析即可。</p>
<h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient()"></a>radial-gradient()</h3><p>创建径向渐变 “图像”。 (默认方向:<code>中心到边缘</code>)，其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: radial-gradient(shape size at position, start-color, ..., last-color);</span><br></pre></td></tr></table></figure>

<p>具体参数：</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">shape</td>
<td align="left">设置径向渐变的形状</td>
</tr>
<tr>
<td>1</td>
<td align="left">size</td>
<td align="left">定义渐变的半径长度</td>
</tr>
<tr>
<td>1</td>
<td align="left">position</td>
<td align="left">定义渐变的位置</td>
</tr>
<tr>
<td>2~n</td>
<td align="left">start-color, …, last-color</td>
<td align="left">用于指定渐变的起止颜色。用法同<code>linear-gradient()  </code></td>
</tr>
</tbody></table>
<p>这里我们主要介绍第一个参数，第一个参数包含三部分：<code>shape </code>形状，<code>size</code>大小，<code>position</code>位置</p>
<p><strong>shape</strong></p>
<ul>
<li>ellipse (<code>默认</code>): 指定椭圆形的径向渐变</li>
<li>circle ：指定圆形的径向渐变</li>
</ul>
<p><strong>size</strong></p>
<ul>
<li>farthest-corner (<code>默认</code>) : 指定径向渐变的半径长度为从圆心到离圆心<code>最远的角</code></li>
<li>closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心<code>最近的角</code></li>
<li>farthest-side ：指定径向渐变的半径长度为从圆心到离圆心<code>最远的边</code></li>
<li>closest-side ：指定径向渐变的半径长度为从圆心到离圆心<code>最近的边</code></li>
</ul>
<p><strong>position</strong></p>
<ul>
<li>以<code>at</code>开头，后面紧接渐变位置</li>
<li>渐变位置取值<ul>
<li>center（<code>默认</code>）：设置<code>中间</code>为径向渐变圆心的纵坐标值。</li>
<li>还可设置为：<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<p>渐变形状为<code>圆形</code>，渐变半径长度为：圆心到离圆心<code>最近的角</code>，末尾颜色为<code>white</code>且终止于盒子宽度的<code>250%</code>。</p>
<p><img src="/2021/05/06/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/CSS/background%E7%9B%B8%E5%85%B3/background%E7%9B%B8%E5%85%B3/background%E7%9B%B8%E5%85%B3.assets/radial-gradient2.png" alt="radial-gradient2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  	width: 100px;</span><br><span class="line">  	height: 90px;</span><br><span class="line">  	background-image: radial-gradient(</span><br><span class="line">    circle closest-corner at right,</span><br><span class="line">    #00cec9,</span><br><span class="line">    #81ecec,</span><br><span class="line">    #74b9ff,</span><br><span class="line">    #0984e3,</span><br><span class="line">    #dfe6e9,</span><br><span class="line">    white 250%</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>径向渐变相对较为复杂，但也都符合上面所讲的逻辑，只需分析参数即可。</p>
<h3 id="重复设置渐变"><a href="#重复设置渐变" class="headerlink" title="重复设置渐变"></a>重复设置渐变</h3><p>可重复设置渐变，对应两个属性值：<code>repeating-linear-gradient()</code>与<code>repeating-radial-gradient()</code>，分别重复设置线性、径向渐变效果。</p>
<p>其参数用法与单独设置渐变效果相同，但若要出现重复渐变的效果，必须要：<strong>设置末尾元素的结束位置&lt; 盒子尺寸</strong>。</p>
<p>这个很好理解，因为渐变末尾颜色的结束位置若大于等于盒子尺寸，则整个渐变效果会覆盖整个盒子，也就不会出现重复渐变的效果。</p>
<p>具体案例可以参考上文（<code>background-image</code>起始处）。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>background看似很简单，其实藏有很多的细节，可以结合之前所学知识多元化思考，就可能创造出非常炫酷的效果</p>
<p>本文到此结束，希望对你有所帮助，我是 Ashun ，在校大学生，立志成为资深前端工程师，欢迎大家一起交流、学习。后续更新更多文章，请持续关注哦~</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，速速告知。</p>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>CSS</category>
        <category>background相关</category>
      </categories>
  </entry>
  <entry>
    <title>Promise核心</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<h2 id="Promise核心"><a href="#Promise核心" class="headerlink" title="Promise核心"></a>Promise核心</h2><p>本章来自己开发一个Promise实现，提升异步编程的能力。</p>
<h3 id="起步构建"><a href="#起步构建" class="headerlink" title="起步构建"></a>起步构建</h3><p>首先声明定义类并声明Promise状态与值，有以下几个细节需要注意。</p>
<ul>
<li>executor为执行者</li>
<li>当执行者出现异常时触发<strong>拒绝</strong>状态，并异步抛出错误<ul>
<li>如果直接抛出错误，在打印时，看不到PROMISE本身的状态与值，所以将抛出错误放在异步宏任务中</li>
<li>这个结果和原生Promsie是相同的</li>
</ul>
</li>
<li>使用静态属性保存状态值</li>
<li>状态只能改变一次，所以在resolve与reject添加条件判断</li>
<li>因为 <code>resolve</code>或<code>rejected</code>方法在executor中调用，作用域也是executor作用域，这会造成在外部确认状态时：this指向window，现在我们使用的是class定义，this为undefined。所以我们要改变this指向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PROMISE &#123;</span><br><span class="line">  static PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">  static FULFILLED &#x3D; &quot;fulfilled&quot;;</span><br><span class="line">  static REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.value &#x3D; undefined;</span><br><span class="line">    this.status &#x3D; PROMISE.PENDING;</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      this.reject(err);</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        throw err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.status &#x3D; PROMISE.FULFILLED;</span><br><span class="line">      this.value &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">      this.value &#x3D; reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试状态改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(new PROMISE(() &#x3D;&gt; &#123;&#125;));</span><br><span class="line">console.log(</span><br><span class="line">  new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>测试executor执行异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   console.log(</span><br><span class="line">     new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       console.log(as);</span><br><span class="line">     &#125;)</span><br><span class="line">   );</span><br><span class="line">&#x2F;&#x2F;对比原生Promise</span><br><span class="line">   console.log(</span><br><span class="line">     new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       console.log(as);</span><br><span class="line">     &#125;)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>



<h3 id="THEN"><a href="#THEN" class="headerlink" title="THEN"></a>THEN</h3><p>现在添加then方法来处理状态的改变，有以下几点说明</p>
<ol>
<li>then可以有两个参数，即成功和错误时的回调函数</li>
<li>若then处理的Promise状态为fulfilled，then的函数参数都不是必须的，如果传入非函数则将被忽略，还需要设置默认值为函数，用于处理没传参，或传入非函数的情况，并将PROMISE的value返回，为后期链式调用then传递值。</li>
<li>若then所处理的Promise状态为rejected且没有使用then的onRejected处理时，将会报错。</li>
<li>当执行then传递的函数发生异常时，统一交给onRejected来处理错误</li>
<li>then的执行是异步任务</li>
</ol>
<h4 id="基础构建"><a href="#基础构建" class="headerlink" title="基础构建"></a>基础构建</h4><p>先观察原生Promsie.then的特点</p>
<ul>
<li>能够处理异步确认状态</li>
<li>then异步执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    res(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>若没有处理拒绝状态的Promise，则会报错</li>
</ul>
<p>若Promise状态为rejected，且没有被then中的onRejected函数处理，将会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;没有传递onRejeted</span><br><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">    &#125;).then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;onRejeted不是函数，证明没有处理异常，依旧会报错</span><br><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">    &#125;).then((result) &#x3D;&gt; console.log(result), &quot;rejected&quot;);</span><br></pre></td></tr></table></figure>

<p>即便是空函数，也代表对异常做了处理，便不会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;Ashun&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  () &#x3D;&gt; &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实现基本功能</p>
<ul>
<li>对onResolve设置默认函数，并返回this.value，当PROMISE状态为fulfilled时，不传参，也会将值传递给下一个then</li>
</ul>
<p><strong>rejected处理</strong></p>
<p>实现方法（一）</p>
<ul>
<li><p>不为onRejected设置默认函数，若设置了默认函数，则会默认处理rejected状态</p>
</li>
<li><p>设置一个变量<code>isfilter</code>，监听rejected是否被处理</p>
</li>
<li><p>由于不确定onRejected是否为函数，也没有为其设置默认函数，所以在后期执行时，要判断其类型，再设置<code>isfilter</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PROMISE &#123;</span><br><span class="line">  …</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    ……</span><br><span class="line">    this.isfilter &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"> 	……</span><br><span class="line">  then(onResolve, onReject) &#123;</span><br><span class="line">    if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">      onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onResolve(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          onReject(this.value);</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          onReject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式有一个弊端，就是一旦抛出错误，后续的同步代码将不再被执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;Ashun&quot;);</span><br><span class="line">&#125;).then();</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;); &#x2F;&#x2F;rejected没有被处理，抛出错误，后续同步代码不会执行</span><br></pre></td></tr></table></figure>



<p><strong>实现方法（二）</strong></p>
<p>在reject回调函数中，<code>异步判断isfilter</code>，因为外部代码自上而下执行，isfilter的初始值为false，若不异步判断，则无论是否被处理，一旦执行reject回调函数，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码自上而下执行，若在reject回调函数中判断isfilter，则要异步判断，等待then处理后，再判断</span><br><span class="line"></span><br><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        	(result) &#x3D;&gt; console.log(result),</span><br><span class="line">        	(reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reject(reason) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">    this.value &#x3D; reason;</span><br><span class="line">    &#x2F;&#x2F; 异步判断是否被过滤,等待then执行完毕，判断rejected是否被处理;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      if (!this.isfilter) &#123;</span><br><span class="line">        throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      onResolve(this.value);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      onReject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">    if (onReject instanceof Function) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onReject(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      this.isfilter &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来测试then方法，结果正常输出<code>Ashun</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        	(result) &#x3D;&gt; console.log(result),</span><br><span class="line">        	(reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">			);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<p>若没有处理rejected，会报错，并且不会影响后续同步代码的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(result &#x3D;&gt; console.log(result));</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;); </span><br></pre></td></tr></table></figure>



<h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>但上面的代码并不是异步执行的，使用setTimeout来将onFulfilled与onRejected做为异步宏任务执行</p>
<ul>
<li><code>isfilter</code>的改变不使用setTimeout包裹，只要onReject为Function，就立即设置<code>isfilter=true</code>，这样才能够让resolve及时监听<code>isfilter</code>的改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        onResolve(this.value);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        onReject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">    if (onReject instanceof Function) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          onReject(this.value);</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          onReject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      this.isfilter &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再执行代码，已经有异步效果了，先输出了<code>阿顺特烦恼</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> new PROMISE((res, rej) =&gt; &#123;</span><br><span class="line">        // res(&quot;Ashun&quot;);</span><br><span class="line">        rej(&quot;Ashun&quot;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) =&gt; console.log(result),</span><br><span class="line">        (reason) =&gt; console.log(reason)</span><br><span class="line">      );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="PENDING异步"><a href="#PENDING异步" class="headerlink" title="PENDING异步"></a>PENDING异步</h4><p>当在PROMISE中<code>异步确认状态</code>时，then处理的是pending状态的PROMISE，所以不会执行对应的处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          res(&quot;as&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) &#x3D;&gt; console.log(result),</span><br><span class="line">        (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">      );</span><br><span class="line"># 由于处理的是pending状态的PROMISE，所以不会执行处理函数</span><br></pre></td></tr></table></figure>

<p>为了处理以上情况，需要进行几点改动</p>
<ol>
<li>在构造函数中添加callbacks来保存pending状态时处理函数，当状态改变时，即<code>resolve/reject</code>被调用时，再在<code>resolve/reject</code>函数体中调用callbacks对应状态的处理函数</li>
<li>callbacks中的处理函数也要设置为异步调用</li>
<li>只有在异步确认状态时，才会向callbacks中压入对应处理函数，所以在调用时，要判断处理函数是否存在。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(executor)&#123;</span><br><span class="line">	……</span><br><span class="line">	this.callbacks&#x3D;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">resolve(result) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.FULFILLED;</span><br><span class="line">    this.value &#x3D; result;</span><br><span class="line">    this.callbacks.onResolve &amp;&amp; this.callbacks.onResolve(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reject(reason) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">    this.status &#x3D; PROMISE.REJECTED;</span><br><span class="line">    this.value &#x3D; reason;</span><br><span class="line">    this.callbacks.onReject &amp;&amp; this.callbacks.onReject(this.value);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        if (!this.isfilter) throw new Error(&quot;PROMISE status rejected&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">          &#x2F;&#x2F;设置默认值</span><br><span class="line">          if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">            onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;同步确认状态处理，直接执行对应处理函数</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                onResolve(this.value);</span><br><span class="line">              &#125; catch (err) &#123;</span><br><span class="line">                onReject(err);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">          	 if (onReject instanceof Function) &#123;</span><br><span class="line">          	 		this.isfilter &#x3D; true;</span><br><span class="line">            		setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              		try &#123;</span><br><span class="line">               		 onReject(this.value);</span><br><span class="line">              		&#125; catch (err) &#123;</span><br><span class="line">               		 onReject(err);</span><br><span class="line">              		&#125;</span><br><span class="line">           		 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">          &#x2F;&#x2F;先将处理函数添加到callbacks中，当状态发生改变时，再在this.resolve&#x2F;reject中调用</span><br><span class="line">          if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">            this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  onResolve(result);</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                  onReject(err);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">            this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            	if (onReject instanceof Function) &#123;</span><br><span class="line">          	 		this.isfilter &#x3D; true;</span><br><span class="line">              	setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                	try &#123;</span><br><span class="line">                  	onReject(reason);</span><br><span class="line">               	 	&#125; catch (err) &#123;</span><br><span class="line">                 	 	onReject(err);</span><br><span class="line">               	 	&#125;</span><br><span class="line">              	&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>







<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p>Promise中的then是链式调用执行的，所以then也要默认返回状态为fulfilled的Promise。</p>
<ol>
<li>then的onReject函数是对前面Promise的rejected的处理</li>
<li>但默认返回的Promise状态要为fulfilled，所以在调用onRejected后，需要改变当前promise为fulfilled状态,并把执行结果传入。让下一个then得以接收</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line">  if (!(onResolve instanceof Function)) &#123;</span><br><span class="line">    onResolve &#x3D; () &#x3D;&gt; this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认返回一个PROMISE</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let preResult &#x3D; onResolve(this.value);</span><br><span class="line">          resolve(preResult);			</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let preReason &#x3D; onReject(this.value);</span><br><span class="line">            resolve(preReason);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let preResult &#x3D; onResolve(result);</span><br><span class="line">            resolve(preResult);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        if (onReject instanceof Function) &#123;</span><br><span class="line">          this.isfilter &#x3D; true;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              let preReason &#x3D; onReject(reason);</span><br><span class="line">              resolve(preReason);</span><br><span class="line">            &#125; catch (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面经过测试后，链式操作已经有效了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    reject(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; result,</span><br><span class="line">    (reason) &#x3D;&gt; reason</span><br><span class="line">  )</span><br><span class="line">  .then()</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; console.log(result),</span><br><span class="line">    (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">  );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>原生Promise.then，若在then中手动返回一个新的Promise并确认状态，这个手动返回的Promise能够改变当前then的状态，并且下一个then就是对返回的Promise的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;Promise status: fulfilled&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return Promise.reject(&quot;then status: rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(null, (err) &#x3D;&gt; console.log(err));</span><br></pre></td></tr></table></figure>

<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>我们若要实现这个效果，就要判断then返回结果的类型是否为PROMISE，若是PROMISE，我们直接调用 <code>preRusult.then(resolve,reject)</code>即可，因为调用then会等待手动返回的PROMISE确认状态后执行。</p>
<p>让手动返回的PROMISE状态改变当前then默认返回的PROMISE的状态</p>
<ul>
<li>使用then处理，若手动返回PROMISE确认状态为fulfilled,就执行默认返回PROMISE的resolve，让其状态也变为fulfilled</li>
<li>同理，若手动返回PROMISE确认状态为rejected,就执行默认返回PROMISE的reject，让其状态也变为rejected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">          &#x2F;&#x2F;设置默认值</span><br><span class="line">       		………</span><br><span class="line">          return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  let preResult &#x3D; onResolve(this.value);</span><br><span class="line">                  if (preResult instanceof PROMISE) &#123;</span><br><span class="line">                    preResult.then(resolve, reject);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    resolve(preResult);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; catch (err) &#123;</span><br><span class="line">                  reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">              if (onReject instanceof Function) &#123;</span><br><span class="line">                this.isfilter &#x3D; true;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                    let preReason &#x3D; onReject(this.value);</span><br><span class="line">                    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">                      preReason.then(resolve, reject);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      resolve(preReason);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; catch (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">              this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                    let preResult &#x3D; onResolve(result);</span><br><span class="line">                    if (preResult instanceof PROMISE) &#123;</span><br><span class="line">                      preResult.then(resolve, reject);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      resolve(preResult);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; catch (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;;</span><br><span class="line">              this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">                if (onReject instanceof Function) &#123;</span><br><span class="line">                  this.isfilter &#x3D; true;</span><br><span class="line">                  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      let preReason &#x3D; onReject(reason);</span><br><span class="line">                      if (preReason instanceof PROMISE) &#123;</span><br><span class="line">                        preReason.then(resolve, reject);</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                        resolve(preReason);</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125; catch (err) &#123;</span><br><span class="line">                      reject(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>测试能够到的正确结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashun&quot;);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;ashun&quot;);</span><br><span class="line">    rej(&quot;as&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; result,</span><br><span class="line">    (reason) &#x3D;&gt; reason</span><br><span class="line">  )</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">      res(&quot;then2 status Fulfilled&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (result) &#x3D;&gt; console.log(&#96;resolve__:$&#123;result&#125;&#96;),</span><br><span class="line">    (reason) &#x3D;&gt; console.log(&#96;rejected__:$&#123;reason&#125;&#96;)</span><br><span class="line">  );</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h4><p>现在发现pendding、fulfilled、rejected 状态的代码非常相似，所以可以提取出方法Parse来复用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line"> 	……</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(onResolve(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(onReject(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onResolve(result), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onReject(reason), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Parse(Operation, resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let preReason &#x3D; Operation;</span><br><span class="line">    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">      preReason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(preReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回约束"><a href="#返回约束" class="headerlink" title="返回约束"></a>返回约束</h4><p>then手动返回的promise不能是then默认返回Promise，会产生循环调用，下面是原生Promise的示例将产生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((res, rej) =&gt; &#123;</span><br><span class="line">        res(&quot;fulfilled&quot;);</span><br><span class="line">      &#125;).then((result) =&gt; promise);</span><br></pre></td></tr></table></figure>

<p>解决上面的问题来完善代码，添加当前promise做为parse的第一个参数与函数执行结果进行比对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onResolve, onReject) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置默认值</span><br><span class="line"> 	……</span><br><span class="line">  let promise &#x3D; new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.FULFILLED) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.Parse(promise, onResolve(this.value), resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED) &#123;</span><br><span class="line">      if (onReject instanceof Function) &#123;</span><br><span class="line">        this.isfilter &#x3D; true;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(onReject(this.value), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步确认状态处理</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">      this.callbacks.onResolve &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.Parse(promise, onResolve(result), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.callbacks.onReject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">        if (onReject instanceof Function) &#123;</span><br><span class="line">          this.isfilter &#x3D; true;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            this.Parse(onReject(reason), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parse(promise, Operation, resolve, reject) &#123;</span><br><span class="line">  if (promise &#x3D;&#x3D;&#x3D; Operation) &#123;</span><br><span class="line">    throw new Error(&quot;Chaining cycle detected for promise&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    let preReason &#x3D; Operation;</span><br><span class="line">    if (preReason instanceof PROMISE) &#123;</span><br><span class="line">      preReason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(preReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在进行测试也可以得到原生一样效果了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;fulfilled&quot;);</span><br><span class="line">&#125;).then((result) &#x3D;&gt; promise);</span><br></pre></td></tr></table></figure>



<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="RESOLVE"><a href="#RESOLVE" class="headerlink" title="RESOLVE"></a>RESOLVE</h4><p>下面来实现原生Promise的静态方法<code>Promise.resolve</code>用于快速返回一个状态为resolve的Promise</p>
<ul>
<li><p>默认返回Promise</p>
</li>
<li><p>同样需要注意返回类型，若为PROMISE，则使用then处理的就是返回的PROMISE</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(</span><br><span class="line">  new Promise((res) &#x3D;&gt; res(&quot;ashuntefannao&quot;))</span><br><span class="line">).then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>

<p>创建静态方法<code>static resolve</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static resolve(value) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (value instanceof PROMISE) &#123;</span><br><span class="line">      value.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROMISE.resolve(</span><br><span class="line">  new PROMISE((res, rej) &#x3D;&gt; rej(&quot;ashuntefannao&quot;))</span><br><span class="line">).then(null, (reason) &#x3D;&gt; console.log(&#96;rejected__$&#123;reason&#125;&#96;));</span><br><span class="line"></span><br><span class="line">PROMISE.resolve(&quot;ashun&quot;).then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>



<h4 id="REJECT"><a href="#REJECT" class="headerlink" title="REJECT"></a>REJECT</h4><p>封装思想和<code>resolve</code>静态方法相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (reason instanceof PROMISE) &#123;</span><br><span class="line">      reason.then(resolve, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROMISE.reject(&quot;rejected&quot;).then(null, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">PROMISE.reject(PROMISE.resolve(&quot;阿顺特烦恼&quot;)).then((val) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>原生Promise的静态方法all</p>
<ul>
<li>接收一个PromiseArray，并按顺序对PromiseArray中的promise进行判断和处理</li>
<li>若存在一个promise没有确定状态，则all返回的Promise也为pending状态</li>
<li>若存在一个promise状态为rejected，则all返回的Promise也为rejected状态，并且后续的then能够接收到拒绝状态的promise传值。</li>
<li>若所有promise状态都为fulfilled，则返回一个有序的、元素为promise结果的数组</li>
</ul>
<p>由于all是有序处理，所以我们需要通过遍历，按顺序处理业务逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static all(PROMISEarr) &#123;</span><br><span class="line">  let resolveArr &#x3D; [];</span><br><span class="line">  let test &#x3D; true;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    for (let promise of PROMISEarr) &#123;</span><br><span class="line">      let isPending &#x3D; promise.status &#x3D;&#x3D;&#x3D; PROMISE.PENDING;</span><br><span class="line">      let isReject &#x3D; promise.status &#x3D;&#x3D;&#x3D; PROMISE.REJECTED;</span><br><span class="line"></span><br><span class="line">      if (isPending) &#123;</span><br><span class="line">        test &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      &#125; else if (isReject) &#123;</span><br><span class="line">        test &#x3D; false;</span><br><span class="line">        promise.then(null, (reason) &#x3D;&gt; reject(reason));</span><br><span class="line">        break;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        promise.then((res) &#x3D;&gt; resolveArr.push(res));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test &amp;&amp; resolve(resolveArr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例可自行改变某个promise的状态，来检测不同结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p2 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let all &#x3D; PROMISE.all(arr).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(result),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(all);</span><br><span class="line">&#125;, 100);</span><br></pre></td></tr></table></figure>



<h4 id="RACE"><a href="#RACE" class="headerlink" title="RACE"></a>RACE</h4><ul>
<li><code>race(PromiseArray)</code>赛跑，哪个Promise优先确认状态，就返回哪个Promise</li>
<li>一开始我们就已经实现了promise状态一经确定，就不可再改变</li>
<li>所以在实现的时候，我们只需循环调用每一个promise的then方法，哪个最先确认状态，就会优先执行then，我们可以通过then的两个回调函数，来改变当前默认返回的Promsie的状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static race(PROMISEarr) &#123;</span><br><span class="line">  return new PROMISE((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    PROMISEarr.map((promise) &#x3D;&gt; &#123;</span><br><span class="line">      promise.then(resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例可自行改变某个promise确认状态的延迟时间，来检测不同结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let race &#x3D; PROMISE.race(arr).then(</span><br><span class="line">  (result) &#x3D;&gt; console.log(&#96;result__$&#123;result&#125;&#96;),</span><br><span class="line">  (reason) &#x3D;&gt; console.log(&#96;reason__$&#123;reason&#125;&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(race);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>



<h4 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h4><ul>
<li>不在乎状态拒绝与否，所有的promise确认状态后，将会返回有序结果，且返回的promise状态为fulfilled。</li>
<li>若有一个promise没有确认状态，则allSettled默认返回的promise状态也为fulfilled，也就不会执行后续的then</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static allSettled(PROMISEarr) &#123;</span><br><span class="line">  let results &#x3D; [];</span><br><span class="line">  let isPending &#x3D; true;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    for (let promise of PROMISEarr) &#123;</span><br><span class="line">      if (promise.status &#x3D;&#x3D; PROMISE.PENDING) &#123;</span><br><span class="line">        isPending &#x3D; true;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      let status &#x3D; promise.status;</span><br><span class="line">      let value &#x3D; promise.value;</span><br><span class="line">      promise.then(</span><br><span class="line">        (result) &#x3D;&gt; &#123;</span><br><span class="line">          results.push(&#123; status, value &#125;);</span><br><span class="line">          if (results.length &#x3D;&#x3D; PROMISEarr.length) resolve(results);</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) &#x3D;&gt; &#123;</span><br><span class="line">          results.push(&#123; status, reason: value &#125;);</span><br><span class="line">          if (results.length &#x3D;&#x3D; PROMISEarr.length) resolve(results);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p1 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">  res(&quot;p3 stastus fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [p1, p2, p3];</span><br><span class="line">let allSettled &#x3D; PROMISE.allSettled(arr).then((result) &#x3D;&gt;</span><br><span class="line">  console.log(result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(allSettled);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>

<p>若有一个promise始终没有确认状态，则allSettled默认返回的promise状态也为pending。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      let p2 &#x3D; new PROMISE((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;rej(&quot;p2 stastus rejected&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>事件</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在文档、浏览器、标签元素等元素在特定状态下触发的行为即为事件，比如用户的单击行为、表单内容的改变行为即为事件，我们可以为不同的事件定义处理程序。JS使用异步事件驱动的形式管理事件。</p>
<p><strong>事件类型</strong></p>
<p>JS为不同的事件定义的类型，也可以称为事件名称。</p>
<p><strong>事件目标</strong></p>
<p>事件目标指触发事件的对象，比如a标签被点击那么a标签就是事件目标。元素是可以嵌套的，所以在进行一次点击行为时可能会触发多个事件目标(事件冒泡)。</p>
<h3 id="处理程序"><a href="#处理程序" class="headerlink" title="处理程序"></a>处理程序</h3><p>事件的目的是要执行一段代码，我们称这类代码块为事件处理（监听）程序。当在对象上触发事件时就会执行定义的事件处理程序。</p>
<h4 id="HTML绑定"><a href="#HTML绑定" class="headerlink" title="HTML绑定"></a>HTML绑定</h4><p>可以在html元素上设置事件处理程序，浏览器解析后会绑定到DOM属性中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(`Ashuntefannao`)&quot;&gt;阿顺特烦恼&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>往往事件处理程序业务比较复杂，所以绑定方法或函数会很常见</p>
<ul>
<li>绑定函数或方法时需要加上括号</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;show()&quot;&gt;阿顺特烦恼&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function show() &#123;</span><br><span class="line">    alert(&#x27;Ashuntefannao&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用对象方法做为事件处理程序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; onkeyup=&quot;SHUN.show()&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  class SHUN &#123;</span><br><span class="line">    static show() &#123;</span><br><span class="line">      console.log(&#x27;Ashun&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以传递事件源对象与事件对象</p>
<ul>
<li>传入<code>this</code>指向事件源span元素</li>
<li>传入<code>event</code>指向事件对象，可通过其访问各种事件处理的属性/方法。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- this指向span元素，event为事件对象，--&gt;</span><br><span class="line">&lt;span onclick=&quot;show(this,&#x27;Ashun&#x27;,&#x27;阿顺特烦恼&#x27;,event)&quot;&gt;ASHUN&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function show(...args) &#123;</span><br><span class="line">        console.log(args)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="DOM绑定"><a href="#DOM绑定" class="headerlink" title="DOM绑定"></a>DOM绑定</h4><p>也可以将事件处理程序绑定到DOM属性中</p>
<ul>
<li>使用setAttribute方法设置事件处理程序无效</li>
<li>属性名区分大小写</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>无法为事件类型绑定多个事件处理程序，下面绑定了多个事件处理程序，因为属性是相同的所以只有最后一个有效</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  app.onclick = function () &#123;</span><br><span class="line">    this.style.fontSize = &#x27;55px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>通过上面的说明我们知道使用HTML与DOM绑定事件都有缺陷，建议使用新的事件监听绑定方式addEventListener 操作事件</p>
<p>使用addEventListener添加事件处理程序有以下几个特点</p>
<ul>
<li>transtionend / DOMContentLoaded 等事件类型只能使用 addEventListener 处理</li>
<li>同一事件类型可以设置多个事件处理程序，按设置的顺序先后执行</li>
<li>也可以对未来添加的元素绑定事件</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>addEventListener</td>
<td>添加事件处理程序</td>
</tr>
<tr>
<td>removeEventListener</td>
<td>移除事件处理程序</td>
</tr>
</tbody></table>
<p>addEventListener的参数说明如下</p>
<ol>
<li>参数一事件类型</li>
<li>参数二事件处理程序callback<ul>
<li>callback默认接收<code>event事件对象</code>参数</li>
</ul>
</li>
<li>参数三为定制的选项，可传递object或boolean类型。后面会详细介绍使用区别</li>
</ol>
<h4 id="绑定多个事件"><a href="#绑定多个事件" class="headerlink" title="绑定多个事件"></a>绑定多个事件</h4><p>使用addEventListener来多个事件处理程序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.style.fontSize = &#x27;55px&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通过对象绑定"><a href="#通过对象绑定" class="headerlink" title="通过对象绑定"></a>通过对象绑定</h4><p><code>事件处理程序可以是对象</code>，对象的 handleEvent 方法会做为事件处理程序执行。下面将元素的事件统一交由对象处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  class Events &#123;</span><br><span class="line">    handleEvent(e) &#123;</span><br><span class="line">      this[e.type](e)</span><br><span class="line">    &#125;</span><br><span class="line">    click() &#123;</span><br><span class="line">      console.log(&#x27;单击事件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    mouseover() &#123;</span><br><span class="line">      console.log(&#x27;鼠标悬停事件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, new Events())</span><br><span class="line">  app.addEventListener(&#x27;mouseover&#x27;, new Events())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h4><p>使用removeEventListener删除事先绑定的事件处理函数</p>
<ul>
<li>事件处理程序单独定义函数或方法，这可以保证访问的事件处理程序是同一个</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;button id=&quot;rmEvent&quot;&gt;删除事件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  const rm = document.querySelector(&#x27;#rmEvent&#x27;)</span><br><span class="line">  function show(event) &#123;</span><br><span class="line">  	console.log(event.target)</span><br><span class="line">    console.log(&#x27;APP我执行了&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, show)</span><br><span class="line">  rm.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    app.removeEventListener(&#x27;click&#x27;, show)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="事件选项"><a href="#事件选项" class="headerlink" title="事件选项"></a>事件选项</h4><p>addEventListener的第三个参数为定制的选项，可传递object或boolean类型</p>
<p>下面是传递对象时的说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>可选参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>once</td>
<td>true/false</td>
<td>只执行一次事件</td>
</tr>
<tr>
<td>capture</td>
<td>true/false</td>
<td>事件是在捕获/冒泡哪个阶段执行，true:捕获阶段 false:冒泡阶段，默认为false</td>
</tr>
<tr>
<td>passive</td>
<td>true/false</td>
<td>声明事件里不会判断 <code>preventDefault()</code>，可以减少系统默认行为的等待</td>
</tr>
</tbody></table>
<p>传递Boolean时</p>
<ul>
<li>true：事件捕获方式执行，等同于参数<code>&#123;capture:true&#125;</code></li>
<li>false：事件冒泡方式执行，等同于参数<code>&#123;capture:false&#125;</code></li>
</ul>
<p><strong>事件捕获</strong></p>
<p>事件执行顺序：最顶层window-&gt;最底层触发事件的dom</p>
<p><strong>事件冒泡</strong></p>
<p>事件执行顺序与事件捕获相反</p>
<p>下面使用once:true 来指定事件只执行一次</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;app&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;阿顺特烦恼_Ashun&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; once: true &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置 <code>&#123; capture: true &#125;</code> 或直接设置第三个参数为true用来在捕获阶段执行事件</p>
<blockquote>
<p>addEventListener的第三个参数传递true/false 和设置 {capture:true/false}是一样</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;background-color: red&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;bt&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    const bt = document.querySelector(&#x27;#bt&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是div事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: true &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bt.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是按钮事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: true &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置 <code>&#123; capture: false &#125;</code> 或 直接设置第三个参数为false 或 不设置第三个参数(默认为false), 用来在冒泡阶段执行事件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;background-color: red&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;bt&quot;&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">    const bt = document.querySelector(&#x27;#bt&#x27;)</span><br><span class="line">    app.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是div事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: false &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bt.addEventListener(</span><br><span class="line">        &#x27;click&#x27;,</span><br><span class="line">        function () &#123;</span><br><span class="line">            alert(&#x27;这是按钮事件 &#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; capture: false &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>passive</code>选项:   声明事件里不会判断 <code>preventDefault()</code>，可以减少系统默认行为的等待</p>
<p>很多移动端的页面都会监听 touchstart 等 touch 事件，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&quot;touchstart&quot;, function(e)&#123;</span><br><span class="line">    ... &#x2F;&#x2F; 浏览器不知道这里会不会有 e.preventDefault()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>执行事件处理程序时，会产生包含当前事件相关信息的对象，即为事件对象。<strong>系统会自动做为参数传递给事件处理程序</strong>。</p>
<ul>
<li>大部分浏览器将事件对象保存到window.event中</li>
<li>有些浏览器会将事件对象做为事件处理程序的参数传递</li>
</ul>
<p>事件对象常用属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>事件类型</td>
</tr>
<tr>
<td>target</td>
<td>事件目标对象，冒泡方式时父级对象可以通过该属性找到在哪个子元素上最终执行事件</td>
</tr>
<tr>
<td>currentTarget</td>
<td>当前执行事件的对象</td>
</tr>
<tr>
<td>timeStamp</td>
<td>事件发生时间</td>
</tr>
<tr>
<td>x</td>
<td>相对窗口的X坐标</td>
</tr>
<tr>
<td>y</td>
<td>相对窗口的Y坐标</td>
</tr>
<tr>
<td>clientX</td>
<td>相对窗口的X坐标</td>
</tr>
<tr>
<td>clientY</td>
<td>相对窗口的Y坐标</td>
</tr>
<tr>
<td>screenX</td>
<td>相对计算机屏幕的X坐标</td>
</tr>
<tr>
<td>screenY</td>
<td>相对计算机屏幕的Y坐标</td>
</tr>
<tr>
<td>pageX</td>
<td>相对于文档的X坐标</td>
</tr>
<tr>
<td>pageY</td>
<td>相对于文档的Y坐标</td>
</tr>
<tr>
<td>offsetX</td>
<td>相对于事件对象的X坐标</td>
</tr>
<tr>
<td>offsetY</td>
<td>相对于事件对象的Y坐标</td>
</tr>
<tr>
<td>layerX</td>
<td>相对于父级定位的X坐标</td>
</tr>
<tr>
<td>layerY</td>
<td>相对于父级定位的Y坐标</td>
</tr>
<tr>
<td>path</td>
<td>冒泡的路径</td>
</tr>
<tr>
<td>altKey</td>
<td>是否按了alt键</td>
</tr>
<tr>
<td>shiftKey</td>
<td>是否按了shift键</td>
</tr>
<tr>
<td>metaKey</td>
<td>是否按了媒体键</td>
</tr>
<tr>
<td>window.pageXOffset</td>
<td>文档参考窗口水平滚动的距离</td>
</tr>
<tr>
<td>window.pageYOffset</td>
<td>文档参考窗口垂直滚动的距离</td>
</tr>
</tbody></table>
<h3 id="冒泡捕获"><a href="#冒泡捕获" class="headerlink" title="冒泡捕获"></a>冒泡捕获</h3><h4 id="冒泡行为"><a href="#冒泡行为" class="headerlink" title="冒泡行为"></a>冒泡行为</h4><p>事件默认是冒泡执行的：标签元素是嵌套的，在一个元素上触发的事件，同时也会向上触发父级元素对应的事件处理程序，一直到最顶层window。</p>
<ul>
<li>大部分事件都会冒泡，但像focus事件则不会</li>
<li>event.target <code>指向事件链中最底层事件的对象</code></li>
<li>event.currentTarget == this 即当前执行事件的对象</li>
</ul>
<p>以下示例有标签的嵌套，并且父子标签都设置了事件，当在子标签上触发事件事会冒泡执行父级标签的事件，直至window</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      #app &#123;</span><br><span class="line">        height: 70px;</span><br><span class="line">        background-color: #95a5a6;</span><br><span class="line">      &#125;</span><br><span class="line">      strong &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #f39c12;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">      const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">      const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line">      </span><br><span class="line">      window.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;window Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      document.documentElement.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;html Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;App Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下例无论点击哪个元素，都会变为<strong>蓝色</strong></p>
<ul>
<li><code>event.target</code>指向事件链中的最底层的事件对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      article &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background: #5f27cd;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      section &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: #ff9f43;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">      &lt;section&gt;&lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#0abde3&quot;; &#x2F;&#x2F; 祖先级body改蓝色</span><br><span class="line">      console.log(event.target);	&#x2F;&#x2F;由于冒泡执行，点击任意元素，该语句都会执行</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#ee5253&quot;; &#x2F;&#x2F; 父级article改红色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.target.style.background &#x3D; &quot;#10ac84&quot;; &#x2F;&#x2F; 子级section改绿色</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>若通过<code>event.currentTarget</code>处理当前所触发事件的元素，则更改的颜色就会对应起来</p>
<ul>
<li>由于事件冒泡，点击某个元素，也会导致其祖先元素的更改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#0abde3&quot;; &#x2F;&#x2F; 祖先级body改蓝色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#ee5253&quot;; &#x2F;&#x2F; 父级article改红色</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#10ac84&quot;; &#x2F;&#x2F; 子级section改绿色</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><p>冒泡过程中的任何事件处理程序中，都可以执行 <code>event.stopPropagation/stopImmediatePropagation()</code> 方法阻止继续进行冒泡传递</p>
<ul>
<li>event.stopPropagation() 用于阻止冒泡</li>
<li>event.stopImmediatePropagation() 阻止<code>事件冒泡</code>并且阻止<code>相同事件类型的其他事件处理函数被调用</code></li>
</ul>
<p>使用event.stopPropagation处理冒泡行为中的例子，通过阻止冒泡，点击某个元素，不会影响祖先元素的背景颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">    document.body.addEventListener(&quot;click&quot;, (evnet) &#x3D;&gt; &#123;</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#0abde3&quot;;</span><br><span class="line">      console.log(event.target);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;article&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#ee5253&quot;;</span><br><span class="line">      console.log(event.currentTarget);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.querySelector(&quot;section&quot;).addEventListener(&quot;click&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">      event.currentTarget.style.background &#x3D; &quot;#10ac84&quot;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><code>stopPropagation</code>只是阻止冒泡，不会阻止相同事件类型的其它事件处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">	&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> 			const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">      const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line"></span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;App Method&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        console.log(&quot;strong Method__1&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__2&quot;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>点击strong，打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;strong Method__1</span><br><span class="line">&#x2F;&#x2F;strong Method__2</span><br></pre></td></tr></table></figure>

<p>若将上述代码中的<code>stopPropagation</code>改为<code>stopImmediatePropagation</code>，则也会阻止相同事件的其它处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">点击strong，打印结果: &#x2F;&#x2F;strong Method__1</span><br></pre></td></tr></table></figure>



<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获：事件执行顺序与冒泡行为相反，会由事件链的最顶层window逐步向下传递执行。事件捕获在实际使用中频率不高。</p>
<ul>
<li><p>通过设置第三个参数为true或{ capture: true } 在捕获阶段执行事件处理程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      #app &#123;</span><br><span class="line">        height: 70px;</span><br><span class="line">        background-color: #95a5a6;</span><br><span class="line">      &#125;</span><br><span class="line">      strong &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #f39c12;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      Ashuntefannao</span><br><span class="line">      &lt;strong&gt;MyStrong&lt;&#x2F;strong&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     const app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line">     const strong &#x3D; document.querySelector(&quot;strong&quot;);</span><br><span class="line"></span><br><span class="line">      app.addEventListener(</span><br><span class="line">        &quot;click&quot;,</span><br><span class="line">        () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&quot;App Method&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        true</span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      strong.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__1&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      strong.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;strong Method__2&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>由于在给<code>#app</code>添加事件时，第三个参数设置为<code>true/&#123;capture:true&#125;</code>,在事件捕获阶段执行，所以在点击<code>strong</code>时，会先执行<code>#app</code>的事件处理程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 结果</span><br><span class="line">App Method</span><br><span class="line">strong Method__1</span><br><span class="line">strong Method__2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>借助冒泡思路，我们可以不为子元素设置事件，而将事件设置在父级。然后通过父级事件对象的<code>event.target</code>查找事件链底层的元素，并对它做出处理。</p>
<ul>
<li>这在为多个元素添加相同事件时很方便</li>
<li>会使添加事件变得非常容易</li>
</ul>
<p>下面是为父级UL设置事件来控制子元素LI的样式切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      .active &#123;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        background-color: #eee;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;阿顺&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;Ashuntefannao&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   document.querySelector(&quot;ul&quot;).addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">      e.target.classList.toggle(&quot;active&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用事件代理来共享事件处理程序，不用为每个元素单独绑定事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li data-action&#x3D;&quot;border&quot; data-border&#x3D;&quot;2px solid #aaa&quot;&gt;阿顺&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-action&#x3D;&quot;color&quot; data-color&#x3D;&quot;red&quot;&gt;Ashuntefannao&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class Event &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          let action &#x3D; e.target.dataset.action;</span><br><span class="line">          this[action](e.target);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      border(event) &#123;</span><br><span class="line">        event.style.border &#x3D; event.dataset.border;</span><br><span class="line">      &#125;</span><br><span class="line">      color(event) &#123;</span><br><span class="line">        console.log(event.dataset);</span><br><span class="line">        event.style.color &#x3D; event.dataset.color;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new Event(document.querySelector(&quot;ul&quot;));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是使用事件代理实现的TAB面板效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">			.tab &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      dl &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line">      dt,</span><br><span class="line">      dd &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        color: white;</span><br><span class="line">      &#125;</span><br><span class="line">      dt &#123;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background-color: #34495e;</span><br><span class="line">      &#125;</span><br><span class="line">      dd &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 60px;</span><br><span class="line">        background-color: #e67e22;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt data-action&#x3D;&quot;toggle&quot;&gt;阿顺特烦恼&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd data-action&#x3D;&quot;hidden&quot;&gt;Ashuntefannao&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;dt data-action&#x3D;&quot;toggle&quot;&gt;阿顺&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd data-action&#x3D;&quot;hidden&quot;&gt;Ashun&lt;&#x2F;dd&gt;</span><br><span class="line">      &lt;&#x2F;dl&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class Card &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          let action &#x3D; e.target.dataset.action;</span><br><span class="line">          this[action](e);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      toggle(event) &#123;</span><br><span class="line">        event.target</span><br><span class="line">          .querySelectorAll(&quot;[data-action&#x3D;&#39;hidden&#39;]&quot;)</span><br><span class="line">          .forEach((elem) &#x3D;&gt; (elem.hidden &#x3D; true));</span><br><span class="line">        event.target.nextElementSibling.hidden &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">      hidden(event) &#123;</span><br><span class="line">        event.target.hidden &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new Card(document.querySelector(&quot;.tab&quot;));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面实现通过代理事件行为，在表单提交时禁用提交按钮，并记录提示次数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;button type=&quot;button&quot; data-submit-disabled data-action=&quot;submit,counter&quot;&gt;提交表单&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class FORM &#123;</span><br><span class="line">      constructor(el) &#123;</span><br><span class="line">        this.$el = el;</span><br><span class="line">        this.sum = 0;</span><br><span class="line">        el.addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class="line">          let actions = e.target.dataset.action;</span><br><span class="line">          actions &amp;&amp;</span><br><span class="line">            actions.split(&quot;,&quot;).forEach((method) =&gt; &#123;</span><br><span class="line">              this[method](e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      submit(e) &#123;</span><br><span class="line">        this.disabled(e, true);</span><br><span class="line">        console.log(&quot;正在提交&quot;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;提交成功！&quot;);</span><br><span class="line">          this.disabled(e, false);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;</span><br><span class="line">      disabled(event, boolean) &#123;</span><br><span class="line">        this.$el</span><br><span class="line">          .querySelectorAll(&quot;[data-submit-disabled]&quot;)</span><br><span class="line">          .forEach((btn) =&gt; (btn.disabled = boolean));</span><br><span class="line">      &#125;</span><br><span class="line">      counter() &#123;</span><br><span class="line">        console.log(`提交次数:$&#123;++this.sum&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new FORM(document.querySelector(&quot;form&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="未来元素"><a href="#未来元素" class="headerlink" title="未来元素"></a>未来元素</h4><p>下面使用事件代理来对未来元素进行事件绑定</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(this.textContent)</span><br><span class="line">  &#125;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    show.call(event.target)</span><br><span class="line">  &#125;)</span><br><span class="line">  let newH2 = document.createElement(&#x27;h2&#x27;)</span><br><span class="line">  newH2.textContent = &#x27;Ashuntefannao&#x27;</span><br><span class="line">  app.append(newH2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以将这个功能封装起来，用来代理某一类未来元素的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;section&gt;My name is Section&lt;&#x2F;section&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Element.prototype.on &#x3D; function (EventType, Element, func) &#123;</span><br><span class="line">      this.addEventListener(EventType, (event) &#x3D;&gt; &#123;</span><br><span class="line">        if (event.target.tagName &#x3D;&#x3D;&#x3D; Element.toUpperCase()) &#123;</span><br><span class="line">          func(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let app &#x3D; document.querySelector(&quot;#app&quot;);</span><br><span class="line"></span><br><span class="line">    app.on(&quot;click&quot;, &quot;h2&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(event.target);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let h2 &#x3D; document.createElement(&quot;h2&quot;);</span><br><span class="line">    h2.innerText &#x3D; &quot;Ashuntefannao&quot;;</span><br><span class="line">    app.append(h2);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><p>JS中有些对象会设置默认事件处理程序，比如A链接在点击时会进行跳转，点击submit会提交表单信息…</p>
<p>一般默认处理程序会在用户定义的处理程序后执行，我们可以在事件处理函数中取消默认事件的执行。</p>
<ul>
<li>使用onclick绑定的事件处理程序，return false 可以阻止默认行为</li>
<li>推荐使用<code>event.preventDefault()</code>阻止默认行为</li>
</ul>
<p>下面阻止超链接的默认行为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下，你就知道&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.querySelector(&#x27;a&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    alert(event.target.innerText)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="文档事件"><a href="#文档事件" class="headerlink" title="文档事件"></a>文档事件</h3><p>下面来学习针对文档事件的处理。</p>
<h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>window.onload</td>
<td>文档解析及外部资源加载后</td>
</tr>
<tr>
<td>DOMContentLoaded</td>
<td>文档解析后执行，不需要等待图片/样式文件等外部资源加载，该事件只能通过addEventListener设置</td>
</tr>
<tr>
<td>window.onbeforeunload</td>
<td>文档刷新或关闭时</td>
</tr>
<tr>
<td>window.onunload</td>
<td>文档卸载时</td>
</tr>
<tr>
<td>scroll</td>
<td>页面滚动时</td>
</tr>
</tbody></table>
<h4 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h4><p>window.onload事件在文档解析后及图片、外部样式文件等资源加载完后执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function () &#123;</span><br><span class="line">    alert(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h4 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h4><p>DOMContentLoaded事件在文档标签解析后执行，不需要等外部图片、样式文件、JS文件等资源加载</p>
<ul>
<li>该事件只能够通过<code>addEventListener</code>添加</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;</span><br><span class="line">    alert(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h4 id="onbeforeunload"><a href="#onbeforeunload" class="headerlink" title="onbeforeunload"></a>onbeforeunload</h4><p>当浏览器窗口关闭或者刷新时，会触发beforeunload事件，可以取消关闭或刷新页面。</p>
<ul>
<li>返回值为非空字符串时，有些浏览器会做为弹出的提示信息内容</li>
<li>部分浏览器使用addEventListener无法绑定事件</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">window.onbeforeunload = function (e) &#123;</span><br><span class="line">  return &#x27;真的要离开吗？&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="unload"><a href="#unload" class="headerlink" title="unload"></a>unload</h4><p>window.unload事件在文档资源被卸载时执行，在beforeunload后执行</p>
<ul>
<li>不能执行alert、confirm等交互指令</li>
<li>发生错误也不会阻止页面关闭或刷新</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//文档被关闭时，在localStorage中存储用户信息</span><br><span class="line">window.addEventListener(&#x27;unload&#x27;, function (e) &#123;</span><br><span class="line">  localStorage.setItem(&#x27;name&#x27;, &#x27;Ashun&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h4 id="事件类型-1"><a href="#事件类型-1" class="headerlink" title="事件类型"></a>事件类型</h4><p>针对鼠标操作的行为有多种事件类型</p>
<ul>
<li>鼠标事件会触发在Z-INDEX 层级最高的那个元素上</li>
</ul>
<table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>click</td>
<td>鼠标单击事件，同时触发 mousedown/mouseup</td>
</tr>
<tr>
<td>dblclick</td>
<td>鼠标双击事件</td>
</tr>
<tr>
<td>contextmenu</td>
<td>点击右键后显示的所在环境的菜单</td>
</tr>
<tr>
<td>mousedown</td>
<td>鼠标按下</td>
</tr>
<tr>
<td>mouseup</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>mousemove</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>mouseover</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>mouseout</td>
<td>鼠标从元素上离开时</td>
</tr>
<tr>
<td>mouseup</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>mouseenter</td>
<td>鼠标移入时触发，不产生冒泡行为</td>
</tr>
<tr>
<td>mosueleave</td>
<td>鼠标移出时触发，不产生冒泡行为</td>
</tr>
<tr>
<td>oncopy</td>
<td>复制内容时触发</td>
</tr>
<tr>
<td>scroll</td>
<td>元素滚动时，可以为元素设置overflow:auto; 产生滚动条来测试</td>
</tr>
</tbody></table>
<h4 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&#x27;copy&#x27;, () =&gt; &#123;</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  alert(&#x27;禁止复制内容&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="relatedTarget"><a href="#relatedTarget" class="headerlink" title="relatedTarget"></a>relatedTarget</h4><p>relatedTarget是控制鼠标移动事件的来源和目标对象的</p>
<ul>
<li>如果移动过快会跳转中间对象</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  const shun = document.querySelector(`#shun`)</span><br><span class="line">  app.addEventListener(&#x27;mouseout&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(event.target)</span><br><span class="line">    console.log(event.relatedTarget)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="mouseenter与mouseleave"><a href="#mouseenter与mouseleave" class="headerlink" title="mouseenter与mouseleave"></a>mouseenter与mouseleave</h4><p>mouseenter与mouseleave事件从子元素移动到父元素时不触发父元素事件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    background: #e74c3c;</span><br><span class="line">    padding: 80px;</span><br><span class="line">    width: 500px;</span><br><span class="line">  &#125;</span><br><span class="line">  #shun &#123;</span><br><span class="line">    background: #f39c12;</span><br><span class="line">    padding: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"> 	Ashuntefannao</span><br><span class="line">  &lt;div id=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  const shun = document.querySelector(`#shun`)</span><br><span class="line"></span><br><span class="line">  app.addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;app&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  shun.addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;shun&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>针对键盘输入操作的行为有多种事件类型</p>
<table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Keydown</td>
<td>键盘按下时，一直按键不松开时keydown事件会重复触发</td>
</tr>
<tr>
<td>keyup</td>
<td>按键抬起时</td>
</tr>
<tr>
<td>keypress</td>
<td>按键 按下、抬起 都会触发，一直按键不松开也会持续触发</td>
</tr>
</tbody></table>
<h4 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h4><p>键盘事件产生的事件对象包含相对应的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keyCode</td>
<td>返回键盘的ASCII字符数字</td>
</tr>
<tr>
<td>code</td>
<td>按键码，字符以Key开始，数字以Digit开始，特殊字符有专属名子。左右ALT键字符不同。 不同布局的键盘值会不同</td>
</tr>
<tr>
<td>key</td>
<td>按键的字符含义表示，大小写不同。不能区分左右ALT等。不同语言操作系统下值会不同</td>
</tr>
<tr>
<td>altKey</td>
<td>是否按了alt键</td>
</tr>
<tr>
<td>ctrlKey</td>
<td>是否按了ctlr键</td>
</tr>
<tr>
<td>shiftKey</td>
<td>是否按了shift键</td>
</tr>
<tr>
<td>metaKey</td>
<td>是否按了媒体键</td>
</tr>
</tbody></table>
<hr>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>下面是可以用在表单上的事件类型</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>focus</td>
<td>获取焦点事件</td>
</tr>
<tr>
<td>blur</td>
<td>失去焦点事件</td>
</tr>
<tr>
<td>element.focus()</td>
<td>让元素强制获取焦点</td>
</tr>
<tr>
<td>element.blur()</td>
<td>让元素失去焦点</td>
</tr>
<tr>
<td>change</td>
<td>文本框在<code>内容发生改变</code>并<code>失去焦点</code>时触发</td>
</tr>
<tr>
<td>input</td>
<td><code>value</code> 被修改时，会触发 <code>input</code> 事件</td>
</tr>
<tr>
<td>submit</td>
<td>提交表单时触发</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>函数进阶</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><p>​    函数是将复用的代码块封装起来的模块，在JS中函数还有其他语言所不具有的特性，接下来我们会详细掌握使用技巧。</p>
<h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p>在JS中函数也是对象函数是<code>Function</code>类创建的实例，下面的例子可以方便理解函数是对象。</p>
<ul>
<li><code>new Function(...argus,funcContent)</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let fun = new Function(&quot;title&quot;, &quot;type&quot;, &quot;console.log(title,type)&quot;);</span><br><span class="line">fun(&quot;Ashun&quot;, &quot;Controller&quot;);</span><br></pre></td></tr></table></figure>

<p>标准语法是：使用函数声明来定义函数</p>
<ul>
<li><code>function funcName(argus)&#123;…funcContent&#125;</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function as(num) &#123;</span><br><span class="line">	return num+=2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(as(3));</span><br></pre></td></tr></table></figure>

<p>对象字面量属性函数简写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: null,</span><br><span class="line">  getName: function (name) &#123;</span><br><span class="line">  	return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  //简写形式</span><br><span class="line">  setName(value) &#123;</span><br><span class="line">  	this.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.setName(&#x27;阿顺&#x27;);</span><br><span class="line">console.log(user.getName()); // 阿顺</span><br></pre></td></tr></table></figure>

<p>普通形式定义的全局函数会声明在window对象中，这很危险，建议使用后面章节的模块处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Ashun() &#123;</span><br><span class="line">	console.log(&quot;普通形式定义的全局函数，会追加到window中&quot;);</span><br><span class="line">	console.log(window.Ashun);</span><br><span class="line">&#125;</span><br><span class="line">Ashun();</span><br></pre></td></tr></table></figure>

<p>再比如：当我们定义了 <code>screenX</code> 函数后就覆盖了window.screenX方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(window.screenX); 	&#x2F;&#x2F;999</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function screenX() &#123;</span><br><span class="line">  return &quot;阿顺&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(window.screenX); </span><br></pre></td></tr></table></figure>

<p>使用<code>let/const</code>时不会压入window</p>
<ul>
<li>注意：使用变量接收定义的函数时，整体为表达式，必须以<code>;</code>结尾，不然会报错。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let func = function as() &#123;</span><br><span class="line">	return &quot;Ashuntefannao.com&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(window.func); //undefined</span><br></pre></td></tr></table></figure>



<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    函数是对象，所以可以通过赋值，指向到函数对象的指针，当然指针也可以传递给其他变量，注意结尾要以<code>;</code>结束(整体为表达式)。下面使用函数表达式将 <code>匿名函数</code> 赋值给变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = function(num) &#123;</span><br><span class="line">  return num+=2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(as instanceof Object); //true</span><br><span class="line"></span><br><span class="line">let tfn = as;</span><br><span class="line">console.log(tfn(3));</span><br></pre></td></tr></table></figure>

<p>标准声明的函数优先级更高，解析器会优先提取函数并放在代码树顶端，所以标准声明函数位置不限制，所以下面的代码可以正常执行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(as(3));</span><br><span class="line">function as(num) &#123;</span><br><span class="line">	return ++num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>标准声明优先级高于赋值声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(as(3)); //4</span><br><span class="line"></span><br><span class="line">function as(num) &#123;</span><br><span class="line">  return ++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var as = function() &#123;</span><br><span class="line">  return &quot;as&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序中使用匿名函数的情况非常普遍</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sum(...args) &#123;</span><br><span class="line">  return args.reduce((a, b) =&gt; a + b);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1, 2, 3));</span><br></pre></td></tr></table></figure>





<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>函数也会提升到前面，但优先级高于<code>var</code>变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var c = 1;</span><br><span class="line">function c(c) &#123;</span><br><span class="line">    console.log(c);</span><br><span class="line">    var c = 2;</span><br><span class="line">&#125;</span><br><span class="line">c(3);	//TypeError: c is not a function</span><br></pre></td></tr></table></figure>

<p>变量定义函数的形式，函数不会被提升</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(as(&quot;Ashun&quot;));	//Ashun </span><br><span class="line"></span><br><span class="line">function as(title) &#123;</span><br><span class="line">	return title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var as = function () &#123;</span><br><span class="line">	return &quot;ashun&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>小测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c &#x3D; 1;</span><br><span class="line">function d() &#123;</span><br><span class="line">    console.log(c);</span><br><span class="line">    var c &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">d();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c &#x3D; 1;</span><br><span class="line">function d(c) &#123;</span><br><span class="line">    console.log(c);</span><br><span class="line">    var c &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">d(3);</span><br></pre></td></tr></table></figure>

<ul>
<li>其实第(1)个结果很快就答出来了:<code>undefined</code></li>
</ul>
<p>原因: <code>var</code>定义变量(除函数)，会提升到当前作用域的最前面，因此打印undefined。</p>
<ul>
<li>但是第(2)个结果一开始我认为是undefined，但其实是<code>3</code></li>
</ul>
<p>原因: 虽然也会变量提升，但是<code>若接收的参数与函数内部定义的变量名重复，并且该变量没有赋值，则该变量还为接收的参数</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c &#x3D; 1;</span><br><span class="line">function d(c) &#123;</span><br><span class="line">		var c;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">d(3);	&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c &#x3D; 1;</span><br><span class="line">function d(c) &#123;</span><br><span class="line">  console.log(c);</span><br><span class="line">  var c &#x3D; 2;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">d(3);	&#x2F;&#x2F;3 2</span><br></pre></td></tr></table></figure>



<h3 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h3><p>形参是在函数声明时设置的参数，实参指在调用函数时传递的值。</p>
<ul>
<li>形参数量大于实参时，没有传参的形参值为 undefined</li>
<li>实参数量大于形参时，多于的实参将忽略并不会报错</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// n1,n2 为形参</span><br><span class="line">function sum(n1, n2) &#123;</span><br><span class="line">	return n1+n2;</span><br><span class="line">&#125;</span><br><span class="line">// 参数 2,3 为实参</span><br><span class="line">console.log(sum(2, 3)); //5</span><br></pre></td></tr></table></figure>

<p>当没传递参数时值为undefined</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sum(n1, n2) &#123;</span><br><span class="line">  return n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(2)); //NaN</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>下面通过计算年平均销售额来体验以往默认参数的处理方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//total:总价 year:年数</span><br><span class="line">function avg(total, year) &#123;</span><br><span class="line">  year = year || 1;</span><br><span class="line">  return Math.round(total / year);</span><br><span class="line">&#125;</span><br><span class="line">console.log(avg(2000, 3));</span><br></pre></td></tr></table></figure>

<p>使用<code>ES6</code>默认参数方式如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function avg(total, year = 1) &#123;</span><br><span class="line">  return Math.round(total / year);</span><br><span class="line">&#125;</span><br><span class="line">console.log(avg(2000, 3));</span><br></pre></td></tr></table></figure>

<p>下面通过排序来体验新版默认参数的处理方式，下例中当不传递 type 参数时使用默认值 asc。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sortArray(arr, type = &#x27;asc&#x27;) &#123;</span><br><span class="line">	return arr.sort((a, b) =&gt; type == &#x27;asc&#x27; ? a - b : b - a);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sortArray([1, 3, 2, 6], &#x27;desc&#x27;));</span><br></pre></td></tr></table></figure>

<p>默认参数要放在最后面</p>
<p>​    默认参数就是为了在使用者默认配置时不用传参，若默认参数放在前面，而非默认参数放在后面，则当使用者默认配置时，为了传递非默认参数，就需要把前面的默认参数都传递进去。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//total:价格,discount:折扣,dis:折后折</span><br><span class="line">function sum(total, discount = 0, dis = 0) &#123;</span><br><span class="line">  return total * (1 - discount) * (1 - dis);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(2000, undefined, 0.3));</span><br></pre></td></tr></table></figure>

<h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p>立即执行函数指函数定义时立即执行</p>
<ul>
<li>可以用来定义私有作用域防止污染全局作用域</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var web = &#x27;astfn.github.io&#x27;;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(web); //web is not defined</span><br></pre></td></tr></table></figure>

<p>使用 <code>let/const</code> 有块作用域特性，所以使用以下方式也可以产生私有作用域</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let web = &#x27;astfn.github.io&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(web);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>函数可以做为参数传递，这也是大多数语言都支持的语法规则。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;订阅&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        alert(&#x27;感谢订阅&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>函数可以做为参数传递</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function filterFun(item) &#123;</span><br><span class="line">	return item &lt;= 3;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1, 2, 3, 4, 5].filter(filterFun);</span><br><span class="line">console.log(arr); //[1,2,3]</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments 是在函数内部获得所有参数集合的一个方式 ，下面是使用 <code>arguments</code> 求和的例子</p>
<ul>
<li>arguments是一种类数组的对象，属性名称依次为0~n，且包含callee和length属性，但其不是Array，所以不能够直接使用数组的方法，若要使用Array的方法，我们需要将其转化为数组，或借用数组原型的方法。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  return [...arguments].reduce((total, num) =&gt; total += num , 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  return Array.from(arguments).reduce((total, num) &#x3D;&gt; (total +&#x3D; num), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  return Array.prototype.reduce.call(</span><br><span class="line">    arguments,</span><br><span class="line">    (pre, v) &#x3D;&gt; (pre +&#x3D; v),</span><br><span class="line">    0</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1, 2, 3));	&#x2F;&#x2F;6</span><br></pre></td></tr></table></figure>

<p>更建议使用展示语法接收多个参数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sum(...args) &#123;</span><br><span class="line"> return args.reduce((a, b) =&gt; a + b);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(2, 3, 4, 2, 6)); //17</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是函数声明的简写形式，在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。</p>
<p>无参数时使用空扩号即可</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let sum = () =&gt; &#123;</span><br><span class="line">	return 1 + 3;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum()); //4</span><br></pre></td></tr></table></figure>

<p>函数体为单一表达式时不需要 <code>return</code> 返回处理，系统会自动返回表达式计算结果。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let sum = () =&gt; 1 + 3;</span><br><span class="line">console.log(sum()); //4</span><br></pre></td></tr></table></figure>

<p>多参数传递与普通声明函数一样使用逗号分隔</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 8, 3, 5].filter((item, index) =&gt; &#123;</span><br><span class="line">	return item &lt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<p>只有一个参数时可以省略括号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 8, 3, 5].filter(item =&gt; item &lt;= 3);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关箭头函数的作用域知识会在后面章节讨论</p>
</blockquote>
<h3 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h3><p>之前在String的<code>标签模板</code>中已经介绍过了，使用<code>标签函数</code>，能够处理string中的<code>普通字符串、变量</code>。</p>
<p>使用函数来解析标签字符串，第一个参数是字符串值的数组，其余的参数为标签变量。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Ashun(str, ...argus) &#123;</span><br><span class="line">  console.log(str); //[&quot;&quot;, &quot;-&quot;, &quot;&quot;, raw: Array(3)]</span><br><span class="line">  console.log(argus); //[&quot;ashun&quot;, &quot;ashuntefannao.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">let name = &#x27;ashun&#x27;,url = &#x27;ashuntefannao.com&#x27;;</span><br><span class="line">Ashun `$&#123;name&#125;-$&#123;url&#125;`;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>调用函数时 <code>this</code> 会隐式传递给函数指函数调用时的关联对象，也称之为函数的上下文。</p>
<ul>
<li>独立存在的函数,this指向window</li>
<li>函数作为对象的方法，this指向该对象</li>
<li>箭头函数本身没有this指向，会使用父级作用域的this指向。</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>全局环境下<code>this</code>就是window对象的引用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(this == window); //true</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用严格模式时在全局函数内<code>this</code>为<code>undefined</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var as = &quot;阿顺&quot;;</span><br><span class="line">function get() &#123;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	console.log(this);	//undefined</span><br><span class="line">	return this.as; 	</span><br><span class="line">&#125;</span><br><span class="line">console.log(get());</span><br><span class="line">//严格模式将产生错误  TypeError: Cannot read property &#x27;as&#x27; of undefined</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>函数为对象的方法时<code>this</code> 指向该对象</p>
<p>可以使用多种方式创建对象，下面是使用构造函数创建对象</p>
<p><strong>构造函数</strong></p>
<p>函数当被 <code>new</code> 时即为构造函数，一般构造函数中包含属性与方法。函数中的上下文<code>指向到实例对象</code>。</p>
<ul>
<li>构造函数主要用来生成对象，里面的this默认就是指当前对象</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;</span><br><span class="line">  this.name = &quot;阿顺&quot;;</span><br><span class="line">  this.say = function() &#123;</span><br><span class="line">    console.log(this); 			//User &#123;name: &quot;阿顺&quot;, say: ƒ&#125;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User();</span><br><span class="line">console.log(as.say()); 			//阿顺</span><br></pre></td></tr></table></figure>

<p><strong>对象字面量</strong></p>
<ul>
<li>下例中的as函数不属于对象方法所以指向<code>window</code></li>
<li>show属于对象方法执向 <code>obj</code>对象</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	site: &quot;阿顺&quot;,</span><br><span class="line">	show() &#123;</span><br><span class="line">		console.log(this.site); //阿顺</span><br><span class="line">		console.log(`show method in :$&#123;this&#125; 中`); //show method in :[object Object] 中</span><br><span class="line">		function as() &#123;</span><br><span class="line">			console.log(`as function in : $&#123;this&#125; 中`); //as function in : [object Window] 中</span><br><span class="line">		&#125;</span><br><span class="line">		as();</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.show();</span><br></pre></td></tr></table></figure>

<p>在方法中使用函数时，有些函数可以改变this如<code>forEach、map…</code>第二个参数为执行上下文，当然也可以使用后面介绍的<code>apply/call/bind</code>，或者直接使用箭头函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Lesson = &#123;</span><br><span class="line">  site: &quot;阿顺&quot;,</span><br><span class="line">  lists: [&quot;js&quot;, &quot;css&quot;, &quot;mysql&quot;],</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.lists.map(function(title) &#123;</span><br><span class="line">      return `$&#123;this.site&#125;-$&#123;title&#125;`;</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Lesson.show());</span><br></pre></td></tr></table></figure>

<p>也可以在父作用域中定义引用<code>this</code>的变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Lesson = &#123;</span><br><span class="line">    site: &quot;阿顺&quot;,</span><br><span class="line">    lists: [&quot;js&quot;, &quot;css&quot;, &quot;mysql&quot;],</span><br><span class="line">    show() &#123;</span><br><span class="line">      const self = this;</span><br><span class="line">      return this.lists.map(function(title) &#123;</span><br><span class="line">        return `$&#123;self.site&#125;-$&#123;title&#125;`;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">console.log(Lesson.show());</span><br></pre></td></tr></table></figure>





<h4 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数没有<code>this</code>, 也可以理解为箭头函数中的<code>this</code> 会继承定义函数时的上下文，可以理解为和外层函数指向同一个this。</p>
<ul>
<li>如果想使用函数定义时的上下文中的this，那就使用箭头函数</li>
</ul>
<p>下例中的匿名函数的执行环境为全局所以 <code>this</code> 指向 <code>window</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var name = &#x27;ASHUN&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;ashun&#x27;,</span><br><span class="line">  getName: function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">    	return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName()()); //返回window.name的值ASHUN</span><br></pre></td></tr></table></figure>

<p>以往解决办法：会在父级函数(对象方法)中定义变量，保留this，然后在独立存在的函数中使用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var name = &#x27;ASHUN&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;阿顺&#x27;,</span><br><span class="line">  getName: function () &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">		return function () &#123;</span><br><span class="line">    	return self.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName()()); //阿顺</span><br></pre></td></tr></table></figure>

<p>使用箭头函数后 <code>this</code> 为定义该函数的上下文，也可以理解为定义时父作用域中的<code>this</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var name = &#x27;ASHUN&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;阿顺&#x27;,</span><br><span class="line">  getName: function () &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">    	return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName()()); //阿顺</span><br></pre></td></tr></table></figure>

<p>事件中使用箭头函数结果不是我们想要的</p>
<ul>
<li>事件函数可理解为对象<code>onclick</code>设置值，所以函数声明时<code>this</code>为当前对象</li>
<li>但使用箭头函数时<code>this</code>为声明函数上下文</li>
</ul>
<p>下面体验使用普通事件函数时<code>this</code>指向元素对象</p>
<p>使用普通函数时<code>this</code>为当前DOM对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button desc=&quot;ashun&quot;&gt;button&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let Dom = &#123;</span><br><span class="line">    site: &quot;阿顺&quot;,</span><br><span class="line">    bind() &#123;</span><br><span class="line">      const button = document.querySelector(&quot;button&quot;);</span><br><span class="line">      button.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">        alert(this.getAttribute(&quot;desc&quot;));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dom.bind();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是使用箭头函数时this指向上下文对象，若想获取当前的DOM，可以通过<code>e.target|e.srcElement</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button desc=&quot;ashun&quot;&gt;button&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let Dom = &#123;</span><br><span class="line">    site: &quot;阿顺&quot;,</span><br><span class="line">    bind() &#123;</span><br><span class="line">      const button = document.querySelector(&quot;button&quot;);</span><br><span class="line">      button.addEventListener(&quot;click&quot;, event =&gt; &#123;</span><br><span class="line">        alert(this.site + event.target.innerHTML);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dom.bind();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply/call/bind"></a>apply/call/bind</h4><p>​    能够改变this指向，并传入参数，也可以理解为对象借用方法，就现像生活中向邻居借东西一样的事情。</p>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>构造函数中的<code>this</code>默认是一个空对象，然后构造函数处理后把这个空对象变得有值。再隐式的设置这个对象的原型。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺&quot;);</span><br></pre></td></tr></table></figure>

<p>可以改变构造函数中的空对象，即让构造函数this指向到另一个对象。传入参数初始化属性，再设置该对象的原型。就可以模仿<code>new 构造函数()</code>的过程。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">User.call(obj, &quot;阿顺&quot;);</span><br><span class="line">Object.setPrototypeOf(obj,User.prototype)</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="apply-call"><a href="#apply-call" class="headerlink" title="apply/call"></a>apply/call</h5><p>call与apply 用于显示的设置函数的上下文，两个方法作用一样都是将对象绑定到this，只是在传递参数上有所不同。</p>
<ul>
<li>apply 用<code>数组</code>传参</li>
<li>call 需要<code>分别</code>传参</li>
<li>与 bind 不同call/apply 会<code>立即执行</code>函数</li>
</ul>
<p>语法使用介绍</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function show(title) &#123;</span><br><span class="line">    alert(`$&#123;title+this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">let zs = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">let lisi = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">show.call(zs, &#x27;Ashun&#x27;);</span><br><span class="line">show.apply(lisi, [&#x27;SHUN&#x27;]);</span><br></pre></td></tr></table></figure>

<p>使用 <code>call</code> 设置函数上下文</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button message=&quot;阿顺&quot;&gt;button&lt;/button&gt;</span><br><span class="line">    &lt;button message=&quot;特烦恼&quot;&gt;button&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function show() &#123;</span><br><span class="line">        alert(this.getAttribute(&#x27;message&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    let bts = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">    for (let i = 0; i &lt; bts.length; i++) &#123;</span><br><span class="line">        bts[i].addEventListener(&#x27;click&#x27;, () =&gt; show.call(bts[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>找数组中的数值最大值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 8];</span><br><span class="line">console.log(Math.max(arr)); //NaN</span><br><span class="line">console.log(Math.max.apply(Math, arr)); //8</span><br><span class="line">console.log(Math.max.call(Math,...arr)); //8</span><br><span class="line">console.log(Math.max(...arr)); //8</span><br></pre></td></tr></table></figure>

<p>实现构造函数属性继承</p>
<ul>
<li>下例相当于Article、Lesson，都继承了Request的get方法</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">      function Request() &#123;</span><br><span class="line">        this.get = function (preset = &#123;&#125;) &#123;</span><br><span class="line">          let paramsTxt = Object.keys(preset)</span><br><span class="line">            .map((key) =&gt; `$&#123;key&#125;=$&#123;preset[key]&#125;`)</span><br><span class="line">            .join(&quot;&amp;&quot;);</span><br><span class="line"></span><br><span class="line">          return `$&#123;this.url&#125;?$&#123;paramsTxt&#125;`;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //控制文章请求</span><br><span class="line">      function Article() &#123;</span><br><span class="line">        this.url = &quot;ashun/article/index.html&quot;;</span><br><span class="line">        Request.call(this);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //控制课程请求</span><br><span class="line">      function Lesson() &#123;</span><br><span class="line">        this.url = &quot;ashun/course/index.html&quot;;</span><br><span class="line">        Request.apply(this, []);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let articleReq = new Article();</span><br><span class="line">      let lessonReq = new Lesson();</span><br><span class="line">      console.log(articleReq.get(&#123; name: &quot;Ashun&quot;, type: &quot;Controller&quot; &#125;));</span><br><span class="line">      console.log(lessonReq.get(&#123; row: 20, start: 999 &#125;));</span><br></pre></td></tr></table></figure>

<p>制作显示隐藏面板</p>
<img src="函数进阶.assets/call-apply.gif" alt="call-apply" style="zoom:70%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        margin: 10px auto;</span><br><span class="line">      &#125;</span><br><span class="line">      dl &#123;</span><br><span class="line">        width: 90%;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">      dt,</span><br><span class="line">      dd &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">      &#125;</span><br><span class="line">      dt &#123;</span><br><span class="line">        height: 35px;</span><br><span class="line">        background-color: #00b894;</span><br><span class="line">        color: white;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        letter-spacing: 2px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">      &#125;</span><br><span class="line">      dd &#123;</span><br><span class="line">        background-color: #636e72;</span><br><span class="line">        color: #dfe6e9;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        border-radius: 0px 0px 5px 5px;</span><br><span class="line">        transition: 0.3s;</span><br><span class="line">        height: 0px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">      .show &#123;</span><br><span class="line">        height: 180px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;main&gt;</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;阿顺特烦恼&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd&gt;Ashuntefannao&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;dt&gt;希望大家&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd&gt;Ashuntefannao&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;dt&gt;没有烦恼&lt;&#x2F;dt&gt;</span><br><span class="line">        &lt;dd&gt;Ashuntefannao&lt;&#x2F;dd&gt;</span><br><span class="line">      &lt;&#x2F;dl&gt;</span><br><span class="line"> 	&lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function show(index) &#123;</span><br><span class="line">        let items &#x3D; document.querySelectorAll(&quot;dd&quot;);</span><br><span class="line">        items.forEach((v) &#x3D;&gt; v.classList.remove(&quot;show&quot;));</span><br><span class="line">        items[index].classList.add(&quot;show&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      let titles &#x3D; document.querySelectorAll(&quot;dt&quot;);</span><br><span class="line">      titles.forEach((ele, i) &#x3D;&gt; &#123;</span><br><span class="line">        ele.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">          show.call(null, i);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>bind(this,...args)</code>在使用形式上与call相同。bind是<code>复制函数行为</code>。</p>
<p>与call、apply的不同之处：</p>
<ul>
<li><p>bind绑定后，函数不会立即执行，需要被调用。</p>
</li>
<li><p>原理不同:</p>
<ul>
<li>call、apply是在函数调用时改变this指向。</li>
<li>使用 bind 绑定函数时，会生成一个新函数，新函数的函数体与被绑定函数一样，bind 是在<code>复制得到新函数时改变的this指向</code>。</li>
</ul>
</li>
</ul>
<p>bind是复制函数行为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let a = function () &#123;&#125;;</span><br><span class="line">	let c = a.bind();</span><br><span class="line">	console.log(c);					//ƒ () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	let a = function () &#123;&#125;;</span><br><span class="line">	let c = a.call();</span><br><span class="line">	console.log(c);					//undefined</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	let a = function () &#123;&#125;;</span><br><span class="line">	let c = a.apply();</span><br><span class="line">	console.log(c);					//undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定参数注意事项</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">  return this.f + a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用bind会生成新函数</span><br><span class="line">let newFunc = sum.bind(&#123; f: 1 &#125;, 3);</span><br><span class="line"></span><br><span class="line">//1+3+2 将2赋值给参数b即 a=3,b=2</span><br><span class="line">console.log(newFunc(2));</span><br></pre></td></tr></table></figure>

<p>在事件中使用<code>bind</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button&gt;阿顺&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.querySelector(&quot;button&quot;).addEventListener(</span><br><span class="line">    &quot;click&quot;,</span><br><span class="line">    function(event) &#123;</span><br><span class="line">      console.log(event.target.innerHTML + this.url);</span><br><span class="line">    &#125;.bind(&#123; url: &quot;Ashuntefannao.com&quot; &#125;)</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>动态改变元素背景颜色，当然下面的例子也可以使用箭头函数处理</p>
<img src="函数进阶.assets/bind.gif" alt="bind" style="zoom:75%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        background-color: #e17055;</span><br><span class="line">        color: rgba(255, 255, 255, 0.8);</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        transition: 0.8s;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Ashuntefannao&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Color &#123;</span><br><span class="line">        constructor(dom) &#123;</span><br><span class="line">          this.dom &#x3D; dom;</span><br><span class="line">          this.colors &#x3D; [ &quot;#fdcb6e&quot;,&quot;#55efc4&quot;,&quot;#00b894&quot;,&quot;#6c5ce7&quot;,&quot;#74b9ff&quot;,&quot;#e17055&quot;];</span><br><span class="line">          this.run();</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">          setInterval(</span><br><span class="line">            function () &#123;</span><br><span class="line">              let random &#x3D; Math.floor(Math.random() * this.colors.length);</span><br><span class="line">              this.dom.style.backgroundColor &#x3D; this.colors[random];</span><br><span class="line">            &#125;.bind(this),</span><br><span class="line">            800</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      new Color(document.body);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>基本类型</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><blockquote>
<p>JavaScript中的基本数据类型有：boolean、null、undefined、number、string、symbol、BigInt。</p>
<p>引用类型有：Object、Array、Function、Match、Date、RegExp、Set、WeakSet、Map、WeakMap…</p>
<p>该标题所示基本类型意为 <strong>新手初始学习</strong> 的一些数据类型。</p>
</blockquote>
<h3 id="一、-类型检测"><a href="#一、-类型检测" class="headerlink" title="一、 类型检测"></a>一、 类型检测</h3><h4 id="1-1-typeof"><a href="#1-1-typeof" class="headerlink" title="1.1 typeof"></a>1.1 typeof</h4><p><code>typeof</code> 能够正确的返回以下数据类型（在不使用构造函数实例化的前提下，否则返回Object）</p>
<ul>
<li><p>Number、String、undefined、Object、Boolean、function</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">        typeof 1,									&#x2F;&#x2F;number </span><br><span class="line">        typeof &quot;&quot;,								&#x2F;&#x2F;string </span><br><span class="line">        typeof undefined,					&#x2F;&#x2F;undefined </span><br><span class="line">        typeof &#123;&#125;,								&#x2F;&#x2F;object  </span><br><span class="line">        typeof false,							&#x2F;&#x2F;boolean </span><br><span class="line">        typeof function () &#123;&#125;			&#x2F;&#x2F;function</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>不能正确判断的情况：</p>
<p>—使用构造函数实例化为对象，则返回Object。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &quot;Ashun&quot;;</span><br><span class="line">let str &#x3D; new String(&quot;Ashun&quot;); </span><br><span class="line">console.log(typeof as, typeof str); &#x2F;&#x2F;string object</span><br></pre></td></tr></table></figure>

<p>—<code>typeof []</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(typeof []);  &#x2F;&#x2F;object</span><br></pre></td></tr></table></figure>

<p>—关于<code>typeof null===&#39;object&#39;</code></p>
<p>首先要说明的是，null**不是!**对象，但为什么返回结果为<code>object</code>呢？</p>
<p>解释: 这是JS的历史遗留bug，在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p>
<blockquote>
<p>—如果要正确判断能够使用构造函数实例化的以上数据类型、或Array。可以使用<code>instanceof</code> 👇</p>
</blockquote>
<hr>
<h4 id="1-2-instanceof"><a href="#1-2-instanceof" class="headerlink" title="1.2 instanceof"></a>1.2 instanceof</h4><p>​    <strong><code>instanceof</code></strong> 运算符用于检测构造函数的 <code>prototype</code> 属性(原型对象)是否出现在某个实例对象的原型链上。也可以理解为：判断是否为某个对象的实例，<code>typeof</code>不能区分Array，但<code>instanceof</code>可以。instanceof的返回结果为Boolean。</p>
<p>—判断Array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([] instanceof Array);		&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>—检测typeof能够正确返回的数据类型（在不 手动实例化 的情况下）</p>
<p>​    只有obj、function能够返回正确的结果，其余返回false的数据类型如果通过构造函数实例化，则能够正确判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;&quot; instanceof String);									&#x2F;&#x2F;false</span><br><span class="line">console.log(1 instanceof Number);										&#x2F;&#x2F;false</span><br><span class="line">console.log(true instanceof Boolean);								&#x2F;&#x2F;false</span><br><span class="line">console.log(function () &#123;&#125; instanceof Function);		&#x2F;&#x2F;true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);									&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里undefined不能够判断，因为其没有构造函数。</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="1-3-值类型与对象"><a href="#1-3-值类型与对象" class="headerlink" title="1.3 值类型与对象"></a>1.3 值类型与对象</h4><p>下面是使用字面量与对象方法创建字符串，返回的是不同类型。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;astfn&quot;;</span><br><span class="line">let ext = new String(&quot;.github.io&quot;); </span><br><span class="line">console.log(typeof as, typeof ext); //string object</span><br></pre></td></tr></table></figure>

<p>只有对象才能够调用属性和方法，但在<code>JS</code>中也可以使用值类型调用方法，因为它会在执行时将值类型转为对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[].concat([&quot;ashun&quot;]);</span><br><span class="line">&quot;Ashun&quot;.length</span><br><span class="line">(1.266).toFixed(2)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h3><h4 id="2-1-声明定义"><a href="#2-1-声明定义" class="headerlink" title="2.1 声明定义"></a>2.1 声明定义</h4><ul>
<li><p>构造函数声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str&#x3D;new String(&quot;ashun&quot;);</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure></li>
<li><p>字面量声明</p>
<p>单引号’’、双引号””、模板字面量``。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str&#x3D;&quot;ashun&quot;;</span><br><span class="line">let str1&#x3D;&#39;ashun&#39;;</span><br><span class="line">let str2&#x3D;&#96;ashun&#96;; </span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-转义符号"><a href="#2-2-转义符号" class="headerlink" title="2.2 转义符号"></a>2.2 转义符号</h4><p>有些字符在js中具有特殊含义，需要进行转义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let site&#x3D;&quot;site:\&quot;ashuntefannao.com\&quot;&quot;;</span><br><span class="line">console.log(site)</span><br><span class="line">&#x2F;&#x2F;site:&quot;ashuntefannao.com&quot;</span><br></pre></td></tr></table></figure>

<p>常用转义符号列表如下</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\</td>
<td>斜杠符号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
</tbody></table>
<p>—在使用RegExp时，有很多符号都具有特殊含义，如果需要匹配某些字符，也需要进行转义，在<code>RegExp</code>总结中会详解。</p>
<hr>
<h4 id="2-3-连接运算符"><a href="#2-3-连接运算符" class="headerlink" title="2.3 连接运算符"></a>2.3 连接运算符</h4><p>使用 <code>+</code> 可以连接多个内容组合成字符串，经常用于组合输出内容使用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let name = &quot;ashun&quot;;</span><br><span class="line">age = 18;</span><br><span class="line">console.log(name + &#x27;今年&#x27; + age + &#x27;岁了&#x27;);</span><br><span class="line">name+=&quot;tefannao&quot;;</span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure>

<p>—使用String的内置方法<code>str.concat(str1,…strN)</code>也能够完成字符串的合并操作。该方法<code>不会改变</code>原字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;ashun&quot;;</span><br><span class="line">console.log(str.concat(&quot;Ashun&quot;, &quot;Tefannao&quot;));&#x2F;&#x2F;ashunAshunTefannao</span><br><span class="line">console.log(str);&#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>



<h4 id="2-4-模板字面量"><a href="#2-4-模板字面量" class="headerlink" title="2.4 模板字面量"></a>2.4 模板字面量</h4><p>（模板字面量`` ）可以声明字符串变量，也可拼接String，相比传统方式使用 + 来链接String，字面量更加的灵活和方便。</p>
<p>优点：</p>
<ul>
<li>可以包含变量和表达式<code>$&#123;&#125;</code></li>
<li>可在模板字面量中换行</li>
<li>可以嵌套使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name&#x3D;&quot;ashun&quot;;</span><br><span class="line">function getAge()&#123;return 18&#125;;</span><br><span class="line">console.log(&#96;$&#123;name&#125;今年$&#123;getAge()&#125;岁了&#96;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#96;Ashun</span><br><span class="line">Te</span><br><span class="line">FanNao</span><br><span class="line">&#96;);</span><br><span class="line">&#x2F;*</span><br><span class="line">Ashun</span><br><span class="line">Te</span><br><span class="line">FanNao</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[&#123;title:&quot;ashun&quot;&#125;,&#123;title:&quot;Ashun&quot;&#125;,&#123;title:&quot;ashuntefannao.com&quot;&#125;,];</span><br><span class="line"></span><br><span class="line">function template(arr)&#123;</span><br><span class="line">return &#96;&lt;ul&gt;$&#123;arr.map(v&#x3D;&gt;&#96;&lt;li&gt;$&#123;v.title&#125;&lt;&#x2F;li&gt;&#96;).join(&quot;&quot;)&#125;&lt;&#x2F;ul&gt;&#96;;</span><br><span class="line">&#125;</span><br><span class="line">document.write(template(arr))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-标签模板"><a href="#2-5-标签模板" class="headerlink" title="2.5 标签模板"></a>2.5 标签模板</h4><p>功能：提取出<code>普通字符串</code>与<code>变量</code>，交由<code>标签函数</code>处理</p>
<p>使用步骤:</p>
<ol>
<li><p>定义处理标签模板的函数</p>
</li>
<li><p>调用标签模板函数，处理字符串</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">functionName &#96;StringContent&#96;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj=&#123;name:&quot;阿顺&quot;,age:18&#125;;</span><br><span class="line">function tagTemplate(str,...argus)&#123;</span><br><span class="line">	console.log(str);		//[&quot;info：&quot;, &quot;今年&quot;, &quot;岁了&quot;]</span><br><span class="line">	console.log(argus);		//[&quot;阿顺&quot;, 18]</span><br><span class="line">&#125;</span><br><span class="line">tagTemplate `info：$&#123;obj.name&#125;今年$&#123;obj.age&#125;岁了`;</span><br></pre></td></tr></table></figure>

<p>—若String开头就使用了变量，那么获取普通字符串Arr的第一个元素为空字符串<code>&quot;&quot;</code></p>
<p>—同理，若String的结尾使用了变量，获取普通字符串Arr的最后一个元素也为<code>&quot;&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name&#x3D;&quot;ashun&quot;;</span><br><span class="line">tag &#96;$&#123;name&#125;18岁了&#96;;</span><br><span class="line">function tag(str,...argu)&#123;</span><br><span class="line">	console.log(str);	&#x2F;&#x2F;[&quot;&quot;, &quot;18岁了&quot;]</span><br><span class="line">	console.log(argu)	&#x2F;&#x2F;[&quot;ashun&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-6-String属性"><a href="#2-6-String属性" class="headerlink" title="2.6 String属性"></a>2.6 String属性</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">length</td>
<td align="left">字符串的长度</td>
</tr>
<tr>
<td align="left">constructor</td>
<td align="left">访问其构造函数</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">通过其可扩展String的属性和方法。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-7-String方法"><a href="#2-7-String方法" class="headerlink" title="2.7 String方法"></a>2.7 String方法</h4><h5 id="2-7-1-大小写转换"><a href="#2-7-1-大小写转换" class="headerlink" title="2.7.1 大小写转换"></a>2.7.1 大小写转换</h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toLowerCase()</td>
<td align="left">把字符串转换为小写。</td>
</tr>
<tr>
<td align="left">toUpperCase()</td>
<td align="left">把字符串转换为大写。</td>
</tr>
</tbody></table>
<h5 id="2-7-2-移除空白"><a href="#2-7-2-移除空白" class="headerlink" title="2.7.2 移除空白"></a>2.7.2 移除空白</h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">trim()</td>
<td align="left">移除字符串左右两侧的空白</td>
</tr>
<tr>
<td align="left">trimLeft()</td>
<td align="left">移除字符串左侧的空白</td>
</tr>
<tr>
<td align="left">trimRight()</td>
<td align="left">移除字符串右侧的空白</td>
</tr>
</tbody></table>
<h5 id="2-7-3-获取单字符"><a href="#2-7-3-获取单字符" class="headerlink" title="2.7.3 获取单字符"></a>2.7.3 获取单字符</h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">charAt(index)</td>
<td align="left">返回在指定位置的字符。</td>
</tr>
<tr>
<td align="left">charCodeAt(index)</td>
<td align="left">返回在指定位置字符的 Unicode 编码。</td>
</tr>
</tbody></table>
<p>—使用索引形式，获取单字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;[2]);</span><br></pre></td></tr></table></figure>



<h5 id="2-7-4-截取字符串"><a href="#2-7-4-截取字符串" class="headerlink" title="2.7.4 截取字符串"></a>2.7.4 截取字符串</h5><p>slice、substr、substring这些操作都不会改变原字符串，而是返回一个新的string。</p>
<h6 id="slice-n1-n2"><a href="#slice-n1-n2" class="headerlink" title="slice(n1,n2)"></a>slice(n1,n2)</h6><p>参数1:起始位置，参数2:结束位置    相当于<code>区间左闭右开[n1,n2)</code>，参数可为负数，意为自后向前的字符。</p>
<p>关于参数：</p>
<ul>
<li><p>没有传参时，截取整个sring</p>
</li>
<li><p>只有一个参数</p>
<ul>
<li>正数：从n1截取到尾部。</li>
<li>负数：自后向前截取n1个字符。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;.slice(-4));			&#x2F;&#x2F;shun</span><br><span class="line"></span><br><span class="line">console.log(&quot;Ashun&quot;.slice(1));			&#x2F;&#x2F;shun</span><br><span class="line"></span><br><span class="line">console.log(&quot;Ashun&quot;.slice(1, 2));		&#x2F;&#x2F;s</span><br><span class="line"></span><br><span class="line">console.log(&quot;Ashun&quot;.slice(1, -1));	&#x2F;&#x2F;shu</span><br><span class="line"></span><br><span class="line">console.log(&quot;Ashun&quot;.slice(-1, -5));	&#x2F;&#x2F;shun</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;截取的规则必须是自前向后，n1&lt;n2</span><br><span class="line">console.log(&quot;Ashun&quot;.slice(-4, -2)); &#x2F;&#x2F;sh</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="substr-n1-n2"><a href="#substr-n1-n2" class="headerlink" title="substr(n1,n2)"></a>substr(n1,n2)</h6><p>参数1:起始位置，参数2:<code>自前向后截取n2个字符（数量包含起始位置字符）</code>,因此参数2不可为负数。</p>
<p>关于参数：</p>
<ul>
<li><p>没有传参时，截取整个sring</p>
</li>
<li><p>只有一个参数（同slice）。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;.substr(1)); 							&#x2F;&#x2F;shun</span><br><span class="line">console.log(&quot;Ashun&quot;.substr(-4)); 							&#x2F;&#x2F;shun</span><br><span class="line">console.log(&quot;Ashuntefan&quot;.substr(1, 3));				&#x2F;&#x2F;shu</span><br><span class="line">console.log(&quot;Ashuntefan&quot;.substr(-3, 2));			&#x2F;&#x2F;fa</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="substring-n1-n2"><a href="#substring-n1-n2" class="headerlink" title="substring(n1,n2)"></a>substring(n1,n2)</h6><p>关于参数：对比slice。</p>
<ul>
<li>相同点<ul>
<li>没有传参时，截取整个sring</li>
<li>参数1、2的意义与slice相同<code>区间左闭右开[n1,n2)</code>。</li>
</ul>
</li>
<li>不同点<ul>
<li>参数不能为负数，否则会视为<code>0</code></li>
<li>自动将两个参数中较小的参数作为起始位置。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;.substring(1));					&#x2F;&#x2F;shun</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二者结果相同</span><br><span class="line">console.log(&quot;Ashun&quot;.substring(1, 5));				&#x2F;&#x2F;shun</span><br><span class="line">console.log(&quot;Ashun&quot;.substring(5, 1));				&#x2F;&#x2F;shun</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;相当于substring(0)</span><br><span class="line">console.log(&quot;Ashun&quot;.substring(-2));					&#x2F;&#x2F;Ashun</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;相当于substring(1,0)&#x3D;&#x3D;&#x3D;substring(0,1)</span><br><span class="line">console.log(&quot;Ashun&quot;.substring(1, -1));			&#x2F;&#x2F;A</span><br><span class="line">console.log(&quot;Ashun&quot;.substring(1, 0));				&#x2F;&#x2F;A</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-7-5-检索字符串"><a href="#2-7-5-检索字符串" class="headerlink" title="2.7.5 检索字符串"></a>2.7.5 检索字符串</h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indexOf(str,index)</td>
<td align="left">返回某个指定的字符串值在字符串中<code>首次出现的索引</code>。匹配失败返回-1。参数2(可选)指定开始查找的位置</td>
</tr>
<tr>
<td align="left">lastIndexOf(str,index)</td>
<td align="left">自后向前检索字符串，返回结果同indexOf()，参数2(可选)指定开始查找的位置(自后向前)</td>
</tr>
<tr>
<td align="left">includes(str，index)</td>
<td align="left">是否包含指定的子字符串，参数2(可选)指定开始查找的位置(自后向前)</td>
</tr>
<tr>
<td align="left">match(<code>Regexp</code>)</td>
<td align="left">查找找到一个或多个正则表达式的匹配。</td>
</tr>
<tr>
<td align="left">search(str/<code>Regexp</code>)</td>
<td align="left">相对于indexof()可以传入<code>Regexp</code></td>
</tr>
<tr>
<td align="left">startsWith(str,index)</td>
<td align="left">是否以指定的str开头。index:检索的起始位置。</td>
</tr>
<tr>
<td align="left">endsWith(str,index)</td>
<td align="left">是否以指定的str结束，index:检索的结束位置。</td>
</tr>
</tbody></table>
<p>—indexOf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun、ashun&quot;.indexOf(&quot;shun&quot;)); 	&#x2F;&#x2F;1</span><br><span class="line">console.log(&quot;Ashun&quot;.indexOf(&quot;as&quot;));						 &#x2F;&#x2F;-1</span><br><span class="line"></span><br><span class="line">let str &#x3D; &quot;ashunashun&quot;;</span><br><span class="line">console.log(str.indexOf(&quot;a&quot;));&#x2F;&#x2F;0</span><br><span class="line">console.log(str.indexOf(&quot;a&quot;, 2));&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<p>—lastIndexOf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun、ashun&quot;.lastIndexOf(&quot;shun&quot;)); 	&#x2F;&#x2F;7</span><br><span class="line">console.log(&quot;Ashun&quot;.lastIndexOf(&quot;as&quot;)); 					&#x2F;&#x2F;-1</span><br><span class="line"></span><br><span class="line">let str &#x3D; &quot;ashunashun&quot;;</span><br><span class="line">console.log(str.lastIndexOf(&quot;a&quot;));&#x2F;&#x2F;5</span><br><span class="line">console.log(str.lastIndexOf(&quot;a&quot;, 3));&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>

<p>—includes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;.includes(&quot;shun&quot;)); 		&#x2F;&#x2F;true</span><br><span class="line">console.log(&quot;Ashun&quot;.includes(&quot;as&quot;)); 			&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>—match</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&quot;shun&quot;, &quot;g&quot;);</span><br><span class="line">console.log(&quot;Ashun、ashun&quot;.match(reg)); 				&#x2F;&#x2F;[&quot;shun&quot;, &quot;shun&quot;]</span><br><span class="line">console.log(&quot;Ashun、ashun&quot;.match(&#x2F;[0-9]&#x2F;)); 		&#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

<p>—search</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&quot;shun&quot;, &quot;g&quot;);</span><br><span class="line">console.log(&quot;Ashun、shun&quot;.search(reg)); 			&#x2F;&#x2F;1</span><br><span class="line">console.log(&quot;Ashun、shun&quot;.search(&quot;、&quot;)); 		 &#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<p>—startsWith</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashuntefannao&quot;.startsWith(&quot;A&quot;));				&#x2F;&#x2F;true</span><br><span class="line">console.log(&quot;Ashuntefannao&quot;.startsWith(&quot;shun&quot;, 1));	&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>—endsWith</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashuntefannao&quot;.endsWith(&quot;fannao&quot;)); 		&#x2F;&#x2F;true</span><br><span class="line">console.log(&quot;Ashuntefannao&quot;.endsWith(&quot;shun&quot;, 5)); 	&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="2-7-6-替换字符串"><a href="#2-7-6-替换字符串" class="headerlink" title="2.7.6 替换字符串"></a>2.7.6 替换字符串</h5><p><code>replace(matchStr,replaceStr)</code> 方法用于字符串的替换操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let site = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(site.replace(&quot;Ashuntefannao&quot;, &quot;ashun&quot;));</span><br></pre></td></tr></table></figure>

<p>默认只替换一次，如果全局替换需要使用正则（更强大的使用会在正则表达式章节介绍）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashun、shun&quot;;</span><br><span class="line">console.log(str.replace(/shun/g, &quot;SHUN&quot;));</span><br></pre></td></tr></table></figure>

<p>使用字符串替换来生成关键词链接</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let keys = [&quot;Js&quot;, &quot;css&quot;];</span><br><span class="line">let str = &quot;Ashun喜欢Js和css知识&quot;;</span><br><span class="line">	str = keys.reduce((pre, key) =&gt; &#123;</span><br><span class="line">		return pre.replace(key, `&lt;a href=&quot;?key=$&#123;key&#125;&quot;&gt;$&#123;key&#125;&lt;/a&gt;`);</span><br><span class="line">&#125;, str);</span><br><span class="line">document.body.innerHTML = str;</span><br></pre></td></tr></table></figure>

<p>使用正则表达式完成替换</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashun喜欢Js和css知识&quot;;</span><br><span class="line">str = str.replace(/(css|Js)/g, `&lt;a href=&quot;?key=$&amp;&quot;&gt;$&amp;&lt;/a&gt;`);</span><br><span class="line">document.body.innerHTML = str;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="2-7-7-重复生成"><a href="#2-7-7-重复生成" class="headerlink" title="2.7.7 重复生成"></a>2.7.7 重复生成</h5><p><code>repeat(num)</code>完成字符串的重复生成</p>
<p>下例是根据参数重复生成星号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function repeat(str = &quot;*&quot;, num = 3) &#123;</span><br><span class="line">		return str.repeat(num);</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat());</span><br><span class="line">console.log(repeat(&quot;8 &quot;, 8));</span><br></pre></td></tr></table></figure>

<p>下面是模糊电话号码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let phone = &quot;89452176335&quot;;</span><br><span class="line">console.log(phone.slice(0, 3).concat(&quot;*&quot;.repeat(5)).concat(phone.slice(-3)));</span><br><span class="line">//894*****335</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-7-8-类型转换"><a href="#2-7-8-类型转换" class="headerlink" title="2.7.8 类型转换"></a>2.7.8 类型转换</h5><h6 id="String-gt-Array"><a href="#String-gt-Array" class="headerlink" title="String-&gt;Array"></a>String-&gt;Array</h6><p>使用<code>split(str)</code>方法：以参数str分割String为Array。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Ashun&quot;.split(&quot;&quot;));								&#x2F;&#x2F;[&quot;A&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;]</span><br><span class="line">console.log(&quot;ashun,Ashun&quot;.split(&quot;,&quot;));				&#x2F;&#x2F;[&quot;ashun&quot;,&quot;Ashun&quot;]</span><br><span class="line">console.log(&quot;Ashuntefannao&quot;.split(&quot;te&quot;));			&#x2F;&#x2F;[&quot;Ashun&quot;,&quot;fannao&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="Number-gt-String"><a href="#Number-gt-String" class="headerlink" title="Number-&gt;String"></a>Number-&gt;String</h6><ul>
<li>+””</li>
<li>String(Number)</li>
<li>num.toString()</li>
</ul>
<h6 id="Array-gt-String"><a href="#Array-gt-String" class="headerlink" title="Array-&gt;String"></a>Array-&gt;String</h6><ul>
<li><p>arr.join(str)</p>
<p><code>join(str)</code>方法：以参数str合并Array的每个元素变为String。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([&quot;2020&quot;, &quot;3&quot;, &quot;13&quot;].join(&quot;-&quot;));			&#x2F;&#x2F;2020-3-13</span><br></pre></td></tr></table></figure></li>
<li><p>arr.toString()</p>
</li>
</ul>
<p>js中大部分类型都是对象，可以使用类方法 <code>toString</code>转化为字符串</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = 99;</span><br><span class="line">console.log(typeof as.toString()); //string</span><br><span class="line"></span><br><span class="line">let arr = [&#x27;Ashun&#x27;, &#x27;阿顺&#x27;];</span><br><span class="line">console.log(typeof arr.toString()); //string</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、Boolean"><a href="#三、Boolean" class="headerlink" title="三、Boolean"></a>三、Boolean</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>基本上所有类型都可以隐式转换为 Boolean类型。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">非空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">非0的数值</td>
<td>0 、NaN</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">不与Boolean比较时</td>
<td>参与比较的空数组</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">不与Boolean比较时</td>
<td></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">无</td>
<td>undefined</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">无</td>
<td>null</td>
</tr>
<tr>
<td align="left">NaN</td>
<td align="left">无</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>当与boolean类型比较时，会将两边类型统一为数字1或0。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(3 == true); 	//false</span><br><span class="line">console.log(0 == false); 	//true</span><br></pre></td></tr></table></figure>

<p>下面是一个典型的例子，字符串在与Boolean比较时，两边都为转换为数值类型后再进行比较。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Boolean(&quot;ashun&quot;)); //true</span><br><span class="line">console.log(Number(&quot;ashun&quot;)); //NaN</span><br><span class="line">console.log(&quot;ashun&quot; == true); //false</span><br><span class="line">console.log(&quot;1&quot; == true); //true</span><br></pre></td></tr></table></figure>

<p>数组的表现与字符串原理一样，会先转换为数值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Number([])); //0</span><br><span class="line">console.log(Number([3])); //3</span><br><span class="line">console.log(Number([1, 2, 3])); //NaN</span><br><span class="line">console.log([] == false); //true</span><br><span class="line">console.log([1] == true); //true</span><br><span class="line">console.log([1, 2, 3] == true); //false</span><br></pre></td></tr></table></figure>

<p>—引用类型<code>Object、Array</code>不与Boolean比较时，值为<code>真</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([]) console.log(&quot;true&quot;);</span><br><span class="line">if (&#123;&#125;) console.log(&quot;true&quot;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>使用 <code>!</code>或<code>!!</code> 转换布尔类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#x27;&#x27;;</span><br><span class="line">console.log(!!as); //false</span><br><span class="line">as = 0;</span><br><span class="line">console.log(!!as); //false</span><br><span class="line">as = null;</span><br><span class="line">console.log(!!as); //false</span><br><span class="line">as = new Date(&quot;2021-3-13 16:42&quot;);</span><br><span class="line">console.log(!!as); //true</span><br></pre></td></tr></table></figure>

<p>使用 <code>Boolean</code> 函数可以显式转换为布尔类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#x27;&#x27;;</span><br><span class="line">console.log(Boolean(as)); //false</span><br><span class="line">as = 0;</span><br><span class="line">console.log(Boolean(as)); //false</span><br><span class="line">as = null;</span><br><span class="line">console.log(Boolean(as)); //false</span><br><span class="line">as = new Date(&quot;2021-3-13 16:42&quot;);</span><br><span class="line">console.log(Boolean(as)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>下面使用Boolean类型判断用户的输入，并给出不同的反馈。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  let test = prompt(&quot;请输入Ashuntefannao成立年份&quot;).trim();</span><br><span class="line">  if (!test) continue;</span><br><span class="line">  alert(test == 2020 ? &quot;回答正确&quot; : &quot;答案错误！假粉一个&quot;);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、Number"><a href="#四、Number" class="headerlink" title="四、Number"></a>四、Number</h3><h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>使用对象方式声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = new Number(3);</span><br><span class="line">console.log(as+3); //6</span><br></pre></td></tr></table></figure>

<p>Number用于表示整数和浮点数，数字是 <code>Number</code>实例化的对象，可以使用对象提供的丰富方法。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let num = 99;</span><br><span class="line">console.log(typeof num);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><p><code>Number.isInteger(num)</code>：判断是否为整数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Number.isInteger(1.2));	//false</span><br></pre></td></tr></table></figure>

<p><code>Number.isNaN(message)</code>：判断参数是否为无效数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &quot;ashun&quot; &#x2F; 0;</span><br><span class="line">console.log(Number.isNaN(as)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><code>num.toFixed(n)</code>：四舍五入保留n位小数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log((16.556).toFixed(2)); // 16.56</span><br></pre></td></tr></table></figure>

<p><code>num.toString()</code>：转为String，js中几乎所有类型都具有该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(typeof (2).toString())</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>表示无效的数值，下例计算将产生NaN结果。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Number(&quot;ashun&quot;)); //NaN</span><br><span class="line"></span><br><span class="line">console.log(2 / &#x27;ashun&#x27;); //NaN</span><br></pre></td></tr></table></figure>

<p>NaN不能使用 <code>==</code> 比较，使用以下代码来判断结果是否正确</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let res = 2 / &#x27;ashun&#x27;;</span><br><span class="line">if (Number.isNaN(res)) &#123;</span><br><span class="line">	console.log(&#x27;Error&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(res == NaN);	//false</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>Object.is</code> 方法判断两个值是否完全相同</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let res = 2 / &#x27;ashun&#x27;;</span><br><span class="line">console.log(Object.is(res, NaN)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>other-&gt;Number</strong></p>
<p>使用Number函数基本上可以转换所有类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Number(&#x27;Ashun&#x27;)); //NaN</span><br><span class="line">console.log(Number(true));	//1</span><br><span class="line">console.log(Number(false));	//0</span><br><span class="line">console.log(Number(&#x27;9&#x27;));	//9</span><br><span class="line">console.log(Number([]));	//0</span><br><span class="line">console.log(Number([5]));	//5</span><br><span class="line">console.log(Number([5, 2]));	//NaN</span><br><span class="line">console.log(Number(&#123;&#125;));	//NaN</span><br></pre></td></tr></table></figure>

<p><strong>parseInt</strong></p>
<p>提取字符串头部去除空白后的数字转为整数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(parseInt(&#x27;  99houdunren&#x27;));	//99</span><br><span class="line">console.log(parseInt(&#x27;18.55&#x27;));	//18</span><br></pre></td></tr></table></figure>

<p><strong>parseFloat</strong></p>
<p>提取字符串头部去除空白后的数字转为浮点数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(parseFloat(&#x27;  99houdunren&#x27;));	//99</span><br><span class="line">console.log(parseFloat(&#x27;  18.55&#x27;));	//18.55</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="浮点精度"><a href="#浮点精度" class="headerlink" title="浮点精度"></a>浮点精度</h4><p>大部分编程语言在浮点数计算时都会有精度误差问题，下面来看JS中的表现形式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let num = 0.1 + 0.2</span><br><span class="line">console.log(num)// 结果：0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>这是因为计算机以二进制处理数值类型，上面的0.1与0.2转为二进制后是无穷的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log((0.1).toString(2)) //0.0001100110011001100110011001100110011001100110011001101</span><br><span class="line">console.log((0.2).toString(2)) //0.001100110011001100110011001100110011001100110011001101</span><br></pre></td></tr></table></figure>

<p><strong>处理方式</strong></p>
<p>一种方式使用toFixed 方法进行小数截取</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log((0.1 + 0.2).toFixed(2)) //0.3</span><br><span class="line"></span><br><span class="line">console.log(1.0 - 0.9) //0.09999999999999998</span><br><span class="line">console.log((1.0 - 0.9).toFixed(2)) //0.10</span><br></pre></td></tr></table></figure>

<p>将小数转为整数进行计算后，再转为小数也可以解决精度问题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Number.prototype.add = function (num) &#123;</span><br><span class="line">	//取两个数值中小数位最大的</span><br><span class="line">  let n1 = this.toString().split(&#x27;.&#x27;)[1].length</span><br><span class="line">  let n2 = num.toString().split(&#x27;.&#x27;)[1].length</span><br><span class="line">  </span><br><span class="line">  //得到10的N次幂</span><br><span class="line">  let m = Math.pow(10, Math.max(n1, n2))</span><br><span class="line"></span><br><span class="line">  return (this * m + num * m) / m</span><br><span class="line">&#125;</span><br><span class="line">console.log((0.1).add(0.2))</span><br></pre></td></tr></table></figure>

<p><strong>推荐做法</strong></p>
<p>市面上已经存在很多针对数学计算的库 <a href="https://mathjs.org/examples/browser/basic_usage.html.html">mathjs</a>、<a href="https://github.com/MikeMcl/decimal.js">decimal.js</a>等，我们就不需要自己构建了。下面来演示使用 <a href="https://github.com/MikeMcl/decimal.js">decimal.js </a>进行浮点计算。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/decimal.js/10.2.0/decimal.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	console.log(Decimal.add(0.1, 0.2).valueOf())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="五、Math"><a href="#五、Math" class="headerlink" title="五、Math"></a>五、Math</h3><p><code>Math</code> 对象提供了众多方法用来进行数学计算，下面我们介绍常用的方法，更多方法使用请查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">MDN官网</a>了解。</p>
<h4 id="取极限值"><a href="#取极限值" class="headerlink" title="取极限值"></a>取极限值</h4><p>使用 <code>min</code> 与 <code>max</code> 可以取得最小与最大值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Math.min(1, 2, 3));</span><br><span class="line"></span><br><span class="line">console.log(Math.max(1, 2, 3));</span><br></pre></td></tr></table></figure>

<p>—从数组中取值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">console.log(Math.max.apply(Math, arr));		</span><br><span class="line">console.log(Math.max(...arr));						</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="舍入处理"><a href="#舍入处理" class="headerlink" title="舍入处理"></a>舍入处理</h4><p><code>Math.ceil(num)</code>向上取整</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Math.ceil(1.111)); //2</span><br></pre></td></tr></table></figure>

<p><code>Math.floor(num)</code>向下取整</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Math.floor(1.555)); //1</span><br></pre></td></tr></table></figure>

<p><code>Math.round(num)</code>四舍五入处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Math.round(1.5)); //2</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p><code>random</code> 方法用于返回<code>[0,1)</code>的随机数。</p>
<p>返回<code>[0,n)</code>的随机数 公式为：Math.floor(Math.random()*n)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const number = Math.floor(Math.random() * 5);</span><br><span class="line">console.log(number);</span><br></pre></td></tr></table></figure>

<p>返回<code>[0,n]</code>的随机数 公式为：Math.floor(Math.random()*(n+1))</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const number = Math.floor(Math.random() * (5+1));</span><br><span class="line">console.log(number);</span><br></pre></td></tr></table></figure>

<p>下面取<code>[2,5)</code>的随机数 公式为：min+Math.floor(Math.random()*(Max-min))</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const number = Math.floor(Math.random() * (5 - 2)) + 2;</span><br><span class="line">console.log(number);</span><br></pre></td></tr></table></figure>

<p>下面取<code>[2,5]</code>的随机数 公式为：min+Math.floor(Math.random()*(Max-min+1))</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const number = Math.floor(Math.random() * (5 - 2 + 1)) + 2;</span><br><span class="line">console.log(number);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="取绝对值"><a href="#取绝对值" class="headerlink" title="取绝对值"></a>取绝对值</h4><p><code>Math.abs(num)</code>：取num的绝对值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Math.abs(-999));&#x2F;&#x2F;999</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="次幂运算"><a href="#次幂运算" class="headerlink" title="次幂运算"></a>次幂运算</h4><p><code>Math.pow(x,y)</code>：返回 x 的 y 次幂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Math.pow(10, -2)); &#x2F;&#x2F;0.01</span><br><span class="line">console.log(Math.pow(1, -2)); &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="六、Date"><a href="#六、Date" class="headerlink" title="六、Date"></a>六、Date</h3><p>  网站中处理日期时间是很常用的功能，通过 <code>Date</code> 类型提供的丰富功能可以非常方便的操作。</p>
<h4 id="声明日期"><a href="#声明日期" class="headerlink" title="声明日期"></a>声明日期</h4><p>获取当前日期时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let now = new Date();</span><br><span class="line">console.log(now);</span><br><span class="line">console.log(typeof date); //object （由构造函数实例化为Object）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//直接使用函数获取当前时间</span><br><span class="line">console.log(Date());</span><br><span class="line">console.log(typeof Date()); //string （直接使用Date()方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据指定的日期与时间定义日期对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let now = new Date(&#x27;2028-02-22 03:25:02&#x27;);</span><br><span class="line">console.log(now);</span><br><span class="line"></span><br><span class="line">now = new Date(2028, 4, 5, 1, 22, 16);</span><br><span class="line">console.log(now);</span><br></pre></td></tr></table></figure>

<p>使用展示运算符处理更方便</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let info = [2021, 3, 14, 10, 51, 19];</span><br><span class="line">let date = new Date(...info);</span><br><span class="line">console.dir(date);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>  js内的时间戳指的是<code>当前时间</code>到<code>1970年1月1日00:00:00</code>之间的<code>毫秒数</code>。</p>
<p>获取时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*	获取指定时间对象的时间戳，可通过内置方法来获取。</span><br><span class="line">*&#x2F;</span><br><span class="line">let as &#x3D; new Date(2021,3,14,11,06,23);</span><br><span class="line">console.log(as); &#x2F;&#x2F;w3c标准时间</span><br><span class="line">console.log(as.getTime()); &#x2F;&#x2F;getTime()获取as的时间戳</span><br><span class="line">console.log(as.valueOf()); &#x2F;&#x2F;valueOf()获取as的时间戳</span><br><span class="line">console.log(as*1);	&#x2F;&#x2F;转为数字即时间戳</span><br><span class="line"></span><br><span class="line">&#x2F;*	获取当前时间戳</span><br><span class="line">*&#x2F;</span><br><span class="line">console.log(Date.now()); </span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line">console.log(new Date()*1);	&#x2F;&#x2F;转为数字即时间戳</span><br></pre></td></tr></table></figure>

<p>计算脚本执行时间<code>Date.now()</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const start = Date.now();</span><br><span class="line">for (let i = 0; i &lt; 2000000; i++) &#123;&#125;</span><br><span class="line">const end = Date.now();</span><br><span class="line">console.log(end - start);</span><br></pre></td></tr></table></figure>

<p>当然也可以使用控制台测试<code>console.time(&quot;name&quot;) &amp;&amp; console.timeEnd(&quot;name&quot;)</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.time(&quot;testFor&quot;);</span><br><span class="line">for (let i = 0; i &lt; 20000000; i++) &#123;&#125;</span><br><span class="line">console.timeEnd(&quot;testFor&quot;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>w3c-&gt;时间戳</strong></p>
<ul>
<li>内置方法获取<code>getTime()\valueOf()</code></li>
<li>将日期<code>转为数值类型</code>就是转为时间戳，单位是毫秒。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = new Date(&quot;2020-2-22 10:33:12&quot;);</span><br><span class="line">console.log(as * 1);</span><br><span class="line"></span><br><span class="line">console.log(Number(as));</span><br><span class="line"></span><br><span class="line">console.log(as.valueOf())</span><br><span class="line"></span><br><span class="line">console.log(date.getTime());</span><br></pre></td></tr></table></figure>

<p><strong>时间戳-&gt;w3c</strong></p>
<ul>
<li><code>实例化Date</code>，并将时间戳作为参数传入。</li>
</ul>
<p>有时后台提供的日期为时间戳格式，下面是将时间戳转换为标准日期的方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const date = new Date().getTime();</span><br><span class="line">console.log(date);</span><br><span class="line">console.log(new Date(date));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="封装时间函数"><a href="#封装时间函数" class="headerlink" title="封装时间函数"></a>封装时间函数</h4><p>封装函数用于复用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function getCurrentTime(date = new Date(),modle = &quot;YYYY/MM/DD/HH/mm/ss&quot;) &#123;</span><br><span class="line">		let newDate = &#123;</span><br><span class="line">					YYYY: date.getFullYear(),</span><br><span class="line">					MM: date.getMonth() + 1,</span><br><span class="line">					DD: date.getDate(),</span><br><span class="line">					HH: date.getHours(),</span><br><span class="line">					mm: date.getMinutes(),</span><br><span class="line">					ss: date.getSeconds(),</span><br><span class="line">		&#125;;</span><br><span class="line">		for (let key in newDate) &#123;</span><br><span class="line">			modle = modle.replace(key, newDate[key]);</span><br><span class="line">		&#125;</span><br><span class="line">		return modle;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getCurrentTime());</span><br><span class="line">console.log(getCurrentTime(new Date(), &quot;YYYY-MM-DD&quot;));</span><br></pre></td></tr></table></figure>



<p>下面是系统提供的日期时间方法，更多方法请查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">MDN官网</a></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Date()</td>
<td align="left">返回当日的日期和时间。</td>
</tr>
<tr>
<td align="left">getDate()</td>
<td align="left">从 Date 对象返回<code>一个月中</code>的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">从 Date 对象返回<code>一周中</code>的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">从 Date 对象返回月份 (<code>0 ~ 11</code>)。</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">parse()</td>
<td align="left">返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">返回 时间戳</td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回 Date 对象的原始值。（时间戳）</td>
</tr>
<tr>
<td align="left">toString()</td>
<td align="left">把 Date 对象转换为字符串</td>
</tr>
</tbody></table>
<h4 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h4><p>Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。</p>
<p>更多使用方法请访问中文官网 <a href="http://momentjs.cn/">http://momentjs.cn</a>或 英文官网 <a href="https://momentjs.com/">https://momentjs.com</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>获取当前时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(moment().format(&quot;YYYY-MM-DD HH:mm:ss&quot;));</span><br></pre></td></tr></table></figure>

<p>设置时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(moment(&quot;2020-02-18 09:22:15&quot;).format(&quot;YYYY-MM-DD HH:mm:ss&quot;));</span><br></pre></td></tr></table></figure>

<p>十天后的日期</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(moment().add(10, &quot;days&quot;).format(&quot;YYYY-MM-DD hh:mm:ss&quot;));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>模块规范</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="模块规范"><a href="#模块规范" class="headerlink" title="模块规范"></a>模块规范</h2><h4 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h4><p>项目变大时需要把不同的业务分割成多个文件，这就是模块的思想。模块是比对象与函数更大的单元，使用模块组织程序便于维护与扩展。</p>
<p>生产环境中一般使用打包工具如 <code>webpack</code> 构建，他提供更多的功能。但学习完本章节后会再学习打包工具会变得简单。</p>
<ul>
<li>模块就是一个独立的文件，里面是函数或者类库</li>
<li>虽然JS没有命名空间的概念，使用模块可以解决全局变量冲突</li>
<li>模块需要隐藏内部实现，只对外开发接口</li>
<li>模块可以避免滥用全局变量，造成代码不可控</li>
<li>模块可以被不同的应用使用，提高编码效率</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><p>在过去JS不支持模块时我们使用<code>AMD/CMD（浏览器端使用）</code>、<code>CommonJS（Node.js使用）</code>、<code>UMD(两者都支持)</code>等形式定义模块。</p>
<p>AMD代表性的是 <code>require.js</code>，CMD 代表是淘宝的 <code>seaJS</code> 框架。</p>
<p>下面通过定义一个类似 <code>require.js</code> 的 <code>AMD</code> 模块管理引擎，来体验模块的工作原理。</p>
<blockquote>
<p>仿写 AMD 规范构建</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let module = (function () &#123;</span><br><span class="line">   //模块列表集合</span><br><span class="line">   const moduleLists = &#123;&#125;;</span><br><span class="line">   function define(name, modules, action) &#123;</span><br><span class="line">     modules.map((m, i) =&gt; &#123;</span><br><span class="line">       modules[i] = moduleLists[m];</span><br><span class="line">     &#125;);</span><br><span class="line">     //执行并保存模块</span><br><span class="line">     moduleLists[name] = action.apply(null, modules);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return &#123; define &#125;;</span><br><span class="line"> &#125;)();</span><br><span class="line"></span><br><span class="line"> //声明模块时不依赖其它模块</span><br><span class="line"> module.define(&quot;as&quot;, [], () =&gt; &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     getName() &#123;</span><br><span class="line">       return this.name;</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;);</span><br><span class="line"> //声明模块时依赖其它模块</span><br><span class="line"> module.define(&quot;shun&quot;, [&quot;as&quot;], (modules) =&gt; &#123;</span><br><span class="line">   let curr = &#123;</span><br><span class="line">     getAge() &#123;</span><br><span class="line">       return this.age;</span><br><span class="line">     &#125;,</span><br><span class="line">     name: &quot;shun&quot;,</span><br><span class="line">   &#125;;</span><br><span class="line">   console.log(modules.getName.call(curr));</span><br><span class="line"></span><br><span class="line">   return curr;</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> module.define(&quot;SHUN&quot;, [&quot;as&quot;, &quot;shun&quot;], (...modules) =&gt; &#123;</span><br><span class="line">   let curr = &#123;</span><br><span class="line">     show() &#123;</span><br><span class="line">       console.log(this.name, this.age);</span><br><span class="line">     &#125;,</span><br><span class="line">     name: &quot;Ashun&quot;,</span><br><span class="line">     age: 18,</span><br><span class="line">   &#125;;</span><br><span class="line">   let merge = Object.assign(...modules, curr);</span><br><span class="line">   console.log(merge);</span><br><span class="line"></span><br><span class="line">   console.log(merge.getName());</span><br><span class="line">   return merge;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>





<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="标签使用"><a href="#标签使用" class="headerlink" title="标签使用"></a>标签使用</h4><p>在浏览器中使用以下语法 靠<code>Javascript脚本提供的模块化规范</code> 管理各个js模块，这样就可以在js文件中使用模块代码了。</p>
<p>在html文件中导入模块，需要定义属性 <code>type=&quot;module&quot;</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>在浏览器中运行<code>js模块化规范</code>管理的模块 在引入时，必须填写正确的路径 如<code>./xxx.js</code> 。</p>
<p>测试的 <code>as.js</code> 的模块内容如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export let as = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面没有指定路径将发生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123; as &#125; from &quot;as.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>正确使用需要添加上路径</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123; as &#125; from &quot;./as.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="延迟解析"><a href="#延迟解析" class="headerlink" title="延迟解析"></a>延迟解析</h4><p>模块总是会在<code>所有html解析后</code>才执行，下面的模块代码可以看到后加载的 <code>button</code> 按钮元素。</p>
<ul>
<li>建议为用户提供加载动画提示，当模块运行时再去掉动画</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    console.log(document.querySelector(&quot;button&quot;)); //Button</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.log(document.querySelector(&quot;button&quot;)); //undefined</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;button&gt;阿顺特烦恼&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="默认严格"><a href="#默认严格" class="headerlink" title="默认严格"></a>默认严格</h4><p>模块默认运行在严格模式，以下代码没有使用声明语句将报错</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">	as = &quot;Ashuntefannao&quot;; // Error</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面的 <code>this</code> 也会是 <code>undefined</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(this); //Window</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  console.log(this); //undefiend</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="独立作用域"><a href="#独立作用域" class="headerlink" title="独立作用域"></a>独立作用域</h4><p>模块都有独立的顶级作用域，下面的模块不能互相访问</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  let as = &quot;Ashuntefannao&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  alert(as); // Error</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>引入单独文件，作用域也是独立的，下面的模块 <code>1.2.js</code> 不能访问模块 <code>1.1.js</code> 中的数据</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;1.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;1.2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">文件内容如下</span><br><span class="line"># 1.1.js</span><br><span class="line">let as = &quot;Ashuntefannao&quot;;</span><br><span class="line"></span><br><span class="line"># 1.2.js</span><br><span class="line">console.log(as)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="一次解析"><a href="#一次解析" class="headerlink" title="一次解析"></a>一次解析</h4><p>模块在导入时<code>只执行一次解析</code>，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据。</p>
<ul>
<li>可以在首次导入时完成一些初始化工作</li>
<li>如果模块内有后台请求，也只执行一次</li>
</ul>
<p>引入多入<code>as.js</code> 脚本时只执行一次</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;./as.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;./as.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"># as.js内容如下</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>

<p>下面在导入多次 <code>as.js</code> 时只解析一次</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &quot;./as.js&quot;;</span><br><span class="line">  import &quot;./as.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"># as.js内容如下</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>ES6使用基于文件的模块，即一个文件一个模块。</p>
<ul>
<li>使用<code>export</code> 将开发的接口导出</li>
<li>使用<code>import</code> 导入模块接口</li>
</ul>
<h4 id="具名导出"><a href="#具名导出" class="headerlink" title="具名导出"></a>具名导出</h4><p>下面定义模块 <code>modules/as.js</code> ，使用 <code>export</code> 具名导出模块接口，没有导出的变量都是模块私有的。</p>
<p>下面是对定义的 <code>as.js</code> 模块，分别导出内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">export const site = &quot;ashuntefannao&quot;;</span><br><span class="line">export const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">export class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="批量导出"><a href="#批量导出" class="headerlink" title="批量导出"></a>批量导出</h5><p>也可在定义被导出变量后，使用<code>批量导出</code>一次性导出多个变量接口,<code>export&#123;…options&#125;</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">const site = &quot;ashuntefannao&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; site, func, User &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="具名导入"><a href="#具名导入" class="headerlink" title="具名导入"></a>具名导入</h4><p><code>具名导入</code>与<code>具名导出</code>相对应，具名导出的模块接口，需要具名导入。</p>
<p>下面导入上面定义的 <code>as.js</code> 模块，分别导入模块导出的内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123; User, site, func &#125; from &quot;./as.js&quot;;</span><br><span class="line">  console.log(site);</span><br><span class="line">  console.log(User);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可只导入部分变量接口，需要哪些导入哪些，当然了 所导入的变量接口，必须被所引入的模块导出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import &#123; User &#125; from &quot;.&#x2F;as.js&quot;;</span><br><span class="line">  console.log(User);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>像下面这样在 <code>&#123;&#125;</code> 中导入是错误的，模块默认是在<code>顶层静态导入</code>，这是为了分析使用的模块，方便打包</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  import &#123; site, func &#125; from &quot;./as.js&quot;; // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="批量导入"><a href="#批量导入" class="headerlink" title="批量导入"></a>批量导入</h5><p>也可使用批量导入语法<code>import * as alias </code>，一次性将所有暴露的接口导入，并为批量导入的接口起一个<code>别名</code>，之后通过别名来访问批量导出的对象。</p>
<ul>
<li><code>*</code>整体为一个Object，为其设置别名后通过<code>alias.propName</code>访问导出的具体变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import * as api from &quot;.&#x2F;hd.js&quot;;</span><br><span class="line">  console.log(api.site);</span><br><span class="line">  console.log(api.User);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="导入建议"><a href="#导入建议" class="headerlink" title="导入建议"></a>导入建议</h4><p>因为以下几点，我们更建议使用明确导入方式</p>
<ul>
<li>使用<code>webpack</code> 构建工具时，没有导入的功能会删除节省文件大小</li>
<li>可以更清晰知道都使用了其他模块的哪些功能</li>
</ul>
<hr>
<h3 id="别名使用"><a href="#别名使用" class="headerlink" title="别名使用"></a>别名使用</h3><h4 id="别名导入"><a href="#别名导入" class="headerlink" title="别名导入"></a>别名导入</h4><p>可以为导入的模块重新命名，语法: <code>import &#123; oldName as newName …&#125;</code></p>
<p><strong>应用场景</strong></p>
<ul>
<li>有些导出的模块命名过长，起别名可以更加简洁</li>
<li>本模块与导入模块 变量重名时，可以通过起别名防止冲突</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">const site = &quot;ashuntefannao&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; site, func, User &#125;;</span><br></pre></td></tr></table></figure>

<p>模块导入使用 <code>as</code> 对接口重命名，本模块中已经存在 <code>func</code> 变量，需要对导入的模块重命名防止命名错误。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123; User as user, func as method, site as name &#125; from &quot;./as.js&quot;;</span><br><span class="line">  let func = &quot;ashunMethod&quot;;</span><br><span class="line">  console.log(name);</span><br><span class="line">  console.log(user);</span><br><span class="line">  console.log(method);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="别名导出"><a href="#别名导出" class="headerlink" title="别名导出"></a>别名导出</h4><p>模块可以对 暴露给外部的接口 起别名，下面是<code>as.js</code> 模块对暴露的接口起别名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">const site = &quot;ashuntefannao&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; site, func as method, User as user &#125;;</span><br></pre></td></tr></table></figure>

<p>由于模块暴露时，为其接口起了别名，所以在具名导入时，应导入对应的别名。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123; user, method &#125; from &quot;./as.js&quot;;</span><br><span class="line">  method();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>很多时候模块只是一个类，也就是说只需要导入一个内容，这地可以使用默认导入。</p>
<p>使用<code>default</code>关键字 定义默认导出的接口，导入时不需要使用 <code>&#123;&#125;</code></p>
<ul>
<li><p>只能有一个默认导出</p>
</li>
<li><p>默认导出可以没有命名</p>
</li>
<li><p>在导入时可以任意命名</p>
</li>
</ul>
<h4 id="单一导出"><a href="#单一导出" class="headerlink" title="单一导出"></a>单一导出</h4><p>下面是<code>as.js</code> 模块内容，默认只导出一个类。并且没有对类命名，这是可以的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export default class &#123;</span><br><span class="line">  static show() &#123;</span><br><span class="line">    console.log(&quot;User.method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将一个导出的接口 分配别名为 <code>default</code> 也算默认导出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  static show() &#123;</span><br><span class="line">    console.log(&quot;User.method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; User as default &#125;;</span><br></pre></td></tr></table></figure>

<p>导入时就不需要使用 <code>&#123;&#125;</code> 来导入了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import User from &quot;./hd.js&quot;;</span><br><span class="line">  User.show();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>默认导出的接口 在引入时 可以随意命名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import as from &quot;./hd.js&quot;;</span><br><span class="line">  as.show();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="混合导出"><a href="#混合导出" class="headerlink" title="混合导出"></a>混合导出</h4><p>模块可以存在默认导出与命名导出。</p>
<p>使用<code>export default</code> 导出默认接口，使用 <code>export &#123;&#125;</code> 导入普通接口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">const site = &quot;ashuntefannao&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">export default class &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; site, func &#125;;</span><br></pre></td></tr></table></figure>

<p>也可以结合别名<code>oldName as default</code>综合导出各个接口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title=&quot;阿顺特烦恼&quot;;</span><br><span class="line">const site = &quot;ashuntefannao&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  return &quot;is a module function&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; site, func, User as default &#125;;</span><br></pre></td></tr></table></figure>

<p>导入默认接口时不需要使用 <code>&#123;&#125;</code> ，普通接口还用 <code>&#123;&#125;</code> 导入</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">	//可以将 as 替换为任何变量</span><br><span class="line">  import as from &quot;./as.js&quot;;</span><br><span class="line">  import &#123; site &#125; from &quot;./as.js&quot;;</span><br><span class="line">  console.log(site);</span><br><span class="line">  as.show();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用一条语句导入默认接口与常规接口，使用<code>,</code>隔开</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import show, &#123; name &#125; from &quot;/modules/ashun.js&quot;;</span><br></pre></td></tr></table></figure>

<p>也可以使用别名导入 默认导出的接口</p>
<ul>
<li><code>default as 自定义名称</code>，之后通过 自定义的变量 访问默认导出接口</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import &#123; site, default as as &#125; from &quot;./as.js&quot;;</span><br><span class="line">console.log(site);</span><br><span class="line">as.show();</span><br></pre></td></tr></table></figure>

<p>如果是批量导入时，使用 <code>alias.default</code> 获得默认导出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import * as api from &quot;./as.js&quot;;</span><br><span class="line">  console.log(api.site);</span><br><span class="line">  api.default.show();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><p>对于默认导出和命名导出有以下建议</p>
<ul>
<li><p>不建议使用默认导出，会让开发者导入时随意命名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import as from &quot;./as.js&quot;;</span><br><span class="line">import shun from &quot;./as.js&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>如果使用默认导入，自定义的名称最好和 模块的文件名 有关联，会使用代码更易阅读</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import as from &quot;./as.js&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="导出合并"><a href="#导出合并" class="headerlink" title="导出合并"></a>导出合并</h3><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>可以将导入的模块重新导出使用，比如项目模块比较多如下所示，这时可以将所有模块<code>合并到一个入口文件</code>中。</p>
<p>这样只需要使用一个模块入口文件，而不用关注多个模块文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|--test1.js</span><br><span class="line">|--test2.js</span><br><span class="line">|--test3.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><p>下面是 <code>test1.js</code> 模块内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const site = &quot;阿顺特烦恼&quot;;</span><br><span class="line">const func = function () &#123;</span><br><span class="line">  console.log(&quot;is a module function&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; site, func &#125;;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>test2.js</code> 模块内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export default class &#123;</span><br><span class="line">  static get() &#123;</span><br><span class="line">    console.log(&quot;ashun.js.get&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>test3.js</code> 模块内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function method() &#123;</span><br><span class="line">  console.log(&quot;test3 method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是 <code>index.js</code> 模块内容，由于我们想让index.js为入口文件，所有的模块都存放其中，暴露给外部。ES模块化规范提供了对应的语法，在<code>index.js</code>中<code>导入其他模块的同时也将其导出</code>。</p>
<ul>
<li>将<code>import</code>与<code>export</code>合并使用，在导入的同时进行导出</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export * as as from &quot;./test1.js&quot;;</span><br><span class="line">//相当于以下语句</span><br><span class="line">// import * as as from &quot;./test1.js&quot;</span><br><span class="line">// export &#123; as &#125;</span><br><span class="line"></span><br><span class="line">export &#123; default as shunClass &#125; from &quot;./test2.js&quot;;</span><br><span class="line">// 以上导入test2的语句相当于下两句</span><br><span class="line">// import &#123; default as shunClass &#125; from &quot;./test2.js&quot;;</span><br><span class="line">// export &#123; shunClass &#125;;</span><br><span class="line">// 也等价于</span><br><span class="line">// import shunClass  from &quot;./test2.js&quot;;</span><br><span class="line">// export &#123; shunClass &#125;;</span><br><span class="line"></span><br><span class="line">// 但以下方式导出 test2默认导出的模块 是错误的</span><br><span class="line">// export shunClass from &quot;./test3.js&quot;;</span><br><span class="line"></span><br><span class="line">//	在index.js中，默认导出test3中的method。</span><br><span class="line">export &#123; method as default &#125; from &quot;./test3.js&quot;;</span><br><span class="line">//	相当于以下语句</span><br><span class="line">//  import &#123;method&#125; from &quot;./test3.js&quot;</span><br><span class="line">//	export &#123;method as default&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import * as api from &quot;./index.js&quot;;</span><br><span class="line">  console.log(api.shunClass);</span><br><span class="line">  console.log(api.as.site);</span><br><span class="line">  api.as.func();</span><br><span class="line">  api.default();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//等价于</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">      import test3Method, &#123; as, shunClass &#125; from &quot;./index.js&quot;;</span><br><span class="line">      console.log(shunClass);</span><br><span class="line">      console.log(as.site);</span><br><span class="line">      test3Method();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//等价于</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">      import &#123; as, shunClass, default as test3Method &#125; from &quot;./index.js&quot;;</span><br><span class="line">      console.log(shunClass);</span><br><span class="line">      console.log(as.site);</span><br><span class="line">      test3Method();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>使用 <code>import</code> 关键字 必须在<code>顶层静态导入</code>模块，而使用<code>import(&quot;path&quot;)</code> 函数可以按需动态的导入模块，它返回一个 <code>promise</code> 对象。</p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p>必须在顶层静态导入，否则会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  import &#123; site, func &#125; from &quot;.&#x2F;as.js&quot;; &#x2F;&#x2F; Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按需动态导入"><a href="#按需动态导入" class="headerlink" title="按需动态导入"></a>按需动态导入</h4><p>测试用的 <code>as.js</code> 模块内容如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const site = &quot;阿顺特烦恼&quot;;</span><br><span class="line">const func = function() &#123;</span><br><span class="line">  console.log(&quot;is a module function&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; site, func &#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>import(&quot;path&quot;)</code> 函数可以动态导入，实现按需加载</p>
<ul>
<li><code>import()</code>返回<code>promise</code>，可以使用promise方法在导入模块后进行操作</li>
<li><code>import(&quot;path&quot;).then(module=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let as = import(&quot;./as.js&quot;).then(module =&gt; &#123;</span><br><span class="line">      console.log(module.site);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是在点击事件发生后按需要加载模块</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;阿顺特烦恼&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">    let as = import(&quot;./as.js&quot;).then(module =&gt; &#123;</span><br><span class="line">      console.log(module.site);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>因为是返回的对象可以使用解构语法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;后盾人&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">    let hd = import(&quot;./hd.js&quot;).then((&#123; site, func &#125;) =&gt; &#123;</span><br><span class="line">      console.log(site);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>export function show(){}</td>
<td>具名导出函数</td>
</tr>
<tr>
<td>export const name=’阿顺’</td>
<td>具名导出变量</td>
</tr>
<tr>
<td>export class User{}</td>
<td>具名导出类</td>
</tr>
<tr>
<td>export { show , name ,  User }</td>
<td>批量具名导出</td>
</tr>
<tr>
<td>export default show</td>
<td>默认导出</td>
</tr>
<tr>
<td>export default show  ……  export{ name ,  User }</td>
<td>混合导出</td>
</tr>
<tr>
<td>export { show as default , name ,  User  }</td>
<td>批量混合导出</td>
</tr>
<tr>
<td>export {name as shun_name}</td>
<td>别名导出</td>
</tr>
<tr>
<td>import {name,show} from ‘as.js’</td>
<td>具名导入</td>
</tr>
<tr>
<td>import defaultVar from ‘ashun.js’</td>
<td>导入默认导出</td>
</tr>
<tr>
<td>import defaultVar,{name,show} from &#39;as.js&#39;</td>
<td>混合导入</td>
</tr>
<tr>
<td>import  {name , show , default as defaultVar} from &#39;as.js&#39;</td>
<td>混合导入</td>
</tr>
<tr>
<td>Import { name as asName , show } from ‘ashun.js’</td>
<td>别名导入</td>
</tr>
<tr>
<td>Import * as api from ‘ashun.js’</td>
<td>导入全部接口</td>
</tr>
</tbody></table>
<p><em><strong>导入并导出</strong></em></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>export { name, site } from “./as.js”</td>
<td>将as.js中的<code>name、site</code>具名导入并导出</td>
</tr>
<tr>
<td>export { name as asName , site } from “./as.js”</td>
<td>将as.js中的<code>name</code>别名导入导出；<code>site</code>具名导入并导出</td>
</tr>
<tr>
<td>export { name as default } from “./as.js”</td>
<td>将as.js中的<code>name</code>具名导入再默认导出</td>
</tr>
<tr>
<td>export { default as defaultVar } from “./as.js”</td>
<td>将as.js中的默认导出进行导入，再以<code>defaultVar</code>具名导出</td>
</tr>
<tr>
<td>export * as asAPI from “./as.js”;</td>
<td>将as.js中暴露的接口合并导入，再以<code>asAPI</code>具名导出</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>空间坐标</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<h2 id="空间坐标"><a href="#空间坐标" class="headerlink" title="空间坐标"></a>空间坐标</h2><h3 id="视口与文档"><a href="#视口与文档" class="headerlink" title="视口与文档"></a>视口与文档</h3><p>首先理解视口（窗口）与文档的含义</p>
<ul>
<li>网页很多都是多屏（通过滚动条显示看不见的内容），所以文档尺寸一般大于视口尺寸</li>
<li>视口可以理解为可视区域，而不是全部的文档</li>
<li>视口尺寸不包括浏览器工具条、菜单、标签、状态栏等</li>
<li>当你打开控制台后，视口尺寸就相应变小了</li>
<li>position使用文档定位，fixed使用视口定位</li>
<li>文档坐标在页面滚动时不发生改变</li>
<li>视口坐标的操作需要考虑滚动条的位置</li>
</ul>
<img src="空间坐标.assets/视口_文档区域1.png" alt="image-20210413150736697" style="zoom:75%;" />

<h4 id="视口与文档尺寸"><a href="#视口与文档尺寸" class="headerlink" title="视口与文档尺寸"></a>视口与文档尺寸</h4><p>视口坐标需要知道滚动条位置才可以进行计算，有以下几种方式获取滚动位置</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>window.innerWidth</td>
<td>视口宽度</td>
<td>包括滚动条（不常用）</td>
</tr>
<tr>
<td>window.innerHeight</td>
<td>视口高度</td>
<td>包括滚动条（不常用）</td>
</tr>
<tr>
<td>document.documentElement.clientWidth</td>
<td>视口宽度</td>
<td></td>
</tr>
<tr>
<td>document.documentElement.clientHeight</td>
<td>视口高度</td>
<td></td>
</tr>
</tbody></table>
<h3 id="几何尺寸"><a href="#几何尺寸" class="headerlink" title="几何尺寸"></a>几何尺寸</h3><p>元素在页面中拥有多个描述几何数值的尺寸，下面截图进行了形象的描述。</p>
<img src="空间坐标.assets/视口_文档区域2.png" alt="image-20210413150736697" style="zoom:75%;" />



<h4 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h4><p>下面是获取尺寸的方法或属性</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>element.getBoundingClientRect</td>
<td>返回元素在视口坐标及元素大小，width/height不包括外边距，与offsetWidth/offsetHeight匹配</td>
<td>窗口坐标</td>
</tr>
<tr>
<td>element.getClientRects</td>
<td>行级元素每行尺寸位置组成的数组</td>
<td></td>
</tr>
<tr>
<td>element.offsetParent</td>
<td>拥有定位属性的父级，或body/td/th/table</td>
<td>对于隐藏元素/body/html值为null</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>元素宽度尺寸，包括内边距与边框和滚动条</td>
<td></td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>元素高度尺寸，包括内边距与边框和滚动条</td>
<td></td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>相对于祖先元素的X轴坐标</td>
<td></td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>相对于祖先元素的Y轴坐标</td>
<td></td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>元素宽度，不包含边框，只包含内容和内边距，行元素尺寸为0</td>
<td></td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>元素高度，不包含边框，只包含内容和内边距，行元素尺寸为0</td>
<td></td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>内容距离外部的距离，滚动条在左侧时包括滚动条尺寸</td>
<td></td>
</tr>
<tr>
<td>element.clientTop</td>
<td>内容距离顶部的距离，滚动条在顶部时包括滚动条尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>元素宽度，内容+内边距+内容溢出的尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>元素高度，内容+内边距+内容溢出的尺寸</td>
<td></td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>水平滚动条左侧已经滚动的宽度</td>
<td></td>
</tr>
<tr>
<td>element.scrollTop</td>
<td>垂直滚动条顶部已经滚动的高度</td>
<td></td>
</tr>
</tbody></table>
<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle"></a>getComputedStyle</h4><p>为什么不要使用getComputedStyle</p>
<ul>
<li>尺寸设置auto时获取结果不可用</li>
<li>由于滚动条的存在，不同浏览器返回结果不同</li>
<li>当元素没有设置CSS尺寸时，获取不到相应的尺寸内容</li>
</ul>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>使用<code>getBoundingClientRect</code>获取元素矩形信息</p>
<img src="空间坐标.assets/视口_文档区域3.png" alt="image-20210413150736697" style="zoom:38%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        height: 300px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        border: 5px solid #ddd;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">        let position &#x3D; div.getBoundingClientRect();</span><br><span class="line">        console.log(position);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>计算结果的矩形尺寸不包括外边距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bottom: 340</span><br><span class="line">height: 330</span><br><span class="line">left: 18</span><br><span class="line">right: 348</span><br><span class="line">top: 10</span><br><span class="line">width: 330</span><br><span class="line">x: 18</span><br><span class="line">y: 10</span><br></pre></td></tr></table></figure>



<h4 id="getClientRects"><a href="#getClientRects" class="headerlink" title="getClientRects"></a>getClientRects</h4><p>getClientRects使用场景：多行元素时 分别返回每行所占的尺寸，下面的行元素将为每行返回对应矩形尺寸</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	span &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。网页很多都是多屏，所以文档尺寸一般大于视口尺寸,当打开控制台后，视口尺寸相应变小。</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let span = document.querySelector(&#x27;span&#x27;)</span><br><span class="line">  let info = span.getClientRects()</span><br><span class="line">  console.log(info)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上例计算结果如下</p>
<table>
<thead>
<tr>
<th align="left">(index)</th>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">width</th>
<th align="left">height</th>
<th align="left">top</th>
<th align="left">right</th>
<th align="left">bottom</th>
<th align="left">left</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">8</td>
<td align="left">8</td>
<td align="left">1255.7125244140625</td>
<td align="left">20.80000114440918</td>
<td align="left">8</td>
<td align="left">1263.7125244140625</td>
<td align="left">28.80000114440918</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">28.80000114440918</td>
<td align="left">675.8624877929688</td>
<td align="left">20.80000114440918</td>
<td align="left">28.80000114440918</td>
<td align="left">683.8624877929688</td>
<td align="left">49.60000228881836</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">length</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">2</td>
</tr>
</tbody></table>
<h3 id="坐标点元素"><a href="#坐标点元素" class="headerlink" title="坐标点元素"></a>坐标点元素</h3><p>JS提供了方法获取指定坐标上的元素，如果指定坐标点在视口外，返回值为NULL</p>
<ul>
<li>坐标都是从左上角计算，这与CSS中的right/bottom等不同</li>
<li>视口坐标类似于position:fixed</li>
<li>文档坐标类似于position:absolute</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>element.elementsFromPoint(x,y)</td>
<td>返回指定坐标点所在的元素集合<code>Array</code></td>
</tr>
<tr>
<td>element.elementFromPoint(x,y)</td>
<td>返回指定坐标点最顶层的元素</td>
</tr>
</tbody></table>
<h4 id="元素集合"><a href="#元素集合" class="headerlink" title="元素集合"></a>元素集合</h4><p>返回指定坐标点上的元素集合<code>Array</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        background-color: black;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.elementsFromPoint(99, 99));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回结果为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[div#app, body, html]</span><br></pre></td></tr></table></figure>

<h4 id="底层元素"><a href="#底层元素" class="headerlink" title="底层元素"></a>底层元素</h4><p>返回坐标点上的最底层的元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        background-color: black;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.elementFromPoint(99, 99));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回结果为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">div</span><br></pre></td></tr></table></figure>



<h3 id="滚动控制"><a href="#滚动控制" class="headerlink" title="滚动控制"></a>滚动控制</h3><p>下面掌握文档或元素的滚动操作</p>
<h4 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h4><p>获取滚动</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>window.pageXOffset</td>
<td>文档相对视口水平滚动的像素距离</td>
<td></td>
</tr>
<tr>
<td>window.pageYOffset</td>
<td>文档相对视口竖直滚动的像素距离</td>
<td></td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>获取和设置元素X轴滚动位置</td>
<td></td>
</tr>
<tr>
<td>element.scrollTop</td>
<td>获取和设置元素Y轴滚动位置</td>
<td></td>
</tr>
</tbody></table>
<p>控制滚动</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollBy()</td>
<td>按偏移量进行滚动内容</td>
<td>参数为<code>obj</code>，{top:垂直偏移量,left:水平偏移量,behavior:’滚动方式’}</td>
</tr>
<tr>
<td>element.scroll() 或 element.scrollTo()</td>
<td>滚动到指定的具体位置</td>
<td>参数为<code>obj</code>，{top:X轴文档位置,left:Y轴文档位置,behavior:’滚动方式’}</td>
</tr>
<tr>
<td>element.scrollIntoView(bool)</td>
<td>定位到顶部或底部</td>
<td>参数为:<code>obj/boolean</code>—参数为<code>boolean</code>：true元素定位到顶部，为false定位到窗口底部。—参数为<code>obj</code>：<code>&#123;block:&quot;start/end&quot;,behavior:&quot;smooth&quot;&#125;</code></td>
</tr>
</tbody></table>
<h4 id="获取滚动位置"><a href="#获取滚动位置" class="headerlink" title="获取滚动位置"></a>获取滚动位置</h4><h5 id="文档滚动位置"><a href="#文档滚动位置" class="headerlink" title="文档滚动位置"></a>文档滚动位置</h5><p>下例是查看文档滚动的X/Y坐标示例,<code>window.pageXOffset/pageYOffset</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;width: 3000px; height: 3000px; background: #e34334&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onscroll = function () &#123;</span><br><span class="line">        console.log(window.pageXOffset)</span><br><span class="line">        console.log(window.pageYOffset)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>doucment.documentElement</code>能够访问到html元素，所以可以使用元素的方法<code>element.scrollTop/scrollLeft</code>获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 3000px; height: 3000px; background: #e34334&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onscroll &#x3D; function () &#123;</span><br><span class="line">        console.log(document.documentElement.scrollTop)</span><br><span class="line">        console.log(document.documentElement.scrollLeft)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="元素滚动位置"><a href="#元素滚动位置" class="headerlink" title="元素滚动位置"></a>元素滚动位置</h5><p>下面查看元素内容的滚动属性，请在控制台查看结果</p>
<ul>
<li>要为父元素设置 overflow:scroll 以使其产生滚动条</li>
<li>使用scroll 事件来监听结果</li>
</ul>
<img src="空间坐标.assets/视口_文档区域4.gif" alt="视口_文档区域4.gif" style="zoom:75%;" />

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; style=&quot;width: 300px; height: 300px; border: solid 6px #e34334; overflow: auto&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width: 1000px; height: 1000px; background: #833ca4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">    app.addEventListener(&#x27;scroll&#x27;, function () &#123;</span><br><span class="line">        console.log(this.scrollLeft)</span><br><span class="line">        console.log(this.scrollTop)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="控制滚动位置"><a href="#控制滚动位置" class="headerlink" title="控制滚动位置"></a>控制滚动位置</h4><p>下面介绍的是控制元素滚动的操作方法</p>
<h5 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy"></a>scrollBy</h5><p>使用<code>scrollBy(&#123;top,left,behavior&#125;)</code><strong>按偏移量</strong>滚动整个文档</p>
<ul>
<li><code>behavior:smooth </code>为平滑滚动</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: linear-gradient(</span><br><span class="line">          to bottom,</span><br><span class="line">          #ecf0f1,</span><br><span class="line">          #1abc9c,</span><br><span class="line">          #f39c12,</span><br><span class="line">          #ecf0f1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">//每隔1秒,向下滚动30px,参照上次的位置，即按偏移量进行滚动</span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    document.documentElement.scrollBy(&#123; top: 30, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>scrollTop/scrollLeft</code>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      let top &#x3D; 0;</span><br><span class="line">      setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        top +&#x3D; 30;</span><br><span class="line">        document.documentElement.scrollTop &#x3D; top;</span><br><span class="line">      &#125;, 1000);</span><br></pre></td></tr></table></figure>



<h5 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h5><p>使用<code>scroll(&#123;top,left,behavior&#125;)</code>滚动到指定位置</p>
<ul>
<li><code>behavior:smooth</code> 为平滑滚动</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body &#123;</span><br><span class="line">    height: 3000px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">//3秒后，滚动到指定位置</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    document.documentElement.scroll(&#123; top: 30, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>scrollTop/scrollLeft</code>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        document.documentElement.scrollTop &#x3D; 30;</span><br><span class="line">      &#125;, 1000);</span><br></pre></td></tr></table></figure>



<h5 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h5><p>使用元素scrollIntoView方法实现滚动操作，参数可以是布尔值或对象</p>
<ul>
<li>参数为Boolean<ul>
<li>参数为 true 时顶部对齐，相当于{block: “start”}</li>
<li>参数为 false 时底部对齐，相当于{block: “end”}</li>
</ul>
</li>
<li>参数为obj<ul>
<li>block:”start/width”</li>
<li>behavior:”smooth”</li>
</ul>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: red;</span><br><span class="line">        border-top: solid 50px #efbc0f;</span><br><span class="line">        border-bottom: solid 50px #1bb491;</span><br><span class="line">    &#125;</span><br><span class="line">    span &#123;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background: #000;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        display: block;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 50px;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 50%;</span><br><span class="line">        right: 50px;</span><br><span class="line">        border: solid 2px #ddd;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;hdcms.com&lt;/div&gt;</span><br><span class="line">&lt;span&gt;TOP&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#x27;span&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">        let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">        app.scrollIntoView(&#123; block: &#x27;end&#x27;, behavior: &#x27;smooth&#x27; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h4><h5 id="backTop"><a href="#backTop" class="headerlink" title="backTop"></a>backTop</h5><p>下例是开发中常用的回到顶部示例</p>
<img src="空间坐标.assets/视口_文档区域5.gif" alt="视口_文档区域5.gif" style="zoom:75%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: linear-gradient(</span><br><span class="line">          to bottom,</span><br><span class="line">          #ecf0f1,</span><br><span class="line">          #1abc9c,</span><br><span class="line">          #f39c12,</span><br><span class="line">          #ecf0f1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      .backtop &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        position: fixed;</span><br><span class="line">        right: 10px;</span><br><span class="line">        bottom: 10px;</span><br><span class="line">        z-index: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: rgba(0, 0, 0, 0.75);</span><br><span class="line">        color: white;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        transition: 0.6s;</span><br><span class="line">        transform: scale(0);</span><br><span class="line">      &#125;</span><br><span class="line">      .show &#123;</span><br><span class="line">        transform: scale(1) rotateZ(360deg);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;backtop&quot;&gt;Top&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let backtop &#x3D; document.querySelector(&quot;.backtop&quot;);</span><br><span class="line">      backtop.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        document.documentElement.scrollIntoView(&#123;</span><br><span class="line">          block: &quot;start&quot;,</span><br><span class="line">          behavior: &quot;smooth&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      window.onscroll &#x3D; function () &#123;</span><br><span class="line">        let test &#x3D;</span><br><span class="line">          document.documentElement.scrollTop +</span><br><span class="line">            document.documentElement.clientHeight &gt;</span><br><span class="line">          document.documentElement.scrollHeight - 300;</span><br><span class="line"></span><br><span class="line">        backtop.classList[test ? &quot;add&quot; : &quot;remove&quot;](&quot;show&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="漂浮广告"><a href="#漂浮广告" class="headerlink" title="漂浮广告"></a>漂浮广告</h5><p>下面是全屏漂浮广告的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        color: rgba(255, 255, 255, 0.8);</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: #e34334;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Ad &#123;</span><br><span class="line">        constructor(preset) &#123;</span><br><span class="line">          this.$el &#x3D; preset.el;</span><br><span class="line">          &#x2F;&#x2F;初始移动方向，1向下&#x2F;向右 -1 向上&#x2F;向左</span><br><span class="line">          this.x &#x3D; this.y &#x3D; 1;</span><br><span class="line">          this.preset &#x3D; Object.assign(&#123;delay: 10,step: 1,&#125;,preset);</span><br><span class="line">          this.run();</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">          this.init();</span><br><span class="line">          setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            this.$el.style.left &#x3D; this.leftMove() + &quot;px&quot;;</span><br><span class="line">            this.$el.style.top &#x3D; this.topMove() + &quot;px&quot;;</span><br><span class="line">          &#125;, this.preset.delay);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置定位模式</span><br><span class="line">        init() &#123;</span><br><span class="line">          this.$el.style.position &#x3D; &quot;fixed&quot;;</span><br><span class="line">          this.$el.style.top &#x3D; 0;</span><br><span class="line">          this.$el.style.left &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        leftMove() &#123;</span><br><span class="line">          let &#123; x, width &#125; &#x3D; this.$el.getBoundingClientRect();</span><br><span class="line">          let &#123; clientWidth &#125; &#x3D; document.documentElement;</span><br><span class="line">          if (x &gt; clientWidth - width) this.x &#x3D; -1;</span><br><span class="line">          if (x &lt; 0) this.x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">          return x + this.preset.step * this.x;</span><br><span class="line">        &#125;</span><br><span class="line">        topMove() &#123;</span><br><span class="line">          let &#123; y, height &#125; &#x3D; this.$el.getBoundingClientRect();</span><br><span class="line">          let &#123; clientHeight &#125; &#x3D; document.documentElement;</span><br><span class="line">          if (y &gt; clientHeight - height) this.y &#x3D; -1;</span><br><span class="line">          if (y &lt; 0) this.y &#x3D; 1;</span><br><span class="line">          return y + this.preset.step * this.y;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      new Ad(&#123; el: div &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>网络请求</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>浏览器天生具发送HTTP请求的能力，比如在在址栏输入内容，提交FORM表单等。本章来学习通过JS程序来管理HTTP请求的能力。</p>
<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><p>最传统的网络请求是通过提交表单进行的，表单的提交、地址栏输入内容，都会导致界面的全部刷新。</p>
<p>而使用JS脚本发送HTTP请求，**<code>不会带来页面的刷新</code>**，我们可以向后台请求数据，拿到数据后渲染到界面上，会有页面局部更新的效果，所以用户体验非常好。</p>
<h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>请求方式有很多，一般使用以下4种</p>
<ol>
<li><p>GET</p>
<blockquote>
<p>该方式一般应用于 单纯获取数据 的业务，请求参数包含在URL内</p>
</blockquote>
</li>
<li><p>POST</p>
<blockquote>
<p>该方式一般应用于 向服务器提交数据 ，请求参数置于请求体当中</p>
</blockquote>
</li>
<li><p>PUT</p>
<blockquote>
<p>该方式一般应用于 更改服务器数据 的业务</p>
</blockquote>
</li>
<li><p>DELETE</p>
<blockquote>
<p>该方式一般应用于 删除服务器数据 的业务</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p><code>open()</code>用于创建请求（单纯创建，并不发送）</p>
<blockquote>
<p>注意：如果<code>open()</code>的<code>method</code>为<code>GET</code>，则<code>url</code>需要自带参数。</p>
<ul>
<li>get请求就是通过url进行的</li>
<li>参数格式<code>key=val</code>多个参数之间使用<code>&amp;</code>隔开</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>method</td>
<td>请求方式</td>
</tr>
<tr>
<td>url</td>
<td>请求地址</td>
</tr>
<tr>
<td>async</td>
<td>是否异步(默认为true)</td>
</tr>
</tbody></table>
<h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p><code>send(body)</code>用于发送请求</p>
<ul>
<li>若请求方式为<code>GET</code>，则不用为其传递参数(get请求在url中传参)。</li>
<li>若请求方式为<code>POST</code>,则要把参数传递到<code>send(body)</code>中</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>body</td>
<td>请求体(要发送的数据)（字符串类型）</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test?name&#x3D;Ashun&quot;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.open(&quot;POST&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">let body&#x3D;&#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">xhr.send(body);</span><br></pre></td></tr></table></figure>



<h5 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h5><p>用于设置请求头，一般我们会指定编码方式。</p>
<ul>
<li>请求方式为<code>POST</code>，需要设置请求头的编码方式，<code>GET</code>不用设置。</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>请求头的key（字符串类型）</td>
</tr>
<tr>
<td>vlaue</td>
<td>请求头的value（字符串类型）</td>
</tr>
</tbody></table>
<ul>
<li><p>当传递的参数为form表单形式的数据，则需要设置<code>Content-type:application/x-www-form-urlencoded</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(&quot;name&#x3D;Ashun&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>若传递的参数为json字符串，则需要设置<code>Content-type:application/json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:5500&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.send(JSON.stringify(&#123; name: &quot;Ashun&quot; &#125;));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders"></a>getAllResponseHeaders</h5><p>用于获取响应头，返回所有的响应头数据（字符串类型）。</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader"></a>getResponseHeader</h5><p>获取响应头中指定<code>header</code>的值，返回该响应头的数据（字符串类型）。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>响应头的key（字符串类型）</td>
</tr>
</tbody></table>
<h5 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h5><p>终止请求。</p>
<hr>
<h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p><code>HTTP</code>状态码，如<code>200/404</code>等等。</p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p><code>HTTP</code>状态文本（字符串），与状态码对应如：OK、NotFound…</p>
<table>
<thead>
<tr>
<th align="center">status</th>
<th align="center">statusText</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">NotFound</td>
</tr>
</tbody></table>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p><code>xhr</code>状态码，使用<code>XmlHttpRequest</code>时共有5种状态。</p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未初始化，尚未调用open()方法</td>
</tr>
<tr>
<td>1</td>
<td>初始化，调用了open()方法，未调用send()方法</td>
</tr>
<tr>
<td>2</td>
<td>发送，已经调用了send()方法，未接收到响应</td>
</tr>
<tr>
<td>3</td>
<td>接收，已经接收到部分响应数据</td>
</tr>
<tr>
<td>4</td>
<td>完成，已经接收到全部响应数据</td>
</tr>
</tbody></table>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><p>这是服务器返回的数据（字符串类型）</p>
<hr>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>以下回调函数需要我们手动配置，当达到对应的状态后自动回调</p>
<h5 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h5><p>当请求完毕后，会自动执行该函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(xhr.getAllResponseHeaders());</span><br><span class="line">  console.log(xhr.responseText);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h5><p>当请求产生错误时，会自动执行该函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(xhr.status);</span><br><span class="line">  console.log(&quot;请求失败&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>当xhr状态码改变时，自动回调。 可以结合xhr、HTTP状态码，对请求是否成功做出判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;请求结束，并且成功</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123; </span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">  &#125; else if (xhr.status &#x3D;&#x3D; 404) &#123;</span><br><span class="line">    console.log(&quot;请求失败&quot;);</span><br><span class="line">  &#125;	else if(xhr.status &#x3D;&#x3D; 500)&#123;</span><br><span class="line">    console.log(&quot;服务器内部错误&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p><code>FormData</code>是JavaScript的一个内置对象，当满足以下使用条件时，会使请求变得更加简便</p>
<ul>
<li>使用表单<code>form</code>发送请求</li>
<li>请求方式为<code>POST</code></li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li>实例化对象，并传入表单Dom<code>let formdata=new FormData(formDom)</code></li>
<li>将其置于请求体中<code>xhr.send(formdata)</code></li>
</ol>
<p>FormData对象，会自动将传入的表单Dom中的数据，转化为正确的形式（<code>key=val</code>多个参数使用<code>&amp;</code>隔开）。</p>
<p>通过使用步骤可知，使用FormData请求的方式必须为<code>POST</code>(请求参数置于请求体当中)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">      &lt;button type&#x3D;&quot;button&quot;&gt;Login&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let formDom &#x3D; document.querySelector(&quot;form&quot;);</span><br><span class="line">      let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">      let btn &#x3D; document.querySelector(&quot;button&quot;);</span><br><span class="line">      btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;如果请求的是同源服务器，那么可以省略掉协议、域名、端口</span><br><span class="line">        xhr.open(&quot;post&quot;, &quot;&#x2F;formdata0&quot;);</span><br><span class="line">        let formdata &#x3D; new FormData(formDom);</span><br><span class="line">        xhr.send(formdata);</span><br><span class="line">        xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          xhr.status &#x3D;&#x3D; 200 &amp;&amp; console.log(xhr.responseText);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(xhr.status);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>若不使用FormData，则我们需要做更多的操作</p>
<ul>
<li>收集表单元素的数据，并以正确格式拼接（<code>FormData</code>自动收集）</li>
<li>发送请求前，需要设置请求头（<code>FormData</code>不需要）</li>
</ul>
<hr>
<h4 id="请求-返回类型"><a href="#请求-返回类型" class="headerlink" title="请求/返回类型"></a>请求/返回类型</h4><p>页面向服务器提交数据、服务器返回给浏览器数据。在这两个过程中，若传递的是<code>引用类型数据</code>，则最终都需要转化为<code>JSON String</code>。</p>
<p><strong>页面向服务器提交数据</strong></p>
<p>向服务器提交数据，请求方式为<code>POST</code>，若发送的数据为引用类型，需要设置响应头信息<code>Content-Type:application/json</code>,且放入请求体中的数据必须是JSON字符串(<code>send(JSON.stringify(data))</code>)</p>
<p><strong>服务器返回给浏览器数据</strong></p>
<p>服务器可以直接返回页面 引用类型 数据，但是页面接收到的还是<code>JSON String</code>，需要将数据反序列化得到真正的数据。</p>
<p>发送请求</p>
<ul>
<li>若直接接收服务器返回的引用类型数据，则为JSON String</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;&#x2F;test&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);</span><br><span class="line">xhr.send(JSON.stringify(&#123; name: &quot;Ashun&quot; &#125;));</span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  console.log(typeof xhr.responseText, xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;结果： string &#123; &quot;name&quot;: &quot;Ashun&quot; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以判断响应头信息，返回对应的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      xhr.onload &#x3D; function () &#123;</span><br><span class="line">        let isJson &#x3D; xhr</span><br><span class="line">          .getResponseHeader(&quot;Content-Type&quot;)</span><br><span class="line">          .includes(&quot;application&#x2F;json&quot;);</span><br><span class="line">        isJson</span><br><span class="line">          ? console.log(JSON.parse(xhr.responseText))</span><br><span class="line">          : console.log(xhr.responseText);</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>

<p>服务器响应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.post(&quot;&#x2F;test&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  let postRes &#x3D; &quot;&quot;;</span><br><span class="line">  req.on(&quot;data&quot;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">    postRes +&#x3D; chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    res.send(JSON.parse(postRes));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h3><p>​    上面我们了解了<code>Ajax</code>的基本使用，现在我们可以封装一个<code>Ajax</code>请求处理函数，让请求更加的简便。</p>
<p><strong>需求</strong></p>
<p>每次请求的过程，都需要经历以下步骤</p>
<ul>
<li>创建xhr对象</li>
<li>初始化请求</li>
<li>设置请求头(post)</li>
<li>发送请求</li>
<li>请求完成后的处理</li>
</ul>
<p>我们可以将上述步骤抽离出来，把需要改变的部分暴露出去，让外部来决定，即：请求方式、请求地址、是否设置请求头、传递的参数、请求完毕后的具体操作。</p>
<p>还要根据服务器返回不同类型的结果进行判断，正确提交给外部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(preset) &#123;</span><br><span class="line">  let options &#x3D; Object.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;get&quot;,</span><br><span class="line">      url: &quot;&quot;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        [&quot;Content-Type&quot;]: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      success: (result, xhr) &#x3D;&gt; console.log(result),</span><br><span class="line">      error: (xhr) &#x3D;&gt; console.log(xhr.status),</span><br><span class="line">    &#125;,</span><br><span class="line">    preset</span><br><span class="line">  );</span><br><span class="line">  &#x2F;&#x2F;数据拼接</span><br><span class="line">  let queryStr &#x3D; Object.entries(options.data)</span><br><span class="line">    .map(([key, val]) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;val&#125;&#96;)</span><br><span class="line">    .join(&quot;&amp;&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;请求处理</span><br><span class="line">  const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  if (options.type &#x3D;&#x3D; &quot;get&quot;) &#123;</span><br><span class="line">    xhr.open(options.type, &#96;$&#123;options.url&#125;?$&#123;queryStr&#125;&#96;);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">  if (options.type &#x3D;&#x3D; &quot;post&quot;) &#123;</span><br><span class="line">    xhr.open(options.type, options.url);</span><br><span class="line">    &#x2F;&#x2F;设置header</span><br><span class="line">    Object.entries(options.header).forEach(([prop, val]) &#x3D;&gt; &#123;</span><br><span class="line">      xhr.setRequestHeader(prop, val);</span><br><span class="line">    &#125;);</span><br><span class="line">    let contentType &#x3D; options.header[&quot;Content-Type&quot;];</span><br><span class="line">    &#x2F;&#x2F;根据请求头信息，判断发送数据的形式</span><br><span class="line">    contentType.includes(&quot;json&quot;)</span><br><span class="line">      ? xhr.send(JSON.stringify(options.data))</span><br><span class="line">      : xhr.send(queryStr);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据响应头信息，返回对应类型的数据</span><br><span class="line">    let isJson &#x3D; xhr.getResponseHeader(&quot;Content-Type&quot;).includes(&quot;json&quot;);</span><br><span class="line">    let result &#x3D; isJson ? JSON.parse(xhr.responseText) : xhr.responseText;</span><br><span class="line">    &#x2F;&#x2F;根据HTTP状态码，执行不同的callback</span><br><span class="line">    xhr.status &#x3D;&#x3D; 200 ? options.success(result, xhr) : options.error(xhr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  type: &quot;post&quot;,</span><br><span class="line">  url: &quot;test&quot;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    [&quot;Content-Type&quot;]: &quot;application&#x2F;json&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &quot;Ashun&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: (res, xhr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res, xhr.status);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><p><code>fetch(url,&#123;options&#125;)</code>是JS升级后提供的更简便的网络请求的操作方法，内部使用Promise来完成异步请求。</p>
<ul>
<li>response.json()处理为JSON对象，将后台返回的JSON字符串处理为JSON对象</li>
<li>response.text()处理为TEXT类型数据</li>
<li>response.blog()处理为Blog二进制数据</li>
</ul>
<h4 id="请示步骤"><a href="#请示步骤" class="headerlink" title="请示步骤"></a>请示步骤</h4><p>使用fetch方法发送异步请求需要分以下两步操作</p>
<h5 id="响应头解析"><a href="#响应头解析" class="headerlink" title="响应头解析"></a>响应头解析</h5><p>第一步对服务器返回的响应头进行解析，会接到Response类创建的对象实例，里面包含以下属性。</p>
<ul>
<li><code>status</code>:HTTP状态码</li>
<li><code>ok</code>:状态码为200-299 时为true的布尔值</li>
</ul>
<h5 id="响应内容解析"><a href="#响应内容解析" class="headerlink" title="响应内容解析"></a>响应内容解析</h5><p>第二步对返回的 保存在response.body 中的响应结果进行解析，支持了以下几种方式对结果进行解析，且以下方法都默认返回Promise</p>
<ul>
<li>response.json()处理为JSON对象，将后台返回的JSON字符串处理为JSON对象</li>
<li>response.text()处理为TEXT类型数据</li>
<li>response.blog()处理为Blog二进制数据</li>
</ul>
<blockquote>
<p>以上方法不能同时使用，因为使用一个方法后数据已经被处理，其他方法就不可以操作了</p>
</blockquote>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>下面来体验使用fetch发送请求</p>
<p><strong>后台服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&quot;&#x2F;test&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.send(&#123; name: &quot;阿顺&quot; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>发送请求</strong></p>
<p>以下为发送get请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch(&quot;&#x2F;test&quot;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">          return result.json();</span><br><span class="line">        &#125;)</span><br><span class="line">        .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">        .catch((err) &#x3D;&gt; console.log(err));</span><br></pre></td></tr></table></figure>



<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>发送POST请求需要设置请求头Request header</p>
<p><strong>发送请求</strong></p>
<ul>
<li>发送的JSON类型需要设置请求头为 <code>application/json;charset=utf-8</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function post() &#123;</span><br><span class="line">  let response = await fetch(&quot;/test&quot;, &#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: JSON.stringify(&#123; name: &quot;阿顺&quot;, title: &quot;Ashuntefannao&quot; &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">  if (response.ok) &#123;</span><br><span class="line">    let result = await response.json();</span><br><span class="line">    console.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后台响应</strong></p>
<p>将数据原样返回</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">app.post(&quot;/test&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  let postRes = &quot;&quot;;</span><br><span class="line">  req.on(&quot;data&quot;, (chunk) =&gt; &#123;</span><br><span class="line">    postRes += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">    res.send(JSON.parse(postRes));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>原型与继承</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="原型与继承"><a href="#原型与继承" class="headerlink" title="原型与继承"></a>原型与继承</h2><h3 id="原型基础"><a href="#原型基础" class="headerlink" title="原型基础"></a>原型基础</h3><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>​    我们知道，在Javascript中，任何一个种类其实都是对象。我们可以访问该对象的属性和方法，但是如果对象本身没有某属性、方法，就会从对象的原型上去查找，如果对象的原型上存在你要使用的属性、方法，则将会使用原型上的对应属性和方法。</p>
<ul>
<li><p>可以将原型理解为对象的父亲，对象从原型对象继承来属性、方法</p>
</li>
<li><p>所有函数的原型默认是 <code>Object</code>的实例，所以可以使用<code>toString/toValues/isPrototypeOf</code> 等方法的原因</p>
</li>
<li><p>使用原型对象为多个对象共享属性或方法</p>
</li>
<li><p>如果对象本身不存在属性或方法才到原型上查找，若对象本身和原型具有同名属性、方法，则会使用对象本身的属性、方法。</p>
</li>
<li><p>使用原型可以解决，通过构建函数创建对象时复制多个函数造成的内存占用问题</p>
</li>
<li><p>原型对象<code>prototype</code>默认包含 <code>constructor</code> 属性，指向构造函数</p>
</li>
<li><p>对象具有 <code>__proto__</code> 属性，指向它<code>构造函数的原型对象prototype</code></p>
</li>
<li><p>构造函数的<code>prototype</code>是用来让实例对象继承的。</p>
</li>
<li><p><code>prototype</code>是<code>构造器/函数/class</code>天生具有的属性<br>JavaScript内置的构造器有：Object,Number,Boolean,String,Array,RegExp,Date,Function,Error,Math,JSON等。</p>
<p>当然，普通的函数也可以是构造函数、工厂函数。所以普通函数也具有prototype，让实例化对象来继承。</p>
</li>
<li><p>原型链的顶点是<code>Object.prototype</code>,所有对象都继承于该原型。</p>
</li>
</ul>
<p>下例就是使用数组原型上的 <code>concat</code> 方法完成的连接操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = [&quot;a&quot;];</span><br><span class="line">console.log(as.concat(&quot;b&quot;));	//[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">console.log(as.concat(&quot;c&quot;,[&quot;d&quot;,&quot;e&quot;],[[[[&quot;f&quot;]]]]));	//[&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,[&quot;f&quot;]]</span><br><span class="line">console.log(as);	//[&quot;a&quot;]</span><br></pre></td></tr></table></figure>

<p>默认情况下创建的对象都有：继承而来的构造函数原型</p>
<img src="原型与继承.assets/prototype_1.png" alt="image-20210327152151367" style="zoom:80%;" />

<ul>
<li>由于a本身是由Objec构造函数创建的，所以a继承的是Object.prototype</li>
<li><code>a.constructor</code>和<code>a.__proto__.constructor</code>其实是一样的。</li>
<li>因为a本身没有constructor属性，所以访问的就是原型上的constructor。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; name: &quot;阿顺特烦恼&quot; &#125;;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(a.constructor);&#x2F;&#x2F; ƒ Object() &#123;&#125;</span><br><span class="line">console.log(a.__proto__.constructor);&#x2F;&#x2F; ƒ Object() &#123;&#125;</span><br><span class="line">console.log(a.__proto__ &#x3D;&#x3D; Object.prototype);	&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<p>我们也可以创建一个极简对象（纯数据字典对象）没有原型（原型为null)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: 3 &#125;;</span><br><span class="line">console.log(obj.hasOwnProperty(&quot;name&quot;));</span><br><span class="line"></span><br><span class="line">let as &#x3D; Object.create(null, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &quot;阿顺&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(as.hasOwnProperty(&quot;name&quot;)); &#x2F;&#x2F;Error:hasOwnProperty not undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Object.keys是静态方法，不是原型方法所以是可以使用的,但也不会返回正常结果，因为该方法也依赖于原型上的迭代接口。</span><br><span class="line">console.log(Object.keys(as));&#x2F;&#x2F;[]</span><br></pre></td></tr></table></figure>



<p>函数具有两个原型对象：<code>prototype</code>、<code>__proto__</code></p>
<ul>
<li>之前说过，只有函数具有prototype，用于让实例继承。</li>
<li>但是在JS中，任何类型其实都是对象，当把函数看作对象时，其也就具有<code>__proto__</code>,用来访问自身的构造函数的原型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.__proto__.view &#x3D; function() &#123;</span><br><span class="line">  console.log(&quot;User MakeFunction view method&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">User.view();</span><br><span class="line"></span><br><span class="line">User.prototype.show &#x3D; function() &#123;</span><br><span class="line">  console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">let as &#x3D; new User();</span><br><span class="line">as.show();</span><br><span class="line">console.log(User.prototype &#x3D;&#x3D; as.__proto__);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">console.log(User.__proto__ &#x3D;&#x3D; User.constructor.prototype);</span><br><span class="line">console.log(User.constructor.prototype &#x3D;&#x3D; Function.prototype);</span><br><span class="line">console.log(User.__proto__.__proto__ &#x3D;&#x3D; Object.prototype);</span><br><span class="line">console.log(User.prototype.__proto__ &#x3D;&#x3D; Object.prototype);</span><br><span class="line">console.log(Object.__proto__.__proto__ &#x3D;&#x3D; Object.prototype);</span><br><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D; null);</span><br></pre></td></tr></table></figure>

<p>是不是感觉<code>Object.__proto__.__proto__ == Object.prototype</code>很难理解？我们可以进行拆解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.__proto__.__proto__ &#x3D;&#x3D; Object.prototype);</span><br><span class="line">console.log(Object.__proto__ &#x3D;&#x3D; Function.prototype);</span><br><span class="line">console.log(Function.prototype.__proto__ &#x3D;&#x3D; Object.prototype);</span><br></pre></td></tr></table></figure>

<p>下面是原型关系分析，与方法继承的示例</p>
<ul>
<li>实例对象，只有一个<code>__proto__</code>接口，用于访问构造函数的<code>prototype</code></li>
<li>而<code>函数/构造函数</code>都有两个原型接口：<code>prototype</code>用于让实例对象继承、<code>__proto__</code>用于让自身继承构造自己的构造函数的<code>prototype</code></li>
</ul>
<img src="原型与继承.assets/prototype_2.png" alt="prototype_2" style="zoom: 60%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; new Object();</span><br><span class="line">as.name &#x3D; &quot;阿顺&quot;;</span><br><span class="line">Object.prototype.show &#x3D; function() &#123;</span><br><span class="line">  console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">as.show();</span><br><span class="line"></span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">let shun &#x3D; new User();</span><br><span class="line">shun.show();</span><br><span class="line">User.show();</span><br></pre></td></tr></table></figure>



<p>下面是使用构造函数创建对象的原型体现</p>
<ul>
<li>构造函数拥有原型</li>
<li>创建对象时构造函数把原型赋予对象</li>
</ul>
<img src="原型与继承.assets/prototype_3.png" alt="prototype_3" style="zoom:70%;" />



<p><code>constructor</code>存在于<code>prototype</code>原型中，用于指向构建函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">let as = new User();</span><br><span class="line">console.log(as.__proto__ == User.prototype);</span><br><span class="line">console.log(as.__proto__.constructor == User);</span><br><span class="line">console.log(as.constructor == User);</span><br></pre></td></tr></table></figure>

<p>使用对象的 <code>constructor</code> 创建对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createByObject(obj, ...args) &#123;</span><br><span class="line">	const constructor = obj.__proto__.constructor;</span><br><span class="line">	// const constructor = Object.getPrototypeOf(obj).constructor;</span><br><span class="line">	return new constructor(...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let as = new User(&quot;阿顺&quot;, 18);</span><br><span class="line">let zs = createByObject(as, &quot;张三&quot;, 7);</span><br><span class="line">console.log(zs);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>​    多个原型对象之间的继承，形成的多层级关系，可以抽象为一个链条，即原型链。</p>
<p>​    从之前的图解中也能够看出这种关系。</p>
<img src="原型与继承.assets/prototype_4.png" alt="prototype_4" style="zoom:60%;" />





<hr>
<h4 id="获取-设置原型"><a href="#获取-设置原型" class="headerlink" title="获取\设置原型"></a>获取\设置原型</h4><h5 id="getprototypeOf"><a href="#getprototypeOf" class="headerlink" title="getprototypeOf"></a>getprototypeOf</h5><ul>
<li><p>使用<code>Object.getPrototypeOf(obj)</code>，获取<code>obj</code>的原型</p>
<ul>
<li>等同于<code>obj.__proto__</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; &#123;&#125;;</span><br><span class="line">console.log(Object.getPrototypeOf(a) &#x3D;&#x3D; Object.prototype);</span><br><span class="line">console.log(Object.getPrototypeOf(a) &#x3D;&#x3D; a.__proto__);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h5><ul>
<li><p>使用<code>Object.setPrototypeOf(sub,sup)</code>，将<code>sub</code>的父级原型对象设置为<code>sup</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;&#125;;</span><br><span class="line">let b &#x3D; &#123;</span><br><span class="line">	show() &#123;</span><br><span class="line">		return &quot;Ashuntefannao&quot;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Object.setPrototypeOf(a, b);</span><br><span class="line">console.log(Object.getPrototypeOf(a));	&#x2F;&#x2F;&#123;show: ƒ&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例中继承关系为 user=&gt;as=&gt;shun。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;&#125;;</span><br><span class="line">let as &#x3D; &#123; name: &quot;Ashun&quot; &#125;;</span><br><span class="line">let shun &#x3D; &#123; type: &quot;Controller&quot; &#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(user, as);</span><br><span class="line">Object.setPrototypeOf(as, shun);</span><br><span class="line"></span><br><span class="line">console.log(user.type);</span><br><span class="line">console.log(Object.getPrototypeOf(as));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h5><p>使用<code>Object.create(sup,&#123;desc…&#125;)</code>在创建对象时设置新对象的父级原型。</p>
<ul>
<li>参数1：设置新对象的父级原型</li>
<li>参数2：为新对象配置属性，以属性描述的形式，相当于<code>Object.defineProperties</code>的形式。</li>
</ul>
<p>只设置原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let as &#x3D; Object.create(user);</span><br><span class="line">as.name &#x3D; &quot;阿顺&quot;;</span><br><span class="line">console.log(as.show());</span><br></pre></td></tr></table></figure>

<p>设置原型并赋予新对象属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sup &#x3D; &#123;</span><br><span class="line">	name: &quot;Ashun&quot;,</span><br><span class="line">	type: &quot;Controller&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">let obj &#x3D; Object.create(sup, &#123;</span><br><span class="line">		show: &#123;</span><br><span class="line">				value: function () &#123;</span><br><span class="line">					console.log(this.name);</span><br><span class="line">					console.log(Object.getPrototypeOf(this).name);</span><br><span class="line">				&#125;,</span><br><span class="line">				writable: false,</span><br><span class="line">				enumerable: true,</span><br><span class="line">		&#125;,</span><br><span class="line">		type:&#123;</span><br><span class="line">			value:&quot;VIP&quot;,</span><br><span class="line">			configurable:false</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.show();	&#x2F;&#x2F;Ashun Ashun</span><br><span class="line">console.log(obj.type) &#x2F;&#x2F;VIP</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型检测"><a href="#原型检测" class="headerlink" title="原型检测"></a>原型检测</h4><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>instanceof 检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">function B() &#123;&#125;</span><br><span class="line">function C() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let c &#x3D; new C();</span><br><span class="line"></span><br><span class="line">B.prototype &#x3D; c;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line"></span><br><span class="line">A.prototype &#x3D; b;</span><br><span class="line"></span><br><span class="line">let a &#x3D; new A();</span><br><span class="line"></span><br><span class="line">console.log(a instanceof A);</span><br><span class="line">console.log(a instanceof B);</span><br><span class="line">console.log(a instanceof C);</span><br><span class="line">console.log(b instanceof B);</span><br><span class="line">console.log(b instanceof C);</span><br></pre></td></tr></table></figure>

<h5 id="isPrototypeof"><a href="#isPrototypeof" class="headerlink" title="isPrototypeof"></a>isPrototypeof</h5><p>使用<code>isPrototypeOf</code>检测一个对象是否是另一个对象的原型链中</p>
<ul>
<li><code>a.isPrototypeOf(b)</code>检测a对象是否在b的原型链上</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const a = &#123;&#125;;</span><br><span class="line">const b = &#123;&#125;;</span><br><span class="line">const c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(a, b);</span><br><span class="line">Object.setPrototypeOf(b, c);</span><br><span class="line"></span><br><span class="line">console.log(b.isPrototypeOf(a)); //true</span><br><span class="line">console.log(c.isPrototypeOf(a)); //true</span><br><span class="line">console.log(c.isPrototypeOf(b)); //true</span><br><span class="line">console.log(Object.prototype.isPrototypeOf(&#123;&#125;)); //true</span><br><span class="line"></span><br><span class="line">let num = new Number(1);</span><br><span class="line">console.log(Object.prototype.isPrototypeOf(num));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h4><p>使用<code>in</code> 检测<code>原型链</code>上是否存在属性，使用 <code>hasOwnProperty</code> 只检测当前对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let a = &#123; url: &quot;Ashuntefannao&quot; &#125;;</span><br><span class="line">let b = &#123; name: &quot;阿顺&quot; &#125;;</span><br><span class="line">Object.setPrototypeOf(a, b);</span><br><span class="line">console.log(&quot;name&quot; in a);</span><br><span class="line">console.log(a.hasOwnProperty(&quot;name&quot;));</span><br><span class="line">console.log(a.hasOwnProperty(&quot;url&quot;));</span><br></pre></td></tr></table></figure>

<p>使用 <code>for/in</code> 也会遍历<code>原型链</code>上的属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123; name: &quot;阿顺&quot; &#125;;</span><br><span class="line">let shun = Object.create(as, &#123;</span><br><span class="line">  url: &#123;</span><br><span class="line">    value: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">for (const key in shun) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasOwnProperty</code> 方法判断对象是否存在属性，而<strong>不会查找原型</strong>。所以如果只想遍历对象属性使用以下代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123; name: &quot;阿顺&quot; &#125;;</span><br><span class="line">let shun = Object.create(as, &#123;</span><br><span class="line">  url: &#123;</span><br><span class="line">    value: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">for (const key in shun) &#123;</span><br><span class="line">  if (xj.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前所说的Object内置迭代器：<code>Object.keys()、Object.values()、Object.entries()</code>,它们只能够获得<strong>自身的、可枚举</strong>的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">		Object.defineProperty(this, &quot;site&quot;, &#123;</span><br><span class="line">			value: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">			enumerable: false,</span><br><span class="line">		&#125;);</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show &#x3D; function () &#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">let as &#x3D; new User(&quot;阿顺&quot;);</span><br><span class="line">console.log(Object.keys(as));&#x2F;&#x2F;[&quot;name&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="借用原型"><a href="#借用原型" class="headerlink" title="借用原型"></a>借用原型</h4><p>使用 <code>call</code> 或 <code>apply</code> 可以借用其他原型方法完成功能。</p>
<p>下面的shun对象不能使用<code>max</code>方法，但可以借用 as 对象的原型方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">	data: [1, 2, 3, 4, 5],</span><br><span class="line">&#125;;</span><br><span class="line">Object.setPrototypeOf(as, &#123;</span><br><span class="line">		max: function (data) &#123;</span><br><span class="line">		return data.sort((a, b) =&gt; b - a)[0];</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(as.max(as.data));</span><br><span class="line"></span><br><span class="line">let shun = &#123;</span><br><span class="line">	lessons: &#123; js: 100, php: 78, node: 78, linux: 125 &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(as.__proto__.max.call(as, Object.values(shun.lessons)));</span><br></pre></td></tr></table></figure>

<p>也可使用系统自带的 <code>Math.max</code> 。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  data: [1, 2, 3, 4, 5]</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Math.max.apply(null, Object.values(as.data)));</span><br><span class="line">console.log(Math.max.apply(null, as.data));</span><br><span class="line"></span><br><span class="line">let shun = &#123;</span><br><span class="line">  lessons: &#123; js: 100, php: 78, node: 78, linux: 125 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Math.max.apply(shun, Object.values(.lessons)));</span><br></pre></td></tr></table></figure>

<p>下面是获取设置了 <code>class</code> 属性的按钮，但<code>NodeList类数组</code>不能直接使用数组的<code>filter</code> 等方法，但借用数组的原型方法就可以操作了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button class=&quot;red&quot;&gt;阿顺&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;Ashun&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">  btns = Array.prototype.filter.call(btns, item =&gt; &#123;</span><br><span class="line">    return item.hasAttribute(&quot;class&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><code>this</code> 不受原型继承影响，<code>this</code> 指向调用属性时使用的对象。</p>
<ul>
<li>谁调用，<code>this</code>指向谁</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let shun = &#123;</span><br><span class="line">  name: &quot;阿顺特烦恼&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let as = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">shun.__proto__ = as;</span><br><span class="line">console.log(shun.show()); //阿顺特烦恼</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        function Fn() &#123;</span><br><span class="line">          this.x &#x3D; 100;</span><br><span class="line">          this.y &#x3D; 200;</span><br><span class="line">          this.getX &#x3D; function () &#123;</span><br><span class="line">            console.log(this.x);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Fn.prototype.getX &#x3D; function () &#123;</span><br><span class="line">          console.log(this.x);</span><br><span class="line">        &#125;;</span><br><span class="line">        Fn.prototype.getY &#x3D; function () &#123;</span><br><span class="line">          console.log(this.y);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        var f1 &#x3D; new Fn();</span><br><span class="line">        var f2 &#x3D; new Fn();</span><br><span class="line">        console.log(f1.getX &#x3D;&#x3D;&#x3D; f2.getX); &#x2F;&#x2F;false</span><br><span class="line">        console.log(f1.getY &#x3D;&#x3D;&#x3D; f2.getY); &#x2F;&#x2F;true</span><br><span class="line">        console.log(f1.__proto__.getY &#x3D;&#x3D;&#x3D; Fn.prototype.getY); &#x2F;&#x2F;true</span><br><span class="line">        console.log(f1.__proto__.getX &#x3D;&#x3D;&#x3D; f2.getX); &#x2F;&#x2F;false</span><br><span class="line">        console.log(f1.__proto__.getX &#x3D;&#x3D;&#x3D; Fn.prototype.getX); &#x2F;&#x2F;true</span><br><span class="line">        console.log(f1.constructor); &#x2F;&#x2F;Fn</span><br><span class="line">        console.log(Fn.prototype.__proto__.constructor); &#x2F;&#x2F;Object</span><br><span class="line">        f1.getX(); &#x2F;&#x2F;100	(使用其本身的getX，this&#x3D;》f1)</span><br><span class="line">        f1.__proto__.getX(); &#x2F;&#x2F;undefined	(通过原型调用，this&#x3D;》f1.__proto__)</span><br><span class="line">        f2.getY(); &#x2F;&#x2F;200	(虽然使用的是原型上的方法，但是通过f2调用，this&#x3D;》f2)</span><br><span class="line">        Fn.prototype.getY(); &#x2F;&#x2F;undefined	(通过原型调用，this&#x3D;》f1.__proto__)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	function fun()&#123;</span><br><span class="line">		this.a &#x3D; 0;</span><br><span class="line">		this.b &#x3D; function()&#123;</span><br><span class="line">			console.log(this.a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fun.prototype &#x3D; &#123;</span><br><span class="line">		b: function()&#123;</span><br><span class="line">			this.a &#x3D; 20;</span><br><span class="line">			console.log(this.a);</span><br><span class="line">		&#125;,</span><br><span class="line">		c: function()&#123;</span><br><span class="line">			this.a &#x3D; 30;</span><br><span class="line">			console.log(this.a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	var my_fun &#x3D; new fun();</span><br><span class="line">	my_fun.b();	&#x2F;&#x2F;私有方法	this&#x3D;&gt;my_fun</span><br><span class="line">	console.log(my_fun.a);</span><br><span class="line">	my_fun.c();	&#x2F;&#x2F;公有方法	this&#x3D;&gt;my_fun this.a &#x3D; 30（将私有属性a修改为30）</span><br><span class="line">	console.log(my_fun.a);</span><br><span class="line">	</span><br><span class="line">	var my_fun2 &#x3D; new fun();</span><br><span class="line">	console.log(my_fun2.a);</span><br><span class="line">	my_fun2.__proto__.c();	&#x2F;&#x2F;this&#x3D;&gt;my_fun2.__proto__ 在原型对象上增加了一个a:30</span><br><span class="line">	console.log(my_fun2.a);</span><br><span class="line">	console.log(my_fun2.__proto__.a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;0,0,30,30,0,30,0,30</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><h5 id="引用属性"><a href="#引用属性" class="headerlink" title="引用属性"></a>引用属性</h5><p>原型中保存引用类型属性会造成对象共享属性，所以一般只会在原型中定义方法。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype = &#123;</span><br><span class="line">  lessons: [&quot;JS&quot;, &quot;VUE&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">const as = new User();</span><br><span class="line">const shun = new User();</span><br><span class="line"></span><br><span class="line">as.lessons.push(&quot;CSS&quot;);</span><br><span class="line"></span><br><span class="line">console.log(as.lessons); //[&quot;JS&quot;, &quot;VUE&quot;, &quot;CSS&quot;]</span><br><span class="line">console.log(shun.lessons); //[&quot;JS&quot;, &quot;VUE&quot;, &quot;CSS&quot;]</span><br></pre></td></tr></table></figure>

<p>普通函数的原型默认只有一个<code>constructor</code>属性，用于指向自身，这样在实例化后，就能让实例访问自身的构造函数。</p>
<img src="原型与继承.assets/prototype_5.png" alt="prototype_5" style="zoom:90%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">console.log(User.prototype);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="更改原型"><a href="#更改原型" class="headerlink" title="更改原型"></a>更改原型</h5><ul>
<li><code>自定义</code>构造函数的原型<code>可以手动更改</code></li>
<li><code>系统内置</code>构造函数的原型:<code>只能读、不能改</code></li>
</ul>
<p>下例是手动更改自定义构造函数的原型，以下代码直接设置了构造函数的原型将造成 <code>constructor</code> 丢失</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype &#x3D; &#123;</span><br><span class="line">	show() &#123;</span><br><span class="line">		return &#96;外部更改了默认的prototype&#96;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(User.prototype); &#x2F;&#x2F; &#123;show: ƒ&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是要保证原型中的 <code>constructor</code>指向构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype &#x3D; &#123;</span><br><span class="line">	constructor:User,</span><br><span class="line">	show() &#123;</span><br><span class="line">		return &#96;外部更改了默认的prototype&#96;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(User.prototype); &#x2F;&#x2F; &#123;constructor: ƒ, show: ƒ&#125;</span><br></pre></td></tr></table></figure>

<p>实例对象的原型引用构造函数的原型对象，是在创建对象时确定的，当构造函数原型对象改变时会影响后面创建的实例对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype.name = &quot;Ashun&quot;;</span><br><span class="line">const obj1 = new User();</span><br><span class="line">console.log(obj1.name); //Ashun</span><br><span class="line"></span><br><span class="line">User.prototype = &#123;</span><br><span class="line">	constructor:User,</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">const obj2 = new User();</span><br><span class="line">console.dir(obj2.name); //阿顺</span><br></pre></td></tr></table></figure>



<p><code>系统内置</code>构造函数的原型:为只读属性，外部不可更改，严格模式下会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype &#x3D; &#123;</span><br><span class="line">	show() &#123;</span><br><span class="line">		return &#96;外部更改了默认的prototype&#96;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(String.prototype);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">String.prototype &#x3D; &#123;</span><br><span class="line">	show() &#123;</span><br><span class="line">		return &#96;外部更改了默认的prototype&#96;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型管理"><a href="#原型管理" class="headerlink" title="原型管理"></a>原型管理</h4><p>通过前介绍我们知道可以使用多种方式设置原型，下面是按时间顺序的排列</p>
<ol>
<li><code>prototype</code> 构造函数的原型属性</li>
<li><code>Object.create</code> 创建对象时指定原型</li>
<li><code>__proto__</code> 声明自定义的<code>非标准属性</code>设置原型，解决之前通过 <code>Object.create</code> 定义原型，而没提供获取方法</li>
<li><code>Object.setPrototypeOf</code> 设置对象原型</li>
</ol>
<p>以上几种方式都可以管理原型，一般我使用 <code>prototype</code> 更改自定义构造函数原型，使用  <code>Object.setPrototypeOf</code>  设置对象原型。</p>
<p>由于<code>__proto__</code>是一个非标准属性，所以使用<code>Object.getPrototypeOf</code>，获取对象原型。</p>
<hr>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="使用优化"><a href="#使用优化" class="headerlink" title="使用优化"></a>使用优化</h4><p>使用构造函数会产生 <code>函数复制</code> 即 <code>函数不能共享</code> 的问题造成内存占用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.get = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let zs = new User(&quot;张三&quot;);</span><br><span class="line">let lisi = new User(&quot;李四&quot;);</span><br><span class="line">console.log(zs.get == lisi.get); //false</span><br></pre></td></tr></table></figure>

<p>将方法定义在原型上让对象共享，解决通过构造函数创建对象时函数复制的内存占用问题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.get = function() &#123;</span><br><span class="line">  return &quot;阿顺特烦恼&quot; + this.name;</span><br><span class="line">&#125;;</span><br><span class="line">let lisi = new User(&quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">let wangwu = new User(&quot;王五&quot;);</span><br><span class="line">console.log(lisi.get == wangwu.get); //true</span><br><span class="line"></span><br><span class="line">//通过修改原型方法会影响所有对象调用，因为方法是共用的</span><br><span class="line">lisi.__proto__.get = function() &#123;</span><br><span class="line">  return &quot;Ashun&quot; + this.name;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(lisi.get());</span><br><span class="line">console.log(wangwu.get());</span><br></pre></td></tr></table></figure>

<p>下面演示使用原型让多个实例共享属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.show = () =&gt; &#123;</span><br><span class="line">  	return `你在$&#123;this.site&#125;的姓名:$&#123;this.name&#125;，年龄:$&#123;this.age&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.site = &#x27;-阿顺特烦恼-&#x27;;</span><br><span class="line">let lisi = new User(&#x27;李四&#x27;, 12); </span><br><span class="line">let xiaoming = new User(&#x27;小明&#x27;, 32);</span><br><span class="line"></span><br><span class="line">console.log(lisi.show()); //你在-阿顺特烦恼-的姓名:李四，年龄:12</span><br><span class="line">console.log(xiaoming.show()); //你在-阿顺特烦恼-的姓名:小明，年龄:32</span><br></pre></td></tr></table></figure>

<p>使用<code>Object.assign</code>一次设置原型方法来复用，后面会使用这个功能实现<code>Mixin模式</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Object.assign(User.prototype, &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  getAge() &#123;</span><br><span class="line">      return this.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">let lisi = new User(&#x27;李四&#x27;, 12);</span><br><span class="line">let xiaoming = new User(&#x27;小明&#x27;, 32);</span><br><span class="line">console.log(lisi.getName()); //李四</span><br><span class="line">console.log(lisi.__proto__)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><p>当对象自身不存在将要使用的属性时，JS会从原型上获取这就是继承在JavaScript中的实现。</p>
<h4 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h4><p>下面使用<code>Object.create</code> 创建对象并指定原型，做为<code>Admin、Member</code>的原型对象来实现继承。</p>
<img src="原型与继承.assets/prototype_6.png" alt="prototype_6" style="zoom:80%;" />

<p>使用<code>Object.create</code> 创建一个对象，虽然没有赋予任何属性，但是为这个空对象指定了原型，所以能够实现原型的继承。</p>
<ul>
<li>但是会导致<code>constructor</code>丢失</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype.getUserName = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line">Admin.prototype.role = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Member() &#123;&#125;</span><br><span class="line">Member.prototype = Object.create(User.prototype);</span><br><span class="line">Member.prototype.email = function() &#123;&#125;;</span><br><span class="line">console.log(new Admin());</span><br><span class="line">console.log(new Member());</span><br></pre></td></tr></table></figure>

<p>不能使用以下方式操作（直接赋值），因为这样会改变User的原型方法，这不是继承，这是改变原型。相当于Admin的原型完全引用了User的原型对象，二者是同一个内存地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype.getUserName = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line">Admin.prototype = User.prototype;</span><br><span class="line">Admin.prototype.role = function() &#123;&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>有多种方式通过构造函数创建对象</p>
<ul>
<li>直接new构造函数</li>
<li>通过原型找到<code>constructor</code>,然后再new实例化</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Admin() &#123;&#125;</span><br><span class="line">console.log(Admin == Admin.prototype.constructor); //true</span><br><span class="line"></span><br><span class="line">let as = new Admin.prototype.constructor();</span><br><span class="line">console.log(as);</span><br><span class="line"></span><br><span class="line">let shun = new Admin();</span><br><span class="line">console.log(shun);</span><br></pre></td></tr></table></figure>

<p>因为有时根据得到的对象获取构造函数，然后再创建新对象，所以需要保证构造函数存在，但如果直接设置 <code>Admin.prototype</code> ，却没有为其保留<code>constructor</code>属性，会造成默认的<code>constructor</code>丢失，所以需要再次设置<code>constructor</code>值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line">Admin.prototype.role = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let as = new Admin();</span><br><span class="line">console.log(as.constructor); //constructor丢失，返回User构造函数</span><br><span class="line"></span><br><span class="line">Admin.prototype.constructor = Admin;</span><br><span class="line"></span><br><span class="line">let shun = new Admin();</span><br><span class="line">console.log(shun.constructor); //正确返回Admin构造函数</span><br><span class="line"></span><br><span class="line">//现在可以通过对象获取构造函数来创建新对象了</span><br><span class="line">console.log(new shun.constructor());</span><br></pre></td></tr></table></figure>

<p>使用<code>Object.defineProperty</code>设置属性特征描述，来禁止遍历constructor属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">function Admin(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Admin.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  value: Admin,</span><br><span class="line">  enumerable: false //禁止遍历</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">for (const key in as) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全重写构建函数原型，只对后面创建的实例对象有效</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">const lisi = new User();</span><br><span class="line">User.prototype = &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    return &quot;prototype show&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const wangwu = new User();</span><br><span class="line">console.log(wangwu.show());</span><br><span class="line"></span><br><span class="line">console.log(lisi.show()); // lisi.show is not a function</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>下而展示的是子类需要重写父类方法的技巧。</p>
<ul>
<li>在子类构造函数的原型上压入 与 父类构造函数原型上的 同名方法</li>
<li>当对象本身没有使用的方法时，会<code>逐级</code>向原型链上层查找。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">  console.log(&quot;parent method&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function User(name) &#123;&#125;</span><br><span class="line">User.prototype = Object.create(Person.prototype);</span><br><span class="line">User.prototype.constructor = User;</span><br><span class="line"></span><br><span class="line">User.prototype.getName = function() &#123;</span><br><span class="line">  //调用父级同名方法</span><br><span class="line">  Person.prototype.getName.call(this);</span><br><span class="line">  console.log(&quot;child method&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">let as = new User();</span><br><span class="line">as.getName();</span><br><span class="line">console.log(Object.getPrototypeOf(as).getName ==</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(as)).getName); //false</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：根据多种不同的形态产生不同的结果。</p>
<p>下而会根据不同类型的对象得到不同的结果。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.show = function () &#123;</span><br><span class="line">     	console.log(this.desc);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   function Admin() &#123;&#125;</span><br><span class="line">   Admin.prototype = Object.create(Person.prototype);</span><br><span class="line">   Admin.prototype.desc = &quot;管理员的蔑视&quot;;</span><br><span class="line"></span><br><span class="line">   function Member() &#123;&#125;</span><br><span class="line">   Member.prototype = Object.create(Person.prototype);</span><br><span class="line">   Member.prototype.desc = &quot;我是Vip&quot;;</span><br><span class="line"></span><br><span class="line">   function Enterprise() &#123;&#125;</span><br><span class="line">   Enterprise.prototype = Object.create(Person.prototype);</span><br><span class="line">   Enterprise.prototype.desc = &quot;企业账户&quot;;</span><br><span class="line"></span><br><span class="line">   let users = [new Admin(), new Member(), new Enterprise()];</span><br><span class="line">   for (const user of Object.values(users)) user.show();</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="深挖继承"><a href="#深挖继承" class="headerlink" title="深挖继承"></a>深挖继承</h3><p>继承是为了复用代码，继承的本质是将原型指向到另一个对象。</p>
<h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们希望<code>调用父类构造函数完成对象属性的初始化</code>，但像下面这样使用是不会成功的。因为此时 <code>this</code> 指向了window，无法为当前对象声明属性。</p>
<ul>
<li>下例通过Admin构造函数创建实例，但是希望在Admin中 使用父级构造函数User来初始化实例的属性。</li>
<li>但是如果直接调用User函数，由于独立存在的函数this指向window，所以不能够为Admin实例赋予属性</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  console.log(this);// Window</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.getUserName = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Admin(name) &#123;</span><br><span class="line">  User(name);</span><br><span class="line">&#125;</span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line"></span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.getUserName()); //undefined</span><br><span class="line">console.log(window.name); //阿顺</span><br></pre></td></tr></table></figure>

<p>解决上面的问题是使用 <code>call/apply</code> 改变User函数的this指向，为每个生成的对象设置属性。</p>
<ul>
<li>因为这里只是简单的调用User构造函数，所以需要改变this指向，不然this指向window。构造函数实例化为对象时，内部的this才会分配到实例上。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  console.log(this); // Admin</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.getUserName = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Admin(name) &#123;</span><br><span class="line">  User.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line"></span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.getUserName()); //undefined</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型工厂"><a href="#原型工厂" class="headerlink" title="原型工厂"></a>原型工厂</h4><p>原型工厂是将继承的过程封装，使用继承业务简单化。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function extend(sub, sup) &#123;</span><br><span class="line">  sub.prototype = Object.create(sup.prototype);</span><br><span class="line">  sub.prototype.constructor = sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Access() &#123;&#125;</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line">function Member() &#123;&#125;</span><br><span class="line"></span><br><span class="line">extend(User, Access); </span><br><span class="line">extend(Admin, User); </span><br><span class="line">extend(Member, Access); </span><br><span class="line"></span><br><span class="line">Access.prototype.rules = function() &#123;&#125;;</span><br><span class="line">User.prototype.getName = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(new Admin()); // 继承关系: Admin&gt;User&gt;Access&gt;Object</span><br><span class="line">console.log(new Member()); //继承关系：Member&gt;Access&gt;Object</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h4><p>其实就是在<code>工厂函数</code>的基础上，完成原型的继承、对象属性的初始化。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function() &#123;</span><br><span class="line">  console.log(this.name, this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Admin(name, age) &#123;</span><br><span class="line">  let instance = Object.create(User.prototype);</span><br><span class="line">  User.call(instance, name, age);</span><br><span class="line">  instance.role=function()&#123;</span><br><span class="line">    console.log(&#x27;admin.role&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br><span class="line">let as = Admin(&quot;阿顺&quot;, 18);</span><br><span class="line">as.show();</span><br><span class="line"></span><br><span class="line">function member(name, age) &#123;</span><br><span class="line">  let instance = Object.create(User.prototype);</span><br><span class="line">  User.call(instance, name, age);</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br><span class="line">let lisi = member(&quot;李四&quot;, 28);</span><br><span class="line">lisi.show();</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h4><p><code>JS</code>不能实现多继承，因为每个类的原型<code>prototype</code>只能设置一次，多次设置会覆盖之前的配置，每个类只能够继承一个父类原型。如果要使用多个类的方法时可以使用<code>mixin</code>混合模式来完成。</p>
<ul>
<li><code>mixin</code> 类是一个包含许多供其它类使用的方法的类</li>
<li><code>mixin</code> 类<code>不用来</code>继承做为其它类的父类,只是将其中的方法合并到目标原型上。</li>
</ul>
<p>下面是示例中 <code>Admin</code>需要使用 <code>Request.prototype</code> 与 <code>Credit.prototype</code> 的功能，因为<code>JS</code> 是单继承，<code>Admin</code>不能够同时继承<code>Request.prototype</code> 与 <code>Credit.prototype</code> 。我们不得不将无关的类连接在一起，显然下面的代码实现并不佳。</p>
<ul>
<li>User-&gt;Request-&gt;Credit</li>
<li>Admin要同时使用Request和Credit中的方法，则就需要一个中间类(User)，将二者连接起来，再继承User的原型</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function extend(sub, sup) &#123;</span><br><span class="line">  sub.prototype = Object.create(sup.prototype);</span><br><span class="line">  sub.prototype.constructor = sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Credit() &#123;&#125;</span><br><span class="line">function Request() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Request, Credit);</span><br><span class="line">extend(User, Request);</span><br><span class="line"></span><br><span class="line">Request.prototype.ajax = function() &#123;</span><br><span class="line">  console.log(&quot;请求后台&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">Credit.prototype.total = function() &#123;</span><br><span class="line">  console.log(&quot;统计积分&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">User.prototype.show = function() &#123;</span><br><span class="line">  console.log(this.name, this.age);</span><br><span class="line">&#125;;</span><br><span class="line">function Admin(...args) &#123;</span><br><span class="line">  User.apply(this, args);</span><br><span class="line">&#125;</span><br><span class="line">extend(Admin, User);</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;, 18);</span><br><span class="line">as.show();</span><br><span class="line">as.total(); //统计积分</span><br><span class="line">as.ajax(); //请求后台</span><br></pre></td></tr></table></figure>

<p>下面分拆功能使用<code>Object.assign</code>实现Mixin多继承，使用代码结构更清晰。只让 <code>Admin</code> 继承 <code>User</code> 原型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function extend(sub, sup) &#123;</span><br><span class="line">  sub.prototype = Object.create(sup.prototype);</span><br><span class="line">  sub.prototype.constructor = sub;</span><br><span class="line">&#125;</span><br><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function() &#123;</span><br><span class="line">  console.log(this.name, this.age);</span><br><span class="line">&#125;;</span><br><span class="line">const Credit = &#123;</span><br><span class="line">  total() &#123;</span><br><span class="line">    console.log(&quot;统计积分&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Request = &#123;</span><br><span class="line">  ajax() &#123;</span><br><span class="line">    console.log(&quot;请求后台&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Admin(...args) &#123;</span><br><span class="line">  User.apply(this, args);</span><br><span class="line">&#125;</span><br><span class="line">extend(Admin, User);</span><br><span class="line">Object.assign(Admin.prototype, Request, Credit);</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;, 18);</span><br><span class="line">as.show();</span><br><span class="line">as.total(); //统计积分</span><br><span class="line">as.ajax(); //请求后台</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面使用<code>Object.assign</code>实现多继承，具有局限性，因为此时，需要继承的方法必须都封装在对象中，此时就需要把<code>Credit、Request</code>从构造函数形式，转化成对象形式。</p>
</blockquote>
<p>我们也可以使用<code>for/in、for/of</code>浅拷贝目标原型上的所有属性，实现多继承，下例就不需要中间类User了，直接继承<code>Credit</code>,再Copy<code>Request.prototype</code>中的属性即可。</p>
<p><strong>Tips</strong></p>
<ul>
<li><p>在遍历赋值之前，使用<code>Object.create()</code>设置了子类的父级原型，也导致子类本身的prototype为<code>&#123;&#125;</code></p>
</li>
<li><p>之后遍历赋值操作，设置了子类的constructor为父类的constructor，不符合逻辑，所以我再次配置了子类的constructor</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function assignPrototype(sub, sup) &#123;</span><br><span class="line">     for (let [key, value] of Object.entries(sup.prototype)) &#123;</span><br><span class="line">       sub.prototype[key] &#x3D; value;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function Credit() &#123;&#125;</span><br><span class="line">   function Request() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   Credit.prototype.total &#x3D; function () &#123;</span><br><span class="line">     console.log(&quot;统计积分&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line">   Credit.prototype.getName &#x3D; function () &#123;</span><br><span class="line">     console.log(this.name);</span><br><span class="line">   &#125;;</span><br><span class="line">   Request.prototype.ajax &#x3D; function () &#123;</span><br><span class="line">     console.log(&quot;请求后台&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   function Admin(name) &#123;</span><br><span class="line">     this.name &#x3D; name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Admin.prototype &#x3D; Object.create(Credit.prototype);</span><br><span class="line">   assignPrototype(Admin, Request);</span><br><span class="line">   Admin.prototype.constructor &#x3D; Admin;	&#x2F;&#x2F;重新设置constructor</span><br><span class="line"></span><br><span class="line">   let as &#x3D; new Admin(&quot;阿顺&quot;);</span><br><span class="line">   as.total();</span><br><span class="line">   as.getName();</span><br><span class="line">   as.ajax();</span><br><span class="line">   console.log(Admin.prototype);</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<code>Object.assign(sub.prototype,sup.prototype)</code>将二者的原型进行合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      Admin.prototype &#x3D; Object.create(Credit.prototype);</span><br><span class="line">      Object.assign(Admin.prototype, Request.prototype);</span><br><span class="line">      Admin.prototype.constructor &#x3D; Admin;	&#x2F;&#x2F;重新设置constructor</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>如果我们只是单纯的使用某些类的方法，而不在意父子关系，我们可以直接使用<code>Object.assign</code>合并多个原型即可，但是由于没有让这些原型链接起来，所以不能够使用instanceof进行判断。</p>
<ul>
<li>若没有使用<code>Object.create</code>设置子类的原型，则之后使用<code>Object.assign</code>合并原型时，不会覆盖子类的<code>prototype.constructor</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">      Object.assign(Admin.prototype, Credit.prototype, Request.prototype);</span><br><span class="line"></span><br><span class="line">      let as &#x3D; new Admin(&quot;阿顺&quot;);</span><br><span class="line">      as.total();</span><br><span class="line">      as.getName();</span><br><span class="line">      as.ajax();</span><br><span class="line">      console.log(as instanceof Admin); &#x2F;&#x2F;true</span><br><span class="line">      console.log(as instanceof Credit); &#x2F;&#x2F;false</span><br><span class="line">      console.log(as instanceof Request); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<p>也可以使用<code>Class</code>结合<code>super</code>关键字，实现多继承</p>
<ul>
<li>super关键字必须写在constructor的顶部</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let CalculaterMixin &#x3D; (Base) &#x3D;&gt;</span><br><span class="line">    class extends Base &#123;</span><br><span class="line">      constructor(...argus) &#123;</span><br><span class="line">        super(...argus);</span><br><span class="line">        this.argus &#x3D; argus;</span><br><span class="line">      &#125;</span><br><span class="line">      cacul() &#123;</span><br><span class="line">        console.log(&#96;Calculater Method:$&#123;this.argus&#125;&#96;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  let RandomMixin &#x3D; (Base) &#x3D;&gt;</span><br><span class="line">    class extends Base &#123;</span><br><span class="line">      constructor(...argus) &#123;</span><br><span class="line">        super(...argus);</span><br><span class="line">        this.argus &#x3D; argus;</span><br><span class="line">      &#125;</span><br><span class="line">      random() &#123;</span><br><span class="line">        console.log(&#96;Random Method:$&#123;this.argus&#125;&#96;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;</span><br><span class="line">    constructor(...argus) &#123;</span><br><span class="line">      this.argus &#x3D; argus;</span><br><span class="line">      console.log(...argus);</span><br><span class="line">    &#125;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      console.log(&#96;Foo Method:$&#123;this.argus&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class End extends CalculaterMixin(RandomMixin(Foo)) &#123;&#125;</span><br><span class="line">  let end &#x3D; new End(&quot;ashun&quot;, &quot;SHUN&quot;);</span><br><span class="line">  end.foo();</span><br><span class="line">  end.random();</span><br><span class="line">  end.cacul();</span><br><span class="line">  console.log(end instanceof End);</span><br><span class="line">  console.log(end instanceof Foo);</span><br><span class="line">  console.log(end instanceof CalculaterMixin); &#x2F;&#x2F;Err</span><br><span class="line">  console.log(end instanceof RandomMixin); &#x2F;&#x2F;Err</span><br></pre></td></tr></table></figure>

<p>上面这种方法利用了ES6中class的extends<code>后面可以使用表达式</code>特性，间接实现多继承，这种方法有个缺点是CalculatorMixin等Mixin其实是个箭头函数，无法用instanceof检测，因为<code>箭头函数没有显示原型</code>。</p>
<p>下面看看如何修正原型链：</p>
<ul>
<li>手动设置Mixin的原型</li>
<li>让Mixin之间产生继承关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">&#x2F;&#x2F;需要继承自Object，这里如果写null的话，CalculaterMixin instanceof Object会是false</span><br><span class="line">CalculaterMixin.prototype &#x3D; Object.create(&#123;&#125;);</span><br><span class="line">RandomMixin.prototype &#x3D; Object.create(null);</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(RandomMixin.prototype, CalculaterMixin.prototype);</span><br><span class="line">Object.setPrototypeOf(Foo.prototype, RandomMixin.prototype);</span><br><span class="line">      console.log(end instanceof End);</span><br><span class="line">      console.log(end instanceof Foo);</span><br><span class="line">      console.log(end instanceof CalculaterMixin); &#x2F;&#x2F;true</span><br><span class="line">      console.log(end instanceof RandomMixin); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p><code>mixin</code> 类也可以继承其他类，比如下面的 <code>Create</code> 类获取积分要请求后台，就需要继承 <code>Request</code> 来完成。</p>
<ul>
<li>手动配置<code>Create</code>的<code>__proto__</code>属性</li>
</ul>
<ul>
<li><code>super</code> 关键字指向本对象的父级原型。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function extend(sub, sup) &#123;</span><br><span class="line">  sub.prototype = Object.create(sup.prototype);</span><br><span class="line">  sub.prototype.constructor = sub;</span><br><span class="line">&#125;</span><br><span class="line">function User(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function() &#123;</span><br><span class="line">  console.log(this.name, this.age);</span><br><span class="line">&#125;;</span><br><span class="line">const Request = &#123;</span><br><span class="line">  ajax() &#123;</span><br><span class="line">    return &quot;请求后台&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Credit = &#123;</span><br><span class="line">  __proto__: Request,</span><br><span class="line">  total() &#123;</span><br><span class="line">    console.log(super.ajax() + &quot;,统计积分&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Admin(...args) &#123;</span><br><span class="line">  User.apply(this, args);</span><br><span class="line">&#125;</span><br><span class="line">extend(Admin, User);</span><br><span class="line">Object.assign(Admin.prototype, Request, Credit);</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;, 18);</span><br><span class="line">as.show();</span><br><span class="line">as.total(); //统计积分</span><br><span class="line">as.ajax(); //请求后台</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实例体验"><a href="#实例体验" class="headerlink" title="实例体验"></a>实例体验</h4><p>使用继承原型的方法，结合 <code>call/apply</code> 制作选项卡。</p>
<img src="原型与继承.assets/prototype_7.gif" alt="prototype_7" style="zoom:70%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-around;</span><br><span class="line">        align-items: center;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        width: 45%;</span><br><span class="line">        height: 300px;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      main &gt; nav &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        min-height: 30px;</span><br><span class="line">        display: flex;</span><br><span class="line">        background-color: #ccc;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">      a &#123;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        flex: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        color: #eee;</span><br><span class="line">      &#125;</span><br><span class="line">      main &gt; article &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">        background-color: #eee;</span><br><span class="line">        position: relative;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        margin-top: 2px;</span><br><span class="line">      &#125;</span><br><span class="line">      section &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">        display: none;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        font-size: 24px;</span><br><span class="line">        color: rgba(255, 255, 255, 0.8);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main class&#x3D;&quot;tab1&quot;&gt;</span><br><span class="line">      &lt;nav&gt;&lt;a&gt;Ashun&lt;&#x2F;a&gt; &lt;a&gt;阿顺&lt;&#x2F;a&gt;&lt;&#x2F;nav&gt;</span><br><span class="line">      &lt;article&gt;</span><br><span class="line">        &lt;section&gt;Ashun&lt;&#x2F;section&gt;</span><br><span class="line">        &lt;section&gt;阿顺&lt;&#x2F;section&gt;</span><br><span class="line">      &lt;&#x2F;article&gt;</span><br><span class="line">    &lt;&#x2F;main&gt;</span><br><span class="line">    &lt;main class&#x3D;&quot;tab2&quot;&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;a&gt;SHUN&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a&gt;shun&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;nav&gt;</span><br><span class="line">      &lt;article&gt;</span><br><span class="line">        &lt;section&gt;SHUN&lt;&#x2F;section&gt;</span><br><span class="line">        &lt;section&gt;shun&lt;&#x2F;section&gt;</span><br><span class="line">      &lt;&#x2F;article&gt;</span><br><span class="line">    &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      &#x2F;*</span><br><span class="line">        prototype 实例操作：实现Tab选项卡</span><br><span class="line">        让Tab类原型继承Animation类的原型。</span><br><span class="line">        Animation类中提供实现动画的方法，Tab类中完成dom的追踪和事件的绑定,</span><br><span class="line">        在Tab类中，结合call&#x2F;applay使用Animation中的方法。</span><br><span class="line">        Tab类中只需要传入选项卡的rootDOM即可，内部使用rootDOM.querySelector查找子元素即可。</span><br><span class="line">      *&#x2F;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;继承封装</span><br><span class="line">      function extend(sub, sup) &#123;</span><br><span class="line">        sub.prototype &#x3D; Object.create(sup.prototype);</span><br><span class="line">        sub.prototype.constructor &#x3D; sub;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;*Animation类*&#x2F;</span><br><span class="line"></span><br><span class="line">      function Animation() &#123;&#125;</span><br><span class="line">      Animation.prototype.show &#x3D; function () &#123;</span><br><span class="line">        this.style.display &#x3D; &quot;flex&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">      Animation.prototype.hide &#x3D; function () &#123;</span><br><span class="line">        this.style.display &#x3D; &quot;none&quot;;</span><br><span class="line">      &#125;;</span><br><span class="line">      Animation.prototype.background &#x3D; function (color) &#123;</span><br><span class="line">        this.style.backgroundColor &#x3D; color;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      function Tab(tab) &#123;</span><br><span class="line">        this.tab &#x3D; tab;</span><br><span class="line">        this.a &#x3D; tab.querySelectorAll(&quot;a&quot;);</span><br><span class="line">        this.section &#x3D; tab.querySelectorAll(&quot;section&quot;);</span><br><span class="line">        console.log(this.a, this.section);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      extend(Tab, Animation);</span><br><span class="line">      </span><br><span class="line">      Tab.prototype.init &#x3D; function () &#123;</span><br><span class="line">        this.build();</span><br><span class="line">        this.reset();</span><br><span class="line">        this.action(0);</span><br><span class="line">      &#125;;</span><br><span class="line">      Tab.prototype.reset &#x3D; function () &#123;</span><br><span class="line">        this.section.forEach((val) &#x3D;&gt; this.hide.call(val));</span><br><span class="line">        this.a.forEach((val) &#x3D;&gt; this.background.call(val, &quot;#ccc&quot;));</span><br><span class="line">      &#125;;</span><br><span class="line">      Tab.prototype.action &#x3D; function (i) &#123;</span><br><span class="line">        this.show.call(this.section[i]);</span><br><span class="line">        this.background.call(this.a[i], &quot;pink&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">      Tab.prototype.build &#x3D; function () &#123;</span><br><span class="line">        this.a.forEach((a, index) &#x3D;&gt; &#123;</span><br><span class="line">          a.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">            this.reset();</span><br><span class="line">            this.action(index);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      new Tab(document.querySelector(&quot;.tab1&quot;)).init();</span><br><span class="line">      new Tab(document.querySelector(&quot;.tab2&quot;)).init();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>正则表达式是用于匹配字符串中<code>字符组合</code>的模式，在 JavaScript中，正则表达式也是对象。</p>
<ul>
<li>正则表达式是在宿主环境下运行的，如<code>js/php/node.js</code> 等 , 即在不同的语言中都会有正则表达式。</li>
<li>本章讲解的知识在其他语言中知识也是可用的，但是会有些函数使用上的区别</li>
</ul>
<h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p>与普通函数操作字符串来比较，正则表达式可以写出更简洁、功能强大的代码。</p>
<p>下面使用获取字符串中的所有数字来比较函数与正则的差异。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Str = &quot;Ashuntefannao1.1324Ashun&quot;;</span><br><span class="line">let numbers = [...Str].filter((char) =&gt; !isNaN(Number(char))).join(&quot;&quot;);</span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式将简单得多</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Str = &quot;Ashuntefannao1.1324Ashun&quot;;</span><br><span class="line">let numbers = Str.match(/\d/g).join(&quot;&quot;);</span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="创建正则"><a href="#创建正则" class="headerlink" title="创建正则"></a>创建正则</h4><p>JS提供<code>字面量</code>与<code>对象</code>两种方式创建正则表达式，推荐使用<code>字面量形式</code>创建RegExp，形式更加简洁。</p>
<h5 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h5><p>使用<code>//</code>包裹的字面量创建方式是推荐的作法，但不能在<code>//</code>中使用变量作为匹配规则</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let reg=/[A-Z]/;</span><br><span class="line">console.log(reg.test(as)); //true</span><br><span class="line">console.log(/[A-Z]/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p><code>//</code>包裹的字面量创建的正则，其中不能应用变量，作为匹配规则。</p>
<ul>
<li><code>//</code>包裹的内容会被理解为正则语法，所以其中的<code>z</code>不是变量，是匹配<code>z</code>字符</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let z = &quot;shun&quot;;</span><br><span class="line">console.log(/z/.test(as)); //false</span><br><span class="line">console.log(/z/.test(&quot;zheng&quot;))//true</span><br></pre></td></tr></table></figure>

<p>虽然可以使用 <code>eval</code> 计算字符串表达式，将其转换为js语法来实现将变量解析到正则中，但是比较麻烦，所以<code>有变量时</code>建议使用下面所讲的<code>对象创建</code>方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">let z = &quot;shun&quot;;</span><br><span class="line">console.log(eval(`/$&#123;z&#125;/`).test(as)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><p>当正则需要动态创建时（应用str变量），建议使用对象方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;ashuntefannao&quot;;</span><br><span class="line">let str = &quot;ashun&quot;;</span><br><span class="line">let reg = new RegExp(str);</span><br><span class="line">console.log(reg.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>根据用户输入高亮显示内容，支持用户输入正则表达式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;content&quot;&gt;ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let matchStr = prompt(&quot;请输入搜索的字符串,支持输入正则&quot;);</span><br><span class="line">  let reg = new RegExp(matchStr, &quot;g&quot;);</span><br><span class="line">  let dom = document.querySelector(&quot;#content&quot;);</span><br><span class="line">  dom.innerHTML = dom.innerHTML.replace(reg, (str) =&gt; &#123;</span><br><span class="line">  	console.log(str);</span><br><span class="line">  	return `&lt;strong style=&quot;color:red;&quot;&gt;$&#123;str&#125;&lt;/strong&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过对象创建正则，提取标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ASHUN&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#123;</span><br><span class="line">        function getElement(ele) &#123;</span><br><span class="line">          let html = document.body.innerHTML;</span><br><span class="line">          let matchStr = `&lt;($&#123;ele&#125;)&gt;.+&lt;/\\1&gt;`;</span><br><span class="line">          let reg = new RegExp(matchStr, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">          console.table(html.match(reg));</span><br><span class="line">        &#125;</span><br><span class="line">        getElement(&quot;h1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h4><p>选择修释符<code>|</code> 这个符号带表<code>或</code>的关系，也就是 <code>|</code> 左右两侧有一个匹配到就可以。</p>
<h6 id="要注意：使用的范围不同，得到的结果也不同"><a href="#要注意：使用的范围不同，得到的结果也不同" class="headerlink" title="要注意：使用的范围不同，得到的结果也不同"></a><em>要注意：使用的范围不同，得到的结果也不同</em></h6><ul>
<li>如果在整个表达式使用，则将整个表达式一分为二</li>
<li>同理，在原子组中使用，则只是将当前原子组一分为二</li>
</ul>
<p>检测电话是否是上海或北京的坐机</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let tel = &quot;010-12345678&quot;;</span><br><span class="line">//错误结果：只匹配 | 左右两边任一结果</span><br><span class="line">console.log(tel.match(/010|020\-\d&#123;7,8&#125;/)); </span><br><span class="line"></span><br><span class="line">//正确结果：需要放在原子组中使用，将当前原子组一分为二</span><br><span class="line">console.log(tel.match(/(010|020)\-\d&#123;7,8&#125;/));</span><br></pre></td></tr></table></figure>

<p>匹配字符是否包含<code>ashuntefannao</code> 或 <code>ashun</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const title = &quot;ashuntefannao&quot;;</span><br><span class="line">console.log(/ashuntefannao|ashun/.test(title)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p><code>\被转义字符</code></p>
<ul>
<li><p>转义用于 <code>改变字符的含义</code>，用来处理 <code>某个字符有多种语义时</code> 的情况。</p>
</li>
<li><p>在正则中具有特殊意义的字符，使用时需要转义。</p>
</li>
<li><p>假如有这样的场景，如果我们想通过正则查找<code>/</code>符号，但是 <code>/</code>在正则中有特殊的意义。如果写成<code>///</code>这会造成解析错误，所以要使用转义语法 <code>/\//</code>来匹配。</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const url = &quot;https://www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/https:\/\//.test(url)); //true</span><br></pre></td></tr></table></figure>

<p>使用 <code>RegExp</code> 构建正则时在转义上会有些区别，下面是对象与字面量定义正则时区别</p>
<ul>
<li>在普通字符串中，转义一次字符，结果不变</li>
<li>由于使用对象形式<code>new RegExp(str,mode)</code>创建正则时，第一个参数接收的是字符串，需要在字符串中定义匹配的规则，所以 若使用特殊意义的匹配字符 需要转义两次。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let price = 12.23;</span><br><span class="line">//含义1: . 除换行外任何字符 	含义2: .普通点</span><br><span class="line">//含义1: d 字母d   					含义2: \d 数字 0~9</span><br><span class="line">console.log(/\d+\.\d+/.test(price));</span><br><span class="line"></span><br><span class="line">//字符串中 \d 与 d 是一样的，所以在 new RegExp 时\d 即为 d</span><br><span class="line">console.log(&quot;\d&quot; == &quot;d&quot;);</span><br><span class="line"></span><br><span class="line">//使用对象定义正则时，可以先把字符串打印一样，结果是字面量一样的定义就对了</span><br><span class="line">console.log(&quot;\\d+\\.\\d+&quot;);</span><br><span class="line">let reg = new RegExp(&quot;\\d+\\.\\d+&quot;);</span><br><span class="line">console.log(reg.test(price));</span><br></pre></td></tr></table></figure>

<p>下面是网址检测中转义符使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let url = &quot;https://www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(url.match(/https?:\/\/w+\.\w+\.\w+/));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h4><p>使用字符边界符用于控制匹配内容的开始与结束约定。</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束，忽略换行符</td>
</tr>
</tbody></table>
<p>匹配内容必须以<code>www</code>开始</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &quot;www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/^www/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>匹配内容必须以<code>.com</code>结束</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &quot;www.ashuntefannao.com&quot;;</span><br><span class="line">console.log(/\.com$/.test(as)); //true</span><br></pre></td></tr></table></figure>

<p>检测用户名长度为3~6位，且只能为字母。如果不使用 <code>^与$</code> 限制将得不到正确结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  	document.querySelector(&quot;[name=&#x27;username&#x27;]&quot;)</span><br><span class="line">          .addEventListener(&quot;input&quot;, function () &#123;</span><br><span class="line">            let test = this.value.match(/^[a-zA-Z]&#123;3,6&#125;$/);</span><br><span class="line">            console.log(test ? &quot;正确&quot; : &quot;错误&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;[a-zA-Z]&#123;3,6&#125;&#x2F;;</span><br><span class="line">    let reg1 &#x3D; &#x2F;^[a-zA-Z]&#123;3,6&#125;$&#x2F;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;不使用^$限制，虽然字符串长度不足时也可返回正确结果</span><br><span class="line">    &#x2F;&#x2F;但字符串长度超出时，返回的是自前向后匹配的结果</span><br><span class="line">    console.log(&quot;as&quot;.match(reg));							&#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;123ashuntefannao123&quot;.match(reg));	&#x2F;&#x2F;[&quot;ashunt&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用^$进行限制，以字母3-6位开头，并以字母3-6位结尾，则匹配结果为3-6位纯字母</span><br><span class="line">    console.log(&quot;ashuntefannao&quot;.match(reg1)); &#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;as&quot;.match(reg1)); 						&#x2F;&#x2F;null</span><br><span class="line">    console.log(&quot;ashun&quot;.match(reg1)); 				&#x2F;&#x2F;[&quot;ashun&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只是用^限制，则只要开头满足3-6位纯字母即可</span><br><span class="line">    console.log(&quot;ashuntefannao123&quot;.match(&#x2F;^[a-zA-Z]&#123;3,6&#125;&#x2F;)); &#x2F;&#x2F;[&quot;ashunt&quot;]</span><br><span class="line">    &#x2F;&#x2F;只是用$限制，则只要结尾满足3-6位纯字母即可</span><br><span class="line">    console.log(&quot;132ashuntefannao&quot;.match(&#x2F;[a-zA-Z]&#123;3,6&#125;$&#x2F;)); &#x2F;&#x2F;[&quot;fannao&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符是正则表达式中的最小元素，只代表单一（一个）字符。</p>
<h4 id="普通元字符"><a href="#普通元字符" class="headerlink" title="普通元字符"></a>普通元字符</h4><p>普通元字符，即 在正则中没有特殊意义的 普通字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &quot;ashun&quot;;</span><br><span class="line">console.log(&#x2F;a&#x2F;.test(a)); 		&#x2F;&#x2F;true</span><br><span class="line">console.log(a.match(&#x2F;a&#x2F;)[0]); &#x2F;&#x2F;a</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="特殊元字符"><a href="#特殊元字符" class="headerlink" title="特殊元字符"></a>特殊元字符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配任意一个数字</td>
<td>[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>与除了数字以外的任何一个字符匹配</td>
<td>[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>与任意一个字母、数字、下划线匹配</td>
<td>[a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>除了 字母、数字、下划线以外 与任何字符匹配</td>
<td>[^a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>任意一个空白字符匹配，如空格，制表符<code>\t</code>，换行符<code>\n</code></td>
<td>[\n\f\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>除了空白符外任意一个字符匹配</td>
<td>[^\n\f\r\t\v]</td>
</tr>
<tr>
<td>\p{prop}</td>
<td>配合<code>u</code>模式，匹配对应属性的字符</td>
<td>( \p{P} | \p{sc=Han} )</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符外的任意字符</td>
<td>[^\n]</td>
</tr>
</tbody></table>
<h4 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h4><p>匹配任意数字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao 2020&quot;;</span><br><span class="line">console.log(as.match(/\d/g)); //[&quot;2&quot;, &quot;0&quot;, &quot;2&quot;, &quot;0&quot;]</span><br></pre></td></tr></table></figure>

<p>匹配所有电话号码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = `</span><br><span class="line">	张三:010-99999999,李四:020-88888888</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let res = as.match(/\d&#123;3&#125;-\d&#123;7,8&#125;/g);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<p>获取所有用户名</p>
<ul>
<li><code>-</code>在原子组<code>[]</code>中具有特殊含义，为了避免冲突，最好转义使用</li>
<li>下列情况是否转义，情况都相同，但在表示一些匹配范围时，就会有歧义</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = `</span><br><span class="line">张三:010-99999999,李四:020-88888888`;</span><br><span class="line">let res = as.match(/[^:\d-,\s]+/g);</span><br><span class="line"></span><br><span class="line">console.log(/[^:\d\-,\s]+/g)</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;103azA&quot;.match(&#x2F;[0\-9]&#x2F;g));	&#x2F;&#x2F;[&quot;0&quot;]</span><br><span class="line">console.log(&quot;103azA&quot;.match(&#x2F;[0-9]&#x2F;g));	&#x2F;&#x2F;[&quot;1&quot;,&quot;0&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure>

<p>也可使用<code>\p&#123;prop&#125;</code>结合<code>u</code>模式，匹配属性为汉字的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(as.match(&#x2F;\p&#123;sc&#x3D;Han&#125;&#123;2,3&#125;&#x2F;gu)); &#x2F;&#x2F;[&quot;张三&quot;,&quot;李四&quot;]</span><br></pre></td></tr></table></figure>



<p>匹配任意非数字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(/\D/.test(2029)); //false</span><br></pre></td></tr></table></figure>

<p>匹配字母数字下划线</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;ashun@&quot;;</span><br><span class="line">console.log(as.match(/\w/g)); //[&quot;a&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;]</span><br></pre></td></tr></table></figure>

<p>匹配除了字母,数字或下划线外与任何字符匹配</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(/\W/.test(&quot;@&quot;)); //true</span><br></pre></td></tr></table></figure>

<p>匹配与任意一个空白字符</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(/\s/.test(&quot; &quot;)); //true</span><br><span class="line">console.log(/\s/.test(&quot;\n \t&quot;)); //true</span><br></pre></td></tr></table></figure>

<p>匹配除了空白符外任意一个字符匹配</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;ashun@&quot;;</span><br><span class="line">console.log(as.match(/\S/g)); //[&quot;a&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;,&quot;@&quot;]</span><br></pre></td></tr></table></figure>

<p>如果要匹配 字符串点<code>&quot;.&quot;</code> 则需要转义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = `ashuntefannao@com`;</span><br><span class="line">console.log(/ashuntefannao.com/i.test(as));  //true</span><br><span class="line">console.log(/ashuntefannao\.com/i.test(as)); //false</span><br></pre></td></tr></table></figure>

<p>使用<code>.</code>匹配除换行符外任意字符，下面匹配不到<code>ashun.com</code> 因为有换行符 且没有使用<code>g</code>模式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const url = `</span><br><span class="line">  https://www.Ashuntefanano.com</span><br><span class="line">  ashun.com</span><br><span class="line">`;</span><br><span class="line">console.log(url.match(/.+/));</span><br></pre></td></tr></table></figure>

<p>特殊元字符<code>.</code> 配合<code>s</code>模式，<code>.</code>就可以匹配任意字符 (能够匹配换行符)</p>
<ul>
<li>使用<code>s</code>单行模式（忽略换行）时，可以匹配所有</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title = `</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    ashuntefannao</span><br><span class="line">    ashun</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">`;</span><br><span class="line">let res = title.match(/&lt;span&gt;.*&lt;\/span&gt;/s);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>

<p>正则中会将 空格 按普通字符对待</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let tel = `010 - 999999`;</span><br><span class="line">console.log(/\d+-\d+/.test(tel)); //false</span><br><span class="line">console.log(/\d+ - \d+/.test(tel)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="所有字符"><a href="#所有字符" class="headerlink" title="所有字符"></a>所有字符</h4><ul>
<li>可以使用 <code>[\s\S]</code>、<code>[\d\D]</code>、<code>[\w\W]</code>等等来匹配所有字符</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = `</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    ashuntefannao</span><br><span class="line">    ashun</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">`;</span><br><span class="line">let res = as.match(/&lt;span&gt;[\s\S]+&lt;\/span&gt;/);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code>结合<code>s</code>单行模式(忽略换行符)，也可匹配所有字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">let res &#x3D; title.match(&#x2F;&lt;span&gt;.*&lt;\&#x2F;span&gt;&#x2F;s);</span><br><span class="line">console.log(res[0]);</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>正则表达式在执行时会按他们的默认执行方式进行处理，但有时候默认的处理方式总不能满足我们的需求，所以可以切换不同的匹配模式满足业务需求。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>不区分大小写字母的匹配</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索所有匹配内容</td>
</tr>
<tr>
<td>m</td>
<td>视为多行</td>
</tr>
<tr>
<td>s</td>
<td>视为单行忽略换行符，使用<code>.</code> 可以匹配所有字符</td>
</tr>
<tr>
<td>y</td>
<td>从 <code>regexp.lastIndex</code> 开始匹配</td>
</tr>
<tr>
<td>u</td>
<td>Unicode模式，能够正确处理四个字符的 UTF-16 编码</td>
</tr>
</tbody></table>
<h4 id="i"><a href="#i" class="headerlink" title="i"></a>i</h4><p>将所有<code>ashuntefannao</code> 统一为小写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let site = &quot;ashuntefannao ASHUNTEFANNAO&quot;;</span><br><span class="line">site = site.replace(/ashuntefannao/gi, &quot;ashuntefannao&quot;);</span><br><span class="line">console.log(site);</span><br></pre></td></tr></table></figure>



<h4 id="g"><a href="#g" class="headerlink" title="g"></a>g</h4><p>使用 <code>g</code> 模式，可以搜索到所有满足匹配规则的string</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        let as = &quot;ashuntefannao&quot;;</span><br><span class="line">        as = as.replace(/n/, &quot;@&quot;);</span><br><span class="line">        console.log(as); //没有使用 g 修饰符是，只替换了第一个 n</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        let as = &quot;ashuntefannao&quot;;</span><br><span class="line">        as = as.replace(/n/g, &quot;@&quot;);</span><br><span class="line">        console.log(as); //使用全局修饰符后替换了全部的 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p><code>m</code>多行匹配模式，结合<code>^$</code>可约束匹配字符串中的每一行。</p>
<p>也就是说：字符串存在换行符<code>\n</code>时，字符串有几行，就匹配多少次。并且每一行都可使用<code>^$</code>进行约束。</p>
<ul>
<li>默认情况下，无论字符串是否有换行符，都只有一个开头<code>^</code>和结尾<code>$</code></li>
<li>结合<code>m</code>模式，每一行都有自身的<code>^$</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let str &#x3D; &#96;</span><br><span class="line">      # jsES6 #</span><br><span class="line">      # vue2.0 #</span><br><span class="line">      # ashunte #</span><br><span class="line">      &#96;;</span><br><span class="line">      console.log(str.match(&#x2F;^\s*#\s+.*\s#$&#x2F;gm));	</span><br><span class="line">      console.log(str.match(&#x2F;^\s*#\s+.+#\s*$&#x2F;g));&#x2F;&#x2F;null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例是将以 <code>#数字</code>开始的课程解析为对象结构，学习过后面讲到的原子组可以让代码简单些</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  			let str = `</span><br><span class="line">  				#1 js,200元 #</span><br><span class="line">  				#2 php,300元 #</span><br><span class="line">  				#9 ashuntefannao # 阿顺特烦恼</span><br><span class="line">  				#3 node.js,180元 #</span><br><span class="line">				`;</span><br><span class="line">        let lessons = str.match(/^\s*#.+#$/gm);</span><br><span class="line">        console.log(lessons);</span><br><span class="line">        lessons = lessons</span><br><span class="line">          .map((v) =&gt; v.replace(/\s*#\d\s*/, &quot;&quot;).replace(/\s*#\s*/, &quot;&quot;))</span><br><span class="line">          .map((v) =&gt; &#123;</span><br><span class="line">            let [name, price] = v.split(&quot;,&quot;);</span><br><span class="line">            return &#123; name, price &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        console.log(JSON.stringify(lessons, null, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p><code>s</code>单行模式，在匹配时忽略<code>换行符</code>，结合<code>.</code>能够匹配所有字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#96;</span><br><span class="line">      ashuntefannao.com</span><br><span class="line">      999999999</span><br><span class="line">      !@#$%^&amp;*()_+-</span><br><span class="line">&#96;;</span><br><span class="line">console.log(str.match(&#x2F;.+&#x2F;gs));</span><br></pre></td></tr></table></figure>



<h4 id="u"><a href="#u" class="headerlink" title="u"></a>u</h4><ul>
<li>每个字符都有属性，如<code>L</code>属性表示是字母，<code>P</code> 表示标点符号</li>
<li>其他属性简写可以访问 <a href="https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt">属性的别名</a>网站查看。</li>
<li>在正则中，使用<code>\p&#123;prop&#125;</code>来匹配对应属性的字符</li>
<li><code>\p&#123;prop&#125;</code>需要结合 <code>u</code> 模式才有效。</li>
</ul>
<p>字符也有unicode文字系统属性 <code>Script=文字系统</code>，下面是使用 <code>\p&#123;sc=Han&#125;</code> 获取中文字符 <code>han</code>为中文系统，其他语言请查看 <a href="http://www.unicode.org/standard/supported.html">文字语言表</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let user &#x3D; &#96;</span><br><span class="line">        阿顺-157******01</span><br><span class="line">        张三-132******88</span><br><span class="line"> &#96;;</span><br><span class="line">let reg &#x3D; &#x2F;\p&#123;sc&#x3D;Han&#125;+&#x2F;gu;</span><br><span class="line">console.log(user.match(reg));</span><br></pre></td></tr></table></figure>

<p>使用 <code>u</code> 模式可以正确处理四个字符的 UTF-16 字节编码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;𝒳𝒴&quot;;</span><br><span class="line">console.table(str.match(/[𝒳𝒴]/)); //结果为乱字符&quot;�&quot;</span><br><span class="line"></span><br><span class="line">console.table(str.match(/[𝒳𝒴]/u)); //结果正确 &quot;𝒳&quot;</span><br></pre></td></tr></table></figure>



<h4 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h4><p><code>reg.lastIndex</code> 可以返回或者设置正则表达式<code>开始匹配的位置</code></p>
<ul>
<li><strong>必须结合 <code>g</code>或<code>y</code> 模式使用</strong></li>
<li><strong>只对 <code>exec</code> 方法有效</strong></li>
<li><strong>使用 <code>exec</code> 匹配完所有结果时，<code>lastIndex</code> 会被重置为0</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">        let text = `阿顺特烦恼希望大家没有烦恼,阿顺不喜欢烦恼`;</span><br><span class="line">        let reg = /阿顺(.&#123;2&#125;)/g;</span><br><span class="line">        reg.lastIndex = 10; //从索引10开始搜索</span><br><span class="line">        console.log(reg.exec(text));</span><br><span class="line">        console.log(reg.lastIndex); //上次匹配的结束位置+1=下次匹配的开始位置:18</span><br><span class="line"></span><br><span class="line">        reg = /\p&#123;sc=Han&#125;/gu;</span><br><span class="line">        while ((res = reg.exec(text))) &#123;</span><br><span class="line">          console.log(res[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(reg.lastIndex);	//匹配完所有结果，lastIndex重置为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reg.lastIndex</code>只对<code>reg.exec</code>有效，对<code>str.match()</code>毫无影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let str &#x3D; &quot;ashuntefannao&quot;;</span><br><span class="line">      let reg &#x3D; &#x2F;a&#x2F;g;</span><br><span class="line">      reg.lastIndex &#x3D; 11;</span><br><span class="line">      console.log(str.match(reg)); &#x2F;&#x2F;[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="y"><a href="#y" class="headerlink" title="y"></a>y</h4><p>我们来对比 <code>y</code> 与<code>g</code> 模式，在结合<code>lastIndex</code>时的使用差异。</p>
<ul>
<li>使用 <code>g</code> 模式会全局匹配，从头查到尾，一直匹配字符串</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let str = &quot;ashuntefannao&quot;;</span><br><span class="line">        let reg = /a/g;</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //1</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //9</span><br><span class="line">        console.log(reg.exec(str));</span><br><span class="line">        console.log(reg.lastIndex); //12</span><br><span class="line">        console.log(reg.exec(str)); //null</span><br><span class="line">        console.log(reg.lastIndex); //0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但使用<code>y</code> 模式后如果从 <code>lastIndex</code> 开始匹配不成功就不继续匹配了 ，匹配结束<code>lastIndex</code>也会置为0</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;fannao&quot;;</span><br><span class="line">let reg = /a/y;</span><br><span class="line">reg.lastIndex = 1;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">console.log(reg.lastIndex); //2</span><br><span class="line">console.log(reg.exec(str)); //null</span><br><span class="line">console.log(reg.lastIndex); //0</span><br></pre></td></tr></table></figure>

<p>因为使用 <code>y</code> 模式可以在<code>lastIndex</code>匹配不到时停止匹配，起到及时止损的作用，在匹配下面字符中的qq时可以提高匹配效率</p>
<ul>
<li>如果提前知道匹配目标 <strong><code>是连续在一起的</code></strong> 那么使用<code>y</code>模式会更加的高效</li>
<li>但由于需要结合<code>lastIndex</code>,所以只能够使用<code>reg.exec</code>结合循环匹配。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let title = `阿顺特烦恼QQ群:11111111,999999999,88888888</span><br><span class="line">        阿顺特烦恼希望大家没有烦恼,阿顺不喜欢烦恼`;</span><br><span class="line"></span><br><span class="line">        let reg = /(\d+),?/y;</span><br><span class="line">        reg.lastIndex = 9;</span><br><span class="line">        while ((res = reg.exec(title))) console.log(res[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="原子表"><a href="#原子表" class="headerlink" title="原子表"></a>原子表</h3><p>在一组字符中匹配某个元字符，在正则表达式中通过元字符表来完成，就是放到<code>[]</code> (方括号)中。</p>
<h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h4><table>
<thead>
<tr>
<th>原子表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ … ]</td>
<td>只匹配其中的一个元字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配<code>除了</code>其中所有字符的任意一个元字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配0-9任何一个数字</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配小写a-z任何一个字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配大写A-Z任何一个字母</td>
</tr>
</tbody></table>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>使用<code>[]</code>匹配其中任意字符即成功，下例中匹配<code>Af</code>其中一个字符，而不会当成一个整体来对待</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const title = &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log(/Af/.test(title)); //false</span><br><span class="line">console.log(/[Af]/.test(title)); //true</span><br></pre></td></tr></table></figure>

<p>日期的匹配</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let time = &quot;2022-02-23&quot;;</span><br><span class="line">console.log(time.match(/\d&#123;4&#125;([-\/])\d&#123;2&#125;\1\d&#123;2&#125;/));</span><br></pre></td></tr></table></figure>

<p>获取<code>0~3</code>间的任意数字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const num = &quot;2&quot;;</span><br><span class="line">console.log(/[0-3]/.test(num)); //true</span><br></pre></td></tr></table></figure>

<p>匹配<code>a~f</code>间的任意字符</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const char = &quot;e&quot;;</span><br><span class="line">console.log(/[a-f]/.test(char)); //true</span><br></pre></td></tr></table></figure>

<p>顺序必须为<code>升序</code>，否则将报错</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const num = &quot;2&quot;;</span><br><span class="line">console.log(/[3-0]/.test(num)); //SyntaxError</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &quot;ashuntefannao&quot;;</span><br><span class="line">console.log(/[f-a]/.test(as)); //SyntaxError</span><br></pre></td></tr></table></figure>

<p><code>排除法 ^ </code>获取所有用户名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = `</span><br><span class="line">张三:010-99999999,李四:020-88888888`;</span><br><span class="line">let res = user.match(/[^\s:\d\-,]+/g);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>[\s\S]</code> 或 <code>[\d\D]</code>等等，匹配到所有字符包括换行符</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const reg = /[\s\S]+/g;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是使用原子表知识删除所有标题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;div id=&quot;content&quot;&gt;</span><br><span class="line"> 			ashuntefannao</span><br><span class="line"> 			&lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line"> 		&lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;ASHUN&lt;/h2&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let html = document.body;</span><br><span class="line">        console.log(html.innerHTML.match(/^\s*&lt;(h[0-6])&gt;.*&lt;\/\1&gt;\s*$/gm));</span><br><span class="line"></span><br><span class="line">        html.innerHTML = html.innerHTML.replace(</span><br><span class="line">          /^\s*&lt;(h[0-6])&gt;.*&lt;\/\1&gt;\s*$/gm,</span><br><span class="line">          &quot;&quot;</span><br><span class="line">        );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="不需要转义的字符"><a href="#不需要转义的字符" class="headerlink" title="不需要转义的字符"></a>不需要转义的字符</h5><p>有些字符在正则中具有特殊含义，但是在原子组中却不用转义，只视为普通字符。</p>
<ul>
<li><code>|</code> ,  原子表中的<code>|</code>只是普通字符，不是选择符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;ASHUN|as&quot;.match(&#x2F;[a|A]&#x2F;g)); &#x2F;&#x2F;[&quot;A&quot;, &quot;|&quot;, &quot;a&quot;]</span><br><span class="line">console.log(&quot;ASHUN|as&quot;.match(&#x2F;(a|A)&#x2F;g)); &#x2F;&#x2F;[&quot;A&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code>  在原子表中也没有特殊含义，只是普通的字符<code>&quot;.&quot;</code>。</li>
<li><code>+</code>  在原子表中也只是普通字符<code>&quot;+&quot;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(site.match(&#x2F;[\w+.\w+]&#x2F;g).join(&quot;&quot;));</span><br><span class="line">console.log(site.match(&#x2F;[\w.]&#x2F;g).join(&quot;&quot;));</span><br></pre></td></tr></table></figure>

<p>若想使用这些特殊含义的字符，可以使用原子组<code>()</code>结合选择符<code>|</code>，让匹配形成<code>或</code>的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(site.match(&#x2F;(\w+|\.)&#x2F;g));</span><br><span class="line">console.log(site.match(&#x2F;(.+)&#x2F;g));</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="原子组"><a href="#原子组" class="headerlink" title="原子组"></a>原子组</h3><ul>
<li>如果一次要匹配多个元子，可以通过元子组完成</li>
<li>原子组与原子表的差别在于原子组一次匹配多个元子，而原子表则是匹配任意一个字符，而且原子组配合其它的方法，能够完成给更多的功能</li>
<li>元字符组用 <code>()</code> 包裹</li>
</ul>
<p>下面使用原子组匹配 <code>h1</code> 标签，如果想匹配 <code>h2</code> 只需要把前面原子组改为 <code>h2</code> 即可。</p>
<ul>
<li>匹配结束标签时的 <code>\1</code> 意为：应用第一个原子组匹配到的内容</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const dom = `&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;`;</span><br><span class="line">console.log(/&lt;(h1)&gt;.+&lt;\/\1&gt;/.test(hd)); //true</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>没有使用 <code>g</code> 模式时，自前向后只匹配到第一个，使用<code>str.match\reg.exec</code>方法 匹配到的信息包含以下数据</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>匹配到的完整内容</td>
</tr>
<tr>
<td>1,2….</td>
<td>匹配到的各个原子组内容</td>
</tr>
<tr>
<td>index</td>
<td>匹配到的str在原字符串中的位置</td>
</tr>
<tr>
<td>input</td>
<td>原字符串</td>
</tr>
<tr>
<td>groups</td>
<td>命名分组</td>
</tr>
</tbody></table>
<img src="正则表达式.assets/RegExp_1.png" alt="RegExp_1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let title &#x3D; &quot;&lt;h3&gt;Ashun阿顺&lt;&#x2F;h3&gt;&quot;;</span><br><span class="line">      let reg &#x3D; &#x2F;&lt;(h[0-9])&gt;(.+)&lt;\&#x2F;\1&gt;&#x2F;;</span><br><span class="line">      console.log(title.match(reg));</span><br><span class="line">      console.log(reg.exec(title));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(as.match(/fan(nao)\.(com)/));</span><br><span class="line">//[&quot;fannao.com&quot;, &quot;nao&quot;, &quot;com&quot;, index: 7, input: &quot;Ashuntefannao.com&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>



<p>下面使用原子组匹配标题元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let content = `</span><br><span class="line">        &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">        &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">        &lt;h2&gt;Ashun&lt;/h2&gt;</span><br><span class="line">      `;</span><br><span class="line"></span><br><span class="line">        console.table(content.match(/&lt;(h[1-6])[\s\S]*&lt;\/\1&gt;/g));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，在匹配标签对内容时，匹配的是任意字符，但是这样在同级别标题连续时，就会出错。</p>
<p>会将<code>&lt;h1&gt;阿顺特烦恼&lt;/h1&gt; \n &lt;h1&gt;ashun&lt;/h1&gt;</code>视为<code>&lt;h1&gt;阿顺……ashun&lt;/h1&gt;</code>，两个标签的匹配结果只有一项</p>
<ul>
<li>应该排除换行符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let content &#x3D; &#96;</span><br><span class="line">        &lt;h1&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;Ashuntefannao&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;span&gt;阿顺&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;h2&gt;Ashun&lt;&#x2F;h2&gt;</span><br><span class="line">      &#96;;</span><br><span class="line"></span><br><span class="line">        console.table(content.match(&#x2F;&lt;(h[1-6])[\s\S]*&lt;\&#x2F;\1&gt;&#x2F;g));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;标签内容应该排除换行符</span><br><span class="line">        console.table(content.match(&#x2F;&lt;(h[1-6]).*&lt;\&#x2F;\1&gt;&#x2F;g));</span><br><span class="line">        console.table(content.match(&#x2F;^\s*&lt;(h[1-6]).*&lt;\&#x2F;\1&gt;\s*$&#x2F;gm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测 <code>0~100</code> 的数值，使用 <code>parseInt</code> 将数值转为10进制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(/^(\d&#123;1,2&#125;|100)$/.test(parseInt(09, 10)));</span><br></pre></td></tr></table></figure>



<h4 id="邮箱匹配"><a href="#邮箱匹配" class="headerlink" title="邮箱匹配"></a>邮箱匹配</h4><p>下面使用原子组匹配邮箱</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let email = &quot;2300071698@qq.com&quot;;</span><br><span class="line">let reg = /^[\w\-]+@[\w\-]+\.(com|org|cn|cc|net)$/i;</span><br><span class="line">console.dir(email.match(reg));</span><br></pre></td></tr></table></figure>

<p>如果邮箱是以下格式 <code>Ashuntefannao@as.com.cn</code> 上面规则将无效，需要定义以下方式</p>
<ul>
<li>将<code>xxx.</code>这样的后缀，封装为分子组，匹配一个或多个</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let email = `admin@Ashun.com.cn`;</span><br><span class="line">let reg = /^[\w-]+@([\w-]+\.)+(org|com|cc|cn)$/;</span><br><span class="line">console.log(email.match(reg));</span><br></pre></td></tr></table></figure>





<h4 id="引用原子组"><a href="#引用原子组" class="headerlink" title="引用原子组"></a>引用原子组</h4><ul>
<li><code>\number</code> 在<strong>匹配</strong>时引用第<code>number</code>个原子组匹配的数据</li>
<li><code>$number</code> 在<strong>替换</strong>时引用第<code>number</code>个原子组匹配的数据。</li>
</ul>
<p>下面将 标题标签 替换为 <code>p</code>标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let content = `</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">  &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;SHUN&lt;/h2&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /&lt;(h[1-6])&gt;(.*)&lt;\/\1&gt;/gi;</span><br><span class="line">console.log(content.replace(reg, `&lt;p&gt;$2&lt;/p&gt;`));</span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title="? :"></a>? :</h4><p>如果希望原子组<strong>只参与匹配，不返回到结果当中</strong>，可使用 <code>?:</code> 处理。<code>:?</code>置于原子组头部。</p>
<p>下面是获取所有域名的示例</p>
<ul>
<li>由于下面第二层嵌套的原子组都使用<code>?:</code>处理，则在返回结果中，便没有了属性<code>2~n</code>，但有属性<code>1</code>返回第一层原子组匹配到的域名部分</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let webs = `</span><br><span class="line">  https://www.Ashuntefannao.com</span><br><span class="line">  http://Ashunwang.com</span><br><span class="line">  https://Ashun.com</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /https?:\/\/((?:\w+\.)?\w+\.(?:com|org|cn))/gi;</span><br><span class="line">while ((v = reg.exec(webs))) &#123;</span><br><span class="line">  console.dir(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="别名-lt-gt"><a href="#别名-lt-gt" class="headerlink" title="别名?&lt;&gt;"></a>别名?&lt;&gt;</h4><p>默认情况下，在不使用<code>g</code>模式时，并结合<code>str.match/reg.exec</code>方法时，各原子组匹配的结果将会存储到<code>1~n</code>属性中，但如果原子组过多，也就代表RegExp越复杂，就越不容易找到对应的原子组匹配结果。</p>
<p>如果希望返回的组数据更清晰，可以为原子组命名，结果将保存在返回的 <code>groups</code>字段中</p>
<ul>
<li>语法<code>?&lt;alia&gt;</code>,将其置于原子组头部即可</li>
</ul>
<img src="正则表达式.assets/RegExp_2.png" alt="RegExp_2" style="zoom:80%;" />

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let title = &quot;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&quot;;</span><br><span class="line">console.dir(title.match(/&lt;(?&lt;tag&gt;h[1-6])(?&lt;content&gt;.*)&lt;\/\1&gt;/));</span><br></pre></td></tr></table></figure>



<h5 id="引用别名原子组"><a href="#引用别名原子组" class="headerlink" title="引用别名原子组"></a>引用别名原子组</h5><p>别名不能在参与匹配时引用，若想引用对应原子组，还是通过<code>\number</code>进行引用</p>
<ul>
<li><code>\number</code>，参与匹配时引用</li>
<li><code>$&lt;alia&gt;</code>，参与替换时使用</li>
</ul>
<p>组别名使用 <code>?&lt;&gt;</code> 形式定义，下面将标签替换为<code>p</code>标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let txt = `</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">  &lt;span&gt;阿顺&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;SHUN&lt;/h2&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /&lt;(?&lt;tag&gt;h[1-6])&gt;(?&lt;content&gt;[\s\S]*)&lt;\/\1&gt;/gi;</span><br><span class="line">console.log(txt.replace(reg, `&lt;p&gt;$&lt;content&gt;&lt;/p&gt;`));</span><br></pre></td></tr></table></figure>

<p>获取链接与网站名称组成数组集合</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;a href=&quot;https://astfn.github.io&quot;&gt;AshunBlog&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://www.hdcms.com&quot;&gt;hdcms&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://www.sina.com.cn&quot;&gt;新浪&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   let body = document.body;</span><br><span class="line">   let reg = /^\s*&lt;a.+href=.*(?&lt;link&gt;https?:\/\/([-\w]+\.)+(?:cn|com|org|cc|github|io)).*&gt;(?&lt;name&gt;.*)&lt;\/a&gt;\s*$/gim;</span><br><span class="line">    let arr = [];</span><br><span class="line">    while ((exec = reg.exec(body.innerHTML))) &#123;</span><br><span class="line">      arr.push(exec[&quot;groups&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>如果要重复匹配一些内容时我们要使用重复匹配修饰符，包括以下几种。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>重复匹配可以应用于:</p>
<ul>
<li>单个字符</li>
<li>原子表</li>
<li>原子组</li>
</ul>
<blockquote>
<p>因为正则最小单位是元字符，而我们很少只匹配一个元字符如a、b所以基本上重复匹配在每条正则语句中都是必用到的内容。</p>
</blockquote>
<p>默认情况下,重复选项对单个字符进行重复匹配，是贪婪匹配，一只匹配到不重复为止。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;assshun&quot;;</span><br><span class="line">console.log(as.match(/as+/i)); //asss</span><br></pre></td></tr></table></figure>

<p>使用原子组后则对整个组重复匹配</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;ashunAshuntefannao&quot;;</span><br><span class="line">console.log(as.match(/(ashun)+/i)); //ashunAshun</span><br></pre></td></tr></table></figure>

<p>下面是验证坐机号的正则</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let tell = &quot;010-12345678&quot;;</span><br><span class="line">console.log(/^0\d&#123;2,3&#125;-\d&#123;7,8&#125;$/.exec(tell));</span><br></pre></td></tr></table></figure>

<p>验证用户名只能为3~8位的字母或数字，并以字母开始</p>
<ul>
<li>像这种严格约束的正则，需要用<code>^…$</code>进行约束，若不使用其进行约束，那么如果用户名符合字母\数字，但是位数超过8位，也能匹配成功，只不过只返回前8位。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#123;</span><br><span class="line">        let input = document.querySelector(&quot;[name=&#x27;username&#x27;]&quot;);</span><br><span class="line">        let reg = /^[a-zA-Z](\d|[a-zA-Z])&#123;2,7&#125;$/;</span><br><span class="line">        input.addEventListener(&quot;input&quot;, function () &#123;</span><br><span class="line">          console.log(reg.test(this.value) ? &quot;正确&quot; : &quot;错误&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>验证密码必须包含大写字母并在5~10位之间</p>
<ul>
<li>多种验证组合，可以将regexp置于数组中，遍历数组过程中对str进行判断</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let input = document.querySelector(`[name=&quot;password&quot;]`);</span><br><span class="line">input.addEventListener(&quot;keyup&quot;, e =&gt; &#123;</span><br><span class="line">  const value = e.target.value.trim();</span><br><span class="line">  const regs = [/^[a-zA-Z0-9]&#123;5,10&#125;$/, /[A-Z]/];</span><br><span class="line">  let state = regs.every(v =&gt; v.test(value));</span><br><span class="line">  console.log(state ? &quot;正确！&quot; : &quot;密码必须包含大写字母并在5~10位之间&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="禁止贪婪"><a href="#禁止贪婪" class="headerlink" title="禁止贪婪"></a>禁止贪婪</h4><p>正则表达式在进行重复匹配时，<strong>默认是贪婪匹配模式</strong>，也就是说会尽量匹配更多内容，但是有的时候我们并不希望他匹配更多内容，这时可以通过 <strong><code>?</code></strong> 对 重复匹配语法 进行修饰，会尽可能的少匹配。</p>
<table>
<thead>
<tr>
<th>使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>0个或多个，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>1个或多个，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>0个或1个，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>n~m个，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>&gt;=n个，但尽可能少重复</td>
</tr>
</tbody></table>
<p>下面是禁止贪婪的语法例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let str &#x3D; &quot;assshun&quot;;</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as+?&#x2F;;      &#x2F;&#x2F;as</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as*?&#x2F;;      &#x2F;&#x2F;a</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as??&#x2F;;      &#x2F;&#x2F;a</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as&#123;2,&#125;?&#x2F;;   &#x2F;&#x2F;ass</span><br><span class="line">     &#x2F;&#x2F; let reg &#x3D; &#x2F;as&#123;2,3&#125;?&#x2F;;  &#x2F;&#x2F;ass</span><br><span class="line"></span><br><span class="line">     console.log(str.match(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有span更换为<code>h5</code> 并描红，并在内容前加上 <code>阿顺-</code></p>
<ul>
<li>之前我们提到过，在匹配标签时，标签对的内容要忽略换行符，为了避免同名标签连续时，合并匹配的情况</li>
<li>其实我们也可使用禁止贪婪，来进行约束，并且禁止贪婪情况下，也就不必使用<code>m</code>模式配合<code>^$</code>进行严格约束了。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;span&gt;ashunwang&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;ashun.com&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;ashuntefannao.com&lt;/span&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg = /&lt;span&gt;([\s\S]+?)&lt;\/span&gt;/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(reg, (v, p1) =&gt; &#123;</span><br><span class="line">    console.log(p1);</span><br><span class="line">    return `&lt;h4 style=&quot;color:red&quot;&gt;后盾人-$&#123;p1&#125;&lt;/h4&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是使用禁止贪婪查找页面中的标题元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> 		&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">      ashuntefannao</span><br><span class="line">      &lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;ashuntefannao&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;ASHUN&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#123;</span><br><span class="line">        let body = document.body.innerHTML;</span><br><span class="line">        let reg = /&lt;(h[1-6])&gt;[\s\S]*?&lt;\/\1&gt;/gi;</span><br><span class="line">        // let reg = /^\s*?&lt;(h[1-6])&gt;[\s\S]*?&lt;\/\1&gt;\s*?$/gim;</span><br><span class="line">        console.table(body.match(reg));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="细节返回"><a href="#细节返回" class="headerlink" title="细节返回"></a>细节返回</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>通过之前的使用，我们知道<code>str.match</code>方法：</p>
<ul>
<li>在非<code>g</code>全局匹配模式下，只返回一个匹配结果，并且包含匹配细节参数</li>
<li>在<code>g</code>模式下，返回一个包含所有匹配内容的Array，但是每个元素不包含匹配细节</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function elem(tag) &#123;</span><br><span class="line">    const reg = new RegExp(`&lt;($&#123;tag&#125;).*&gt;.+?&lt;/\\1&gt;`, &quot;g&quot;);</span><br><span class="line">    return document.body.innerHTML.match(reg);</span><br><span class="line">  &#125;</span><br><span class="line">  console.table(elem(&quot;h1&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll"></a>matchAll</h4><p>在<strong>新版本浏览器</strong>中支持使用 <code>matchAll</code> 操作，并返回迭代对象</p>
<blockquote>
<p>需要添加 <code>g</code> 修饰符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let str &#x3D; &quot;as&quot;;</span><br><span class="line">     let reg &#x3D; &#x2F;.&#x2F;g;</span><br><span class="line">     let iterator &#x3D; str.matchAll(reg);</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:Array(1), done:false &#125;</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:Array(1), done:false &#125;</span><br><span class="line">     console.log(iterator.next()); &#x2F;&#x2F;&#123; value:undefined, done:true &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可迭代对象可使用<code>for/of</code>遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao&quot;;</span><br><span class="line">let reg = /[a-z]/ig;</span><br><span class="line">for (const iterator of str.matchAll(reg)) &#123;</span><br><span class="line">  console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原型定义 <code>matchAll</code>方法，用于在旧浏览器中工作，不需要添加<code>g</code> 模式运行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        String.prototype.matchAll = function (reg) &#123;</span><br><span class="line">          let match = this.match(reg);</span><br><span class="line">          if (match) &#123;</span><br><span class="line">            let str = this.replace(reg, &quot;^&quot;.repeat(match[0].length));</span><br><span class="line">            let matchArr = str.matchAll(reg) || [];</span><br><span class="line">            return [match, ...matchArr];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        let reg = /a/;</span><br><span class="line">        console.log(&quot;ashuna&quot;.matchAll(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>使用 <code>g</code> 模式修正符并结合 <code>exec</code> 循环操作可以获取结果和匹配细节</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;Ashun.com&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function search(string, reg) &#123;</span><br><span class="line">    const matchs = [];</span><br><span class="line">    while ((data = reg.exec( string))) &#123;</span><br><span class="line">      matchs.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">    return matchs;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(search(document.body.innerHTML, /&lt;(h[1-6]).*?&gt;[\s\S]+?&lt;\/\1&gt;/gi));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用上面定义的函数来检索字符串中的网址</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let sites = `https://ashunwang.com  </span><br><span class="line">https://www.sina.com.cn</span><br><span class="line">https://astfn.github.io`;</span><br><span class="line"></span><br><span class="line">let res = search(sites, /https?:\/\/(\w+\.)?(\w+\.)+(com|cn|io)/gi);</span><br><span class="line">console.dir(res);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>下面介绍的方法是 <code>String</code> 提供的支持正则表达式的方法</p>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p><code>search(str/reg)</code> 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索，返回值为索引位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(str.search(&quot;.com&quot;));</span><br></pre></td></tr></table></figure>

<p>使用正则表达式搜索</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(str.search(/\.com/i));</span><br></pre></td></tr></table></figure>

<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>直接使用字符串搜索</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(str.match(&quot;com&quot;));</span><br></pre></td></tr></table></figure>

<p>使用正则获取内容，下面是简单的搜索字符串, 非<code>g</code>模式下，只匹配一次，且返回详细参数信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;Ashuntefannao&quot;;</span><br><span class="line">let res = as.match(/a/i);</span><br><span class="line">console.log(res);</span><br><span class="line">console.log(res[0]); //匹配的结果</span><br><span class="line">console.log(res[index]); //出现的位置</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>g</code> 修饰符时，就不会有结果的详细信息了（可以使用exec），下面是获取所有h1~6的标题元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let body = document.body.innerHTML;</span><br><span class="line">let result = body.match(/&lt;(h[1-6]).*?&gt;[\s\S]+?&lt;\/\1&gt;/g);</span><br><span class="line">console.table(result);</span><br></pre></td></tr></table></figure>

<h4 id="matchAll-1"><a href="#matchAll-1" class="headerlink" title="matchAll"></a>matchAll</h4><p>在新浏览器中支持使用 <code>matchAll</code> 结合<code>g</code>模式操作，并返回迭代对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao&quot;;</span><br><span class="line">let reg = /[a-z]/ig;</span><br><span class="line">for (const iterator of str.matchAll(reg)) &#123;</span><br><span class="line">  console.log(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>用于使用字符串或正则表达式分隔字符串，下面是使用字符串分隔日期</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;2023-02-12&quot;;</span><br><span class="line">console.log(str.split(&quot;-&quot;)); //[&quot;2023&quot;, &quot;02&quot;, &quot;12&quot;]</span><br></pre></td></tr></table></figure>

<p>如果日期的连接符不确定，那就要使用正则操作了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;2023/02-12&quot;;</span><br><span class="line">console.log(str.split(/-|\//));</span><br></pre></td></tr></table></figure>



<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><code>replace</code> 方法不仅可以执行基本字符替换，也可以进行正则替换，下面替换日期连接符</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;2023/02/12&quot;;</span><br><span class="line">console.log(str.replace(/\//g, &quot;-&quot;)); //2023-02-12</span><br></pre></td></tr></table></figure>

<p>替换字符串可以插入下面的特殊变量名：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$$</td>
<td>插入一个 “$”。</td>
</tr>
<tr>
<td>$&amp;</td>
<td>插入匹配的结果。</td>
</tr>
<tr>
<td>$`</td>
<td>插入当前匹配的子串左边的内容。</td>
</tr>
<tr>
<td>$’</td>
<td>插入当前匹配的子串右边的内容。</td>
</tr>
<tr>
<td>$n</td>
<td>假如第一个参数是 <code>RegExp</code> ，并且 n 是个小于100的非负整数，则<code>$n</code>意为：插入第 n 个原子组匹配的字符串。提示：索引是从1开始</td>
</tr>
<tr>
<td>$&lt;alia&gt;</td>
<td>与<code>$n</code>类似，也是插入原子组匹配的内容，但<code>$&lt;alia&gt;</code>是通过别名锁定对应原子组</td>
</tr>
</tbody></table>
<p>在”阿顺”前后再分别添加2个<code>=</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &quot;=阿顺=&quot;;</span><br><span class="line">console.log(as.replace(/阿顺/g, &quot;$`$`$&amp;$&#x27;$&#x27;&quot;)); // ===阿顺===</span><br></pre></td></tr></table></figure>

<p>把电话号用 <code>-</code> 连接</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let tell = &quot;(010)99999999 (020)8888888&quot;;</span><br><span class="line">console.log(tell.replace(/\((\d&#123;3,4&#125;)\)(\d&#123;7,8&#125;)/g, &quot;$1-$2&quot;));</span><br></pre></td></tr></table></figure>

<p>把所有<code>阿顺</code>关键字加上链接 <code>https://www.Ashuntefannao.com</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const body = document.body;</span><br><span class="line">  body.innerHTML = body.innerHTML.replace(</span><br><span class="line">    /阿顺/g,</span><br><span class="line">    `&lt;a href=&quot;https://www.Ashuntefannao.com&quot;&gt;$&amp;&lt;/a&gt;`</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a><strong>回调函数</strong></h5><p>replace 支持回调函数操作，用于处理复杂的替换逻辑，回调函数参数与<code>str.match\str.matchAll\reg.exec</code>返回的详细参数是对应的。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>代表的值</th>
</tr>
</thead>
<tbody><tr>
<td><code>str</code></td>
<td>匹配的子串。（对应于上述的$&amp;。）</td>
</tr>
<tr>
<td><code>p1,p2, ...</code></td>
<td>假如replace()方法的第一个参数是一个 <code>RegExp</code> ，则代表第n个原子组匹配的字符串。</td>
</tr>
<tr>
<td><code>index</code></td>
<td>匹配到的子字符串在原字符串中的索引。（比如，如果原字符串是 <code>&#39;abcd&#39;</code>，匹配到的子字符串是 <code>&#39;bc&#39;</code>，那么这个参数将会是 1）</td>
</tr>
<tr>
<td><code>source</code></td>
<td>被匹配的原字符串。</td>
</tr>
<tr>
<td>NamedCaptureGroup</td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<p>将关于ashun的链接协议全部置为<code>https</code> ，并补全 <code>www.</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;a style=&quot;color: red&quot; href=&quot;http://www.ashun.com&quot;&gt; 阿顺 &lt;/a&gt;</span><br><span class="line">    &lt;a id=&quot;l1&quot; href=&quot;http://Ashuntefannao.com&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://yahoo.com&quot;&gt;雅虎&lt;/a&gt;</span><br><span class="line">    &lt;h4&gt;http://www.ashun.com&lt;/h4&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#123;</span><br><span class="line">        let reg = /(&lt;a.*?)(http)?(:\/\/)(www\.)?(Ashuntefannao|ashun)/g;</span><br><span class="line">        let body = document.body;</span><br><span class="line">        body.innerHTML = body.innerHTML.replace(reg, (val, ...args) =&gt; &#123;</span><br><span class="line">          args[1] = &quot;https&quot;;</span><br><span class="line">          args[3] = args[3] || &quot;www.&quot;;</span><br><span class="line">          return args.slice(0, 5).join(&quot;&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(body.innerHTML.match(reg));</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将标题标签全部替换为 <code>p</code> 标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const reg = /&lt;(h[1-6])&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line">  const body = document.body.innerHTML;</span><br><span class="line">  const html = body.replace(reg, function(str, tag, content) &#123;</span><br><span class="line">    return `&lt;p&gt;$&#123;content&#125;&lt;/p&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">  document.body.innerHTML = html;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>删除页面中的 <code>h1~h6</code> 标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  &lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const reg = /&lt;(h[1-6])&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line">  const body = document.body.innerHTML;</span><br><span class="line">  const html = body.replace(reg, &quot;&quot;);</span><br><span class="line">  document.body.innerHTML = html;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用回调函数将 <code>阿顺</code> 添加上链接</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼,阿顺讨厌烦恼</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  content.innerHTML = content.innerHTML.replace(&quot;阿顺&quot;, function(</span><br><span class="line">    search,</span><br><span class="line">    index,</span><br><span class="line">    source</span><br><span class="line">  ) &#123;</span><br><span class="line">    return `&lt;a href=&quot;https://www.Ashuntefannao.com&quot;&gt;$&#123;search&#125;&lt;/a&gt;`;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>为所有标题添加上 <code>hot</code> 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Ashuntefannao.com&lt;/h1&gt;</span><br><span class="line">  	&lt;h2&gt;ashun.com&lt;/h2&gt;</span><br><span class="line">  	&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  let reg = /&lt;(h[1-6])(.*?)&gt;([\s\S]*?)&lt;\/\1&gt;/gi;</span><br><span class="line">  content.innerHTML = content.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    (</span><br><span class="line">      search, //匹配到的字符</span><br><span class="line">      p1, //第一个原子组</span><br><span class="line">      p2, //第二个原子组</span><br><span class="line">      p3, //第三个原子组</span><br><span class="line">      index, //索引位置</span><br><span class="line">      source //原字符</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      return `</span><br><span class="line">    &lt;$&#123;p1&#125;$&#123;p2&#125; class=&quot;hot&quot;&gt;$&#123;p3&#125;&lt;/$&#123;p1&#125;&gt;</span><br><span class="line">    `;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h3><p>下面是 <code>RegExp</code> 正则对象提供的操作方法</p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><code>reg.test(str)</code>用于判断str是否符合匹配条件，返回Boolean</p>
<p>检测输入的邮箱是否合法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let email = document.querySelector(`[name=&quot;email&quot;]`);</span><br><span class="line">  email.addEventListener(&quot;keyup&quot;, e =&gt; &#123;</span><br><span class="line">    console.log(/^\w+@\w+\.\w+$/.test(e.target.value));</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="exec-1"><a href="#exec-1" class="headerlink" title="exec"></a>exec</h4><p>配合 <code>g</code> 模式使用时，<code>reg.exec(str)</code>可以循环调用直到全部匹配完。</p>
<ul>
<li>配合 <code>g</code> 模式使用时，应一直操作同一个正则，即把正则定义为变量使用，这样才能够不断的向后匹配</li>
<li>使用 <code>g</code> 修饰符最后匹配不到时返回 <code>null</code></li>
</ul>
<p>计算内容中阿顺出现的次数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼	--阿顺</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let content = document.querySelector(&quot;.content&quot;);</span><br><span class="line">  let reg = /(?&lt;tag&gt;阿顺)/g;</span><br><span class="line">  let num = 0;</span><br><span class="line">  while ((result = reg.exec(content.innerHTML))) &#123;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`阿顺共出现$&#123;num&#125;次`);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="断言匹配"><a href="#断言匹配" class="headerlink" title="断言匹配"></a>断言匹配</h3><p>断言虽然写在扩号中但<code>它不是组</code>，所以<strong>不会在匹配结果中保存</strong>，可以将断言理解为<code>正则中的条件</code>。</p>
<table>
<thead>
<tr>
<th>断言匹配语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>(?=exp)</td>
<td>将其放置于匹配内容的后面，用于约束后面的匹配内容</td>
</tr>
</tbody></table>
<h4 id="exp"><a href="#exp" class="headerlink" title="(?=exp)"></a>(?=exp)</h4><p><strong>零宽先行断言</strong> <code>(?=exp)</code> 匹配后面为 <code>exp</code> 的内容</p>
<p>把后面内容为<code>特烦恼</code> 的<code>阿顺</code>加上链接.</p>
<ul>
<li>断言匹配的结果不会返回到内容当中，以下replace接收到的第一个参数只有<code>阿顺</code></li>
<li>断言匹配，只是一个约束条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼。</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main &#x3D; document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg &#x3D; &#x2F;阿顺(?&#x3D;特烦恼)&#x2F;gi;</span><br><span class="line">  main.innerHTML &#x3D; main.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    v &#x3D;&gt; &#96;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;Ashuntefannao.com&quot;&gt;$&#123;v&#125;&lt;&#x2F;a&gt;&#96;</span><br><span class="line">  );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是将价格后面 添加上 <code>.00</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let lessons = `</span><br><span class="line">    js,200元,300次</span><br><span class="line">    php,300.00元,100次</span><br><span class="line">    node.js,180元,260次</span><br><span class="line">  `;</span><br><span class="line">  let reg = /(\d+)(.00)?(?=元)/gi;</span><br><span class="line">  lessons = lessons.replace(reg, (v, ...args) =&gt; &#123;</span><br><span class="line">    args[1] = args[1] || &quot;.00&quot;;</span><br><span class="line">    return args.splice(0, 2).join(&quot;&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用断言验证用户名必须为五位，下面正则体现断言是不是组，并且不在匹配结果中记录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document</span><br><span class="line">    .querySelector(`[name=&quot;username&quot;]`)</span><br><span class="line">    .addEventListener(&quot;keyup&quot;, function() &#123;</span><br><span class="line">      let reg = /^(?=[a-z]&#123;5&#125;$)/i;</span><br><span class="line">      console.log(reg.exec(this.value));</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="lt-exp"><a href="#lt-exp" class="headerlink" title="(?&lt;=exp)"></a>(?&lt;=exp)</h4><p><strong>零宽后行断言</strong> <code>?&lt;=exp</code> 匹配前面为 <code>exp</code> 的内容</p>
<p>匹配前面是<code>Ashuntefannao</code> 的数字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashuntefannao789Ashun666&quot;;</span><br><span class="line">let reg = /(?&lt;=Ashuntefannao)\d+/i;</span><br><span class="line">console.log(str.match(reg)); //789</span><br></pre></td></tr></table></figure>

<p>匹配前后都是数字的内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let str = &quot;Ashuntefannao789Ashun123&quot;;</span><br><span class="line">        let reg = /(?&lt;=\d)[a-z]+(?=\d)/gi;</span><br><span class="line">        // let reg = /(?&lt;=\d&#123;3&#125;).+(?=\d&#123;3&#125;)/g;</span><br><span class="line">        console.log(str.match(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有a标签的超链接替换为<code>Ashuntefannao.com</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;a href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;https://yahoo.com&quot;&gt;雅虎&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const body = document.body;</span><br><span class="line">  let reg = /(?&lt;=&lt;a.*href=([&#x27;&quot;])).+?(?=\1)/gi;</span><br><span class="line">  // console.log(body.innerHTML.match(reg));</span><br><span class="line">  body.innerHTML = body.innerHTML.replace(reg, &quot;https://Ashuntefannao.com&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>把前面内容为<code>阿顺</code> 的<code>特烦恼</code>加上链接.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    阿顺特烦恼希望大家没有烦恼，阿顺讨厌烦恼。</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  const reg = /(?&lt;=阿顺)特烦恼/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(</span><br><span class="line">    reg,</span><br><span class="line">    v =&gt; `&lt;a href=&quot;https://Ashuntefannao.com&quot;&gt;$&#123;v&#125;&lt;/a&gt;`</span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将电话的后四位模糊处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let users = `</span><br><span class="line">  阿顺电话: 12345678901</span><br><span class="line">  客服电话: 98745675603</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">let reg = /(?&lt;=\d&#123;7&#125;)\d+\s*/g;</span><br><span class="line">users = users.replace(reg, str =&gt; &#123;</span><br><span class="line">  return &quot;*&quot;.repeat(4);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(users); //阿顺电话: 1234567**** 客服电话: 9874567****</span><br></pre></td></tr></table></figure>

<p>获取标题中的内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let th = `&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;`;</span><br><span class="line">let reg = /(?&lt;=&lt;h1.*?&gt;).*(?=&lt;\/h1&gt;)/g;</span><br><span class="line">console.log(th.match(reg));</span><br></pre></td></tr></table></figure>



<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="(?!exp)"></a>(?!exp)</h4><p><strong>零宽负向先行断言</strong> 后面<font color="#16a085">不能出现</font> <code>exp</code> 指定的内容</p>
<p>使用 <code>(?!exp)</code>字母后面不能为两位数字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashun12&quot;;</span><br><span class="line">let reg = /[a-z]+(?!\d&#123;2&#125;)$/i;</span><br><span class="line">console.table(reg.exec(str));</span><br></pre></td></tr></table></figure>

<p>下例为用户名中不能出现<code>阿顺</code></p>
<ul>
<li>下例中，<code>(?!exp)</code>前面什么也没有，即<code>&quot;&quot;</code>后面不准出现阿顺，也就是任意一个地方后面不能出现阿顺</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const input = document.querySelector(`[name=&quot;username&quot;]`);</span><br><span class="line">  input.addEventListener(&quot;keyup&quot;, function() &#123;</span><br><span class="line">    const reg = /^(?!.*阿顺)[(\w)(\p&#123;sc=Han&#125;)]&#123;5,6&#125;$/iu;</span><br><span class="line">    console.log(this.value.match(reg));</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="lt-exp-1"><a href="#lt-exp-1" class="headerlink" title="(?&lt;!exp)"></a>(?&lt;!exp)</h4><p><strong>零宽负向后行断言</strong> 前面<font color="#16a085">不能出现</font>exp指定的内容</p>
<p>获取前面不是数字的字符</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &quot;Ashun99shun&quot;;</span><br><span class="line">let reg = /(?&lt;!\d)[a-z]+/i;</span><br><span class="line">console.log(reg.exec(str)); //Ashun</span><br></pre></td></tr></table></figure>

<p>把所有不是以 <code>https://oss.Ashuntfn.com</code> 开始的静态资源替换为新网址</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.Ashuntfn.com/1.jpg&quot;&gt;1.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://oss.Ashuntfn.com/2.jpg&quot;&gt;2.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://cdn.Ashuntfn.com/2.jpg&quot;&gt;3.jpg&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;https://Ashuntfn.com/2.jpg&quot;&gt;3.jpg&lt;/a&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main = document.querySelector(&quot;main&quot;);</span><br><span class="line">  let reg = /https:\/\/(?&lt;!oss\.).+?(?=\/)/gi;</span><br><span class="line">  main.innerHTML = main.innerHTML.replace(reg, v =&gt; &#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">    return &quot;https://oss.Ashuntfn.com&quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>数组类型</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组是多个变量值的集合，数组是<code>Array</code> 对象的实例，所以可以像对象一样调用方法。</p>
<h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><p>使用对象方式创建数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(new Array(1, &#x27;阿顺&#x27;, &#x27;Ashun&#x27;)); //[1, &quot;阿顺&quot;, &quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>

<p>使用字面量创建是推荐的简单作法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const array = [&quot;ashun&quot;, &quot;Ashun&quot;];</span><br></pre></td></tr></table></figure>

<p>多维数组定义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const array = [[&quot;ashun&quot;], [&quot;Ashun&quot;]];					//字面量</span><br><span class="line">const arr = new Array([&quot;ashun&quot;], [&quot;Ashun&quot;]);	//构造函数</span><br><span class="line">console.log(array[1][0], arr[1][0]);  </span><br></pre></td></tr></table></figure>

<p>数组是引用类型可以使用<code>const</code>声明并修改它的值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const array = [&quot;Ashun&quot;, &quot;ashun&quot;];</span><br><span class="line">array.push(&quot;ashuntefannao&quot;);</span><br><span class="line">console.log(array);</span><br></pre></td></tr></table></figure>

<p>使用原型的 <code>length</code>属性可以获取数组元素数量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as= [&quot;Ashun&quot;, &quot;ashun&quot;];</span><br><span class="line">console.log(as.length); //2</span><br></pre></td></tr></table></figure>

<p>数组可以设置任何值，下面是使用索引添加数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = [&quot;阿顺&quot;];</span><br><span class="line">as[1] = &quot;ashun&quot;;</span><br></pre></td></tr></table></figure>

<p>下面直接设置3号数组，会将1，2索引的数组定义为空值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Arr = [&quot;ashun&quot;];</span><br><span class="line">Arr[3] = &quot;Ashun&quot;;</span><br><span class="line">console.log(Arr, Arr[2]); //[&quot;ashun&quot;, empty × 2, &quot;Ashun&quot;] undefined</span><br></pre></td></tr></table></figure>

<p>声明多个空元素的数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = new Array(3);		//仅传入一个参数且为Number，会创建对应长度的空Array</span><br><span class="line">console.log(arr.length);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>



<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p>使用<code>Array.of</code> 与 <code>new Array</code> 不同的是：仅传入一个参数且为Number，不会创建空元素的Array</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = Array.of(3);</span><br><span class="line">console.log(as); //[3]</span><br><span class="line"></span><br><span class="line">as = Array.of(1, 2, 3);</span><br><span class="line">console.log(as); //[1, 2, 3]</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h5><p>检测变量是否为数组类型</p>
<ul>
<li>内置方法<code>Array.isArray(msg)</code></li>
<li><code>instanceof</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Array.isArray(1));					//false</span><br><span class="line">console.log(Array.isArray([&quot;ashun&quot;]));	//true</span><br><span class="line">console.log([] instanceof Array);				//true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>​    在js中，灵活的将各种数据类型转换，使用不同的方法进行处理，能够快速的解决很多问题。</p>
<h5 id="gt-String"><a href="#gt-String" class="headerlink" title="-&gt;String"></a>-&gt;String</h5><p>大部分数据类型都可以使用<code>.toString()</code> 函数转换为字符串。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(([1, 2, 3]).toString()); // 1,2,3</span><br></pre></td></tr></table></figure>

<p>也可以使用函数 <code>String()</code> 转换为字符串。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(String([1, 2, 3]));</span><br></pre></td></tr></table></figure>

<p>或使用<code>join()</code>连接为字符串</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log([1, 2, 3].join(&quot;-&quot;));//1-2-3</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h5><p>使用<code>Array.from</code>可将<code>类数组</code>转换为数组，类数组指包含 <code>length</code> 属性或可迭代的对象。</p>
<ul>
<li>第一个参数为要转换的数据，第二个参数为类似于<code>map</code> 函数的回调方法</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let str = &#x27;阿顺&#x27;;</span><br><span class="line">console.log(Array.from(str)); //[&quot;阿&quot;, &quot;顺&quot;]</span><br></pre></td></tr></table></figure>

<p>为对象设置<code>length</code>属性后也可以转换为数组，但要下标为<code>数值或数值字符串</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  0: &#x27;阿顺&#x27;,</span><br><span class="line">  &#x27;1&#x27;: 18,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Array.from(user)); //[&quot;阿顺&quot;, 18]</span><br></pre></td></tr></table></figure>

<p>DOM元素转换为数组后来使用数组函数，第二个参数类似于<code>map</code> 函数的方法，可对数组元素进行处理。</p>
<ul>
<li><code>querySelectorAll</code>返回的是一个<code>类数组的Object</code>,但不是数组</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;Ashun&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;Ashuntefannao.com&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">    </span><br><span class="line">    console.log(btns instanceof Array); //false</span><br><span class="line">    console.log(btns instanceof Object); //true</span><br><span class="line">    </span><br><span class="line">    console.dir(btns); 		/*NodeList&#123;0:button,1:button,length:2&#125;*/</span><br><span class="line">    </span><br><span class="line">    Array.from(btns, (val) =&gt; &#123;</span><br><span class="line">      val.style.backgroundColor = &quot;red&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h5><p>使用<code>...</code>展开语法将 <code>NodeList</code> 转换为数组操作。</p>
<ul>
<li><code>forEach</code>可以直接操作Dom，但是<code>map</code>方法只能被Array调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .active &#123;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;button&gt;Ashun&lt;/button&gt;</span><br><span class="line">   &lt;button&gt;Ashuntefannao.com&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">  [...btns].map((v) =&gt; &#123;</span><br><span class="line">        v.addEventListener(&quot;click&quot;, (e) =&gt;</span><br><span class="line">          console.log(e.target.classList.toggle(&quot;active&quot;))</span><br><span class="line">        );</span><br><span class="line">   &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="展开语法-1"><a href="#展开语法-1" class="headerlink" title="展开语法"></a>展开语法</h4><p><code>...</code>即展开语法，功能有两个，介绍如下:</p>
<ul>
<li>将Array拆分为多个独立数据元    （作为表达式使用时）</li>
<li>将多个独立数据元合并为Array    （在形参、实参中使用时）</li>
</ul>
<h5 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h5><p>利用拆分功能，合并数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&quot;ashun&quot;, &quot;Ashun&quot;];</span><br><span class="line">let arr1 &#x3D; [1, 2, ...arr];</span><br><span class="line">console.log(arr1);</span><br><span class="line">&#x2F;&#x2F;[1, 2, &quot;ashun&quot;, &quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>

<p>将Array拆分，传入Math.max</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nums &#x3D; [1, 2, 3];</span><br><span class="line">console.log(Math.max(...nums));&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>函数接收多个参数转为Array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(...argu) &#123;</span><br><span class="line">	console.log(argu);</span><br><span class="line">&#125;</span><br><span class="line">test(&quot;ashun&quot;, &quot;Ashun&quot;);&#x2F;&#x2F;[&quot;ashun&quot;, &quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(a, ...argu) &#123;</span><br><span class="line">	console.log(a);							&#x2F;&#x2F;ashun</span><br><span class="line">	console.log(argu);					&#x2F;&#x2F;[1, &quot;site:Ashuntefannao.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">test(&quot;ashun&quot;, 1, &quot;site:Ashuntefannao.com&quot;);</span><br></pre></td></tr></table></figure>

<p>定义实参，合并接收多个数组元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [name, ...argus] &#x3D; [&quot;AHSUN&quot;, &quot;CSS3&quot;, &quot;ES6&quot;, &quot;Node&quot;];</span><br><span class="line">console.log(argus);	&#x2F;&#x2F;[&quot;CSS3&quot;, &quot;ES6&quot;, &quot;Node&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="节点转换"><a href="#节点转换" class="headerlink" title="节点转换"></a>节点转换</h5><p>​    之前已经遇到过此问题：通过<code>querySelectAll</code>获取多个Dom节点，但是不能够使用Array的<code>map</code>等方法。原因是<code>querySelectAll</code>返回的是一个<code>类数组的Object</code>(NodeList),但其并不是Array，自然也就不能够使用Array的方法。但是<code>forEach</code>能够直接操作Dom。</p>
<p>学习后面章节后也可以使用原型处理，将Dom节点传入，那么Array的map方法在执行时，也就拥有了Dom的context(执行上下文)，也就能够操作Dom节点。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;Ashun&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;Ashuntefannao.com&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">	Array.prototype.map.call(btns,(item)=&gt;&#123;</span><br><span class="line">	 item.style.background = &#x27;red&#x27;;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>下面是基本使用语法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let [name, age] = [&quot;ashun&quot;, 18];</span><br><span class="line">console.log(name, age);</span><br></pre></td></tr></table></figure>

<p>函数返回结果也可解构赋值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function getInfo() &#123;</span><br><span class="line">	 return [&quot;ASHUN&quot;, 18];</span><br><span class="line">&#125;</span><br><span class="line">let [name, age] = getInfo();</span><br><span class="line">console.log(name);//ASHUN</span><br></pre></td></tr></table></figure>

<p>剩余解构：指用一个变量来接收剩余参数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let [name, ...args] = [&quot;ashun&quot;, &quot;ashuntefannao.com&quot;, &quot;ES6&quot;, &quot;Vue&quot;];</span><br><span class="line">console.log(args);</span><br></pre></td></tr></table></figure>

<p><code>字符串</code>也可进行解构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let str = &quot;Ashun&quot;;</span><br><span class="line">let [...nameItems] = str;</span><br><span class="line">console.log(nameItems);		//[&quot;A&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议养成先声明后使用的好习惯。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">[web, url] = [&quot;ashun.com&quot;, &quot;ashuntefannao.com&quot;];</span><br><span class="line">console.log(web, url);</span><br><span class="line">//Uncaught ReferenceError: web is not defined</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let [web, url] &#x3D; [&quot;ashun.com&quot;, &quot;ashuntefannao.com&quot;];</span><br><span class="line">console.log(web, url);	&#x2F;&#x2F;ashun.com ashuntefannao.com</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h5><p>可在解构的同时，设置默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [name, age &#x3D; 18] &#x3D; [&quot;ashun&quot;];</span><br><span class="line">console.log(age);&#x2F;&#x2F;18</span><br></pre></td></tr></table></figure>



<h5 id="函数参数赋值"><a href="#函数参数赋值" class="headerlink" title="函数参数赋值"></a>函数参数赋值</h5><p>若函数接收Array为参数，也可利用解构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test([a,b])&#123;</span><br><span class="line">	console.log(a,b);			&#x2F;&#x2F;18 ashun</span><br><span class="line">&#125;</span><br><span class="line">test([&quot;18&quot;,&quot;ashun&quot;]); </span><br></pre></td></tr></table></figure>



<hr>
<h4 id="管理元素"><a href="#管理元素" class="headerlink" title="管理元素"></a>管理元素</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>利用索引，改变Array</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, &quot;Ashun&quot;, &quot;ashun&quot;];</span><br><span class="line">arr[1] = &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log(arr); //[1, &quot;Ashuntefannao&quot;, &quot;ashun&quot;]</span><br></pre></td></tr></table></figure>

<p>向数组追加元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, &quot;Ashun&quot;];</span><br><span class="line">arr[arr.length] = &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log(arr); //[1, &quot;Ashun&quot;, &quot;Ashuntefannao&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h5><p>使用展示语法批量添加元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;A&quot;, &quot;s&quot;];</span><br><span class="line">let arr1 = [&quot;h&quot;, &quot;u&quot;, &quot;n&quot;];</span><br><span class="line">arr.push(...arr1);</span><br><span class="line">console.log(arr); //[&quot;A&quot;, &quot;s&quot;, &quot;h&quot;, &quot;u&quot;, &quot;n&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>压入元素，直接改变元数组，返回值为<code>数组长度</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;ashun&quot;, 18, &quot;AshunTeFanNao&quot;];</span><br><span class="line">console.log(arr.push(&quot;ashun.com&quot;));		//4</span><br><span class="line">console.log(arr);		//[&quot;ashun&quot;, 18, &quot;AshunTeFanNao&quot;, &quot;ashun.com&quot;]</span><br></pre></td></tr></table></figure>

<p>根据区间创建新数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function rangeArray(begin, end) &#123;</span><br><span class="line">		let newArr = [];</span><br><span class="line">		for (let i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">				newArr.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		return newArr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(rangeArray(2, 5)); //[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>



<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><p>从末尾弹出元素，直接改变元数组，返回值为<code>弹出的元素</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;Ashun&quot;, &quot;王五&quot;];</span><br><span class="line">console.log(arr.pop()); //王五</span><br><span class="line">console.log(arr); //[&quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h5><p>从数组前面取出一个元素，返回值为<code>弹出的元素</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;王五&quot;, &quot;Ashun&quot;];</span><br><span class="line">console.log(arr.shift()); //王五</span><br><span class="line">console.log(arr); //[&quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h5><p>从数组前面添加元素，返回值为<code>数组长度</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;u&quot;, &quot;n&quot;];</span><br><span class="line">console.log(arr.unshift(&#x27;s&#x27;, &#x27;h&#x27;)); //4</span><br><span class="line">console.log(arr); //[&quot;a&quot;,&quot;s&quot;,&quot;h&quot;,&quot;u&quot;,&quot;n&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h5><p>​    利用<code>push</code>、<code>shift</code>能够模拟队列操作（先进先出），利用<code>unshift</code>、<code>shift</code>能够模拟栈操作，操作栈顶（后进先出）。</p>
<p><em><strong>小总结</strong></em>：</p>
<ul>
<li>push、unshift都是新增数据，返回结果为Array.length</li>
<li>pop、shift都是弹出数据，返回结果为弹出的元素。</li>
</ul>
<hr>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h5><ul>
<li>参数1：填充的元素</li>
<li>参数2、3：规定填充的范围，区间左闭右开<code>[n1,n2)</code></li>
</ul>
<p>使用<code>fill</code> 填充数组元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.dir(new Array(3).fill(&quot;SHUN&quot;)); //[&quot;SHUN&quot;, &quot;SHUN&quot;, &quot;SHUN&quot;]</span><br><span class="line">//empty×3 -&gt; [&quot;SHUN&quot;, &quot;SHUN&quot;, &quot;SHUN&quot;]</span><br></pre></td></tr></table></figure>

<p><code>fill</code>能够<code>覆盖原来的数据</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3];</span><br><span class="line">arr.fill(&quot;Ashun&quot;);</span><br><span class="line">console.log(arr);		&#x2F;&#x2F;[&quot;Ashun&quot;, &quot;Ashun&quot;, &quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>

<p>指定填充位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">console.log(arr.fill(&quot;ashun&quot;, 1, 2));//[1, &quot;ashun&quot;, 3]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p>该方法的使用规则与<code>string.slice()</code>相同，同时也不会改变原数组，而是返回一个新Array。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3];</span><br><span class="line">console.log(arr.slice(2, 3));&#x2F;&#x2F;[3]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>不传参时，获取所有元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [0, 1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(arr.slice()); //[0, 1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p>使用 <code>splice</code> 方法可以实现<code>添加、删除、替换</code>操作，<font color="#2980b9">会对原数组进行改变</font>，返回值为<code>删除的元素</code>。</p>
<p>该方法可接受多个参数：</p>
<ul>
<li>参数1：操作的位置</li>
<li>参数2：删除的个数</li>
<li>参数3~n：新增的元素</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [0, 1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(arr.splice(1, 3)); //返回删除的元素 [1, 2, 3] </span><br><span class="line">console.log(arr); //删除数据后的原数组 [0, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>通过修改<code>length</code>删除最后一个元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;ashun&quot;, &quot;Ashun&quot;];</span><br><span class="line">arr.length = arr.length - 1;</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<p>通过指定第3~n个参数来设置在删除位置添加的元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [0, 1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(arr.splice(1, 3, &quot;Ashun&quot;, &quot;SHUN&quot;)); //[1, 2, 3]</span><br><span class="line">console.log(arr); //[0, &quot;Ashun&quot;, &quot;SHUN&quot;, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>向末尾添加元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [0, 1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(arr.splice(arr.length, 0, &#x27;ashun&#x27;, &#x27;SHUN&#x27;)); 	//[]</span><br><span class="line">console.log(arr); 	// [0, 1, 2, 3, 4, 5, 6, &quot;ashun&quot;, &quot;SHUN&quot;]</span><br></pre></td></tr></table></figure>

<p>向数组前添加元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [0, 1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(arr.splice(0, 0, &#x27;ashun&#x27;, &#x27;SHUN&#x27;)); //[]</span><br><span class="line">console.log(arr); //[&quot;ashun&quot;, &quot;SHUN&quot;, 0, 1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>数组元素位置调整函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function moveArrayItem(arr, begin, num, to) &#123;</span><br><span class="line">	if (begin &lt; 0 || to &gt; arr.length) &#123;</span><br><span class="line">		throw new Error(&quot;操作范围有误&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (arr.length - begin &lt; num) &#123;</span><br><span class="line">		throw new Error(&quot;删除的数据超出数组的操作长度&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	let newArr = [...arr];</span><br><span class="line">	let movePart = newArr.splice(begin, num);</span><br><span class="line">	newArr.splice(to, 0, ...movePart);</span><br><span class="line">	return newArr;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(moveArrayItem(arr, 0, 3, arr.length)); //[4, 5, 6, 1, 2, 3]</span><br><span class="line">console.log(arr);	//[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>可将方法添加到原型上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.moveArrayItem &#x3D; function (begin, num, to) &#123;</span><br><span class="line">	if (begin &lt; 0 || to &gt; this.length) &#123;</span><br><span class="line">		throw new Error(&quot;操作范围有误&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.length - begin &lt; num) &#123;</span><br><span class="line">		throw new Error(&quot;删除的数据超出数组的操作长度&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	let newArr &#x3D; [...this];</span><br><span class="line">	const movePart &#x3D; newArr.splice(begin, num);</span><br><span class="line">	newArr.splice(to, 0, ...movePart);</span><br><span class="line">	return newArr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> let arr &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line"> console.log(arr.moveArrayItem(0, 6, arr.length));</span><br><span class="line"> console.log(arr);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h5><p>将数组值修改为<code>[]</code>可以清空数组，如果有多个变量引用时，清空其中一个变量，不会影响其它变量对数组内存地址的引用，数组data在内存中依旧存在，被其他变量引用。除非清空所有变量对数组的引用时，才会进行垃圾回收。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [</span><br><span class="line">     &#123; name: &quot;ashun&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">     &#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;,</span><br><span class="line"> ];</span><br><span class="line">let arr = user;</span><br><span class="line">user = [];</span><br><span class="line">console.log(arr);	</span><br><span class="line">/*</span><br><span class="line">     [&#123; name: &quot;ashun&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">     &#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;]</span><br><span class="line"> */</span><br><span class="line">arr = [];</span><br><span class="line">console.log(arr, user); //[] []</span><br></pre></td></tr></table></figure>

<p>将数组<code>length</code>设置为0也可以清空数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [</span><br><span class="line">     &#123; name: &quot;ashun&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">     &#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;,</span><br><span class="line">];</span><br><span class="line">user.length = 0;</span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure>

<p>使用<code>splice</code>方法删除所有数组元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [&#123; name: &quot;ashun&quot; &#125;, &#123; name: &quot;SHUN&quot; &#125;];</span><br><span class="line">user.splice(0, user.length);</span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure>

<p>使用<code>pop/shift</code>删除所有元素，来清空数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [&#123; name: &quot;ashun&quot; &#125;, &#123; name: &quot;SHUN&quot; &#125;];</span><br><span class="line">while (user.pop()) &#123;&#125;</span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h5><p>除了之前介绍的方式：<code>...</code>展开语法、<code>join(str)</code>合并为String。</p>
<p>还有一个属于数组的合并方法：<code>arr.concat(arr1,……arrN)</code>，能够将多个数组合并在一起，该方法<code>不会改变</code>原数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&quot;ashun&quot;, &quot;Ashun&quot;];</span><br><span class="line">console.log(arr.concat([&quot;ASHUN&quot;, &quot;TeFanNao&quot;]));&#x2F;&#x2F;[&quot;ashun&quot;, &quot;Ashun&quot;, &quot;ASHUN&quot;, &quot;TeFanNao&quot;]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[&quot;ashun&quot;, &quot;Ashun&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>当传入的参数也为Array时，在合并时会自动将其展开一层。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; [&quot;a&quot;];</span><br><span class="line">console.log(as.concat(&quot;b&quot;));	&#x2F;&#x2F;[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">console.log(as.concat(&quot;c&quot;,[&quot;d&quot;,&quot;e&quot;],[[[[&quot;f&quot;]]]]));	&#x2F;&#x2F;[&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,[[[&quot;f&quot;]]]];</span><br><span class="line">console.log(as);	&#x2F;&#x2F;[&quot;a&quot;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><p>使用 <code>copyWithin</code> 从数组中复制一部分到同数组中的另一个位置。（该方法会改变原数组）</p>
<p>语法说明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">array.copyWithin(target, start, end)</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>target</em></td>
<td align="left">必需。复制到指定目标索引位置。</td>
</tr>
<tr>
<td align="left"><em>start</em></td>
<td align="left">可选。元素复制的起始位置。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。停止复制的索引位置 (默认为 <em>array</em>.length)。如果为负值，表示倒数。</td>
</tr>
</tbody></table>
<p>start、end<code>区间左闭右开</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line">arr.copyWithin(2, 0, 2)</span><br><span class="line">console.log(arr); //[1, 2, 1, 2]</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>数组包含多种查找的函数，需要把这些函数掌握清楚，然后根据不同场景选择合适的函数。</p>
<p><code>indexOf、lastIndexOf、includes</code>只能查找非引用类型元素。使用方式同<code>string.indexOf()/lastIndexOf()/indeludes()</code></p>
<p><code>find、findIndex</code>能够查找引用类型元素</p>
<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p>使用 <code>indexOf</code> 从前向后查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, 8, 2, 6];</span><br><span class="line">console.log(arr.indexOf(2)); // 2 从前面查找2出现的位置</span><br></pre></td></tr></table></figure>

<p>如下面代码一下，使用 <code>indexOf</code> 查找字符串将找不到，因为<code>indexOf</code> 类似于<code>===</code>是严格类型约束。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, &#x27;8&#x27;, 2, 6];</span><br><span class="line">console.log(arr.indexOf(8)); // -1</span><br></pre></td></tr></table></figure>

<p>第二个参数用于指定查找开始位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, 8, 2, 6];</span><br><span class="line">//从第二个元素开始向后查找</span><br><span class="line">console.log(arr.indexOf(2, 3)); //4</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><p>使用 <code>lastIndexOf</code> 从后向前查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, 8, 2, 6];</span><br><span class="line">console.log(arr.lastIndexOf(2)); // 4 从后查找2出现的位置</span><br></pre></td></tr></table></figure>

<p>第二个参数用于指定查找开始位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, 8, 2, 6];</span><br><span class="line">//从第五个元素向前查找</span><br><span class="line">console.log(arr.lastIndexOf(2, 5));</span><br><span class="line"></span><br><span class="line">//从最后一个字符向前查找</span><br><span class="line">console.log(arr.lastIndexOf(2, -2));</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h5><p>使用 <code>includes</code> 查找字符串返回值是布尔类型更方便判断</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, 6];</span><br><span class="line">console.log(arr.includes(6)); //true</span><br></pre></td></tr></table></figure>

<p>我们来实现一个自已经的<code>includes</code>函数，来加深对<code>includes</code>方法的了解</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function includes(array, item) &#123;</span><br><span class="line">  for (const value of array)</span><br><span class="line">    if (item === value) return true;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(includes([1, 2, 3, 4], 3)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>find 方法找到后会把值返回出来，且只返回第一次找到的值，不继续查找。如果找不到返回值为<code>undefined</code>。</p>
<ul>
<li>参数是一个callback：<code>(val,index,arr)=&gt;&#123;return Boolean&#125;</code></li>
<li>callback必须返回一个boolean，就是通过这个boolean判断是否找到目标元素。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;ashun&quot;, &quot;Ashun&quot;, &quot;SHUN&quot;];</span><br><span class="line">console.log(arr.find((v) =&gt; v === &quot;SHUN&quot;));//SHUN</span><br><span class="line">console.log(arr.find((v) =&gt; true));//ashun</span><br></pre></td></tr></table></figure>

<p>使用<code>includes、indexOf、lastIndexOf</code>不能查找引用类型，因为它们的内存地址是不相等的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [</span><br><span class="line">    &#123; name: &quot;ashun&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">    &#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;,</span><br><span class="line">];</span><br><span class="line">console.log(user.includes(&#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;));//false</span><br><span class="line">console.log(user.indexOf(&#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;));//-1</span><br><span class="line">console.log(user.lastIndexOf(&#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;));//-1</span><br></pre></td></tr></table></figure>

<p><code>find</code> 可以方便的查找引用类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = [</span><br><span class="line">	&#123; name: &quot;ashun&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">	&#123; name: &quot;wangwu&quot;, type: &quot;user&quot; &#125;,</span><br><span class="line">];</span><br><span class="line">let find=user.find((v) =&gt; v.type == &quot;Controller&quot;);</span><br><span class="line">console.log(find);//&#123;name: &quot;ashun&quot;, type: &quot;Controller&quot;&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h5><p><code>findIndex</code> 与 <code>find</code> 的区别是返回索引值。其余用法相同。</p>
<ul>
<li>查找不到时返回 <code>-1</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [7, 3, 2, &#x27;8&#x27;, 2, 6];</span><br><span class="line"></span><br><span class="line">console.log(arr.findIndex(function (v) &#123;</span><br><span class="line">	return v == 8;</span><br><span class="line">&#125;)); //3</span><br><span class="line"></span><br><span class="line">console.log(8 == &quot;8&quot;);//true</span><br><span class="line">console.log(8 === &quot;8&quot;);//false</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="find原理"><a href="#find原理" class="headerlink" title="find原理"></a>find原理</h5><p>下面使用自定义函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">function find(array, callback) &#123;</span><br><span class="line">  for (const value of array) &#123;</span><br><span class="line">    if (callback(value) === true) return value;</span><br><span class="line">  &#125;</span><br><span class="line">  return undefined;</span><br><span class="line">&#125;</span><br><span class="line">let res = find(arr, function(item) &#123;</span><br><span class="line">  return item == 23;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Find(arr, callback) &#123;</span><br><span class="line">	for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		if (callback(arr[i], i, arr)) &#123;</span><br><span class="line">			return arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [&quot;ashun&quot;, &quot;Ashun&quot;, &quot;SHUN&quot;];</span><br><span class="line">let find &#x3D; Find(arr, (val, index, arr) &#x3D;&gt; val &#x3D;&#x3D; &quot;SHUN&quot;);</span><br><span class="line">console.log(find);&#x2F;&#x2F;SHUN</span><br></pre></td></tr></table></figure>

<p>下面添加原型方法实现</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Array.prototype.Find = function (callback) &#123;</span><br><span class="line">	for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">		if (callback(this[i], i, this)) return this[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return undefined;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let arr = [7, 3, 2, &quot;8&quot;, 2, 6];</span><br><span class="line">let find = arr.Find((val, index, arr) =&gt; index == 3);</span><br><span class="line">console.log(find);//&#x27;8&#x27;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>反转数组顺序，该方法<code>会改变</code>原数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 4, 2, 9];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr)//[9, 2, 4, 1]</span><br></pre></td></tr></table></figure>



<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort&#96;每次使用两个值进行比较 &#96;Array.sort((a,b)&#x3D;&gt;a-b)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回负数 a 排在 b前面，从小到大,<code>a-b</code></li>
<li>返回正数 b 排在a 前面,<code>b-a</code></li>
<li>返回 0 时保持不变</li>
<li>该方法也<code>会改变</code>原数组</li>
</ul>
<p>默认从小到大排序数组元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 4, 2, 9];</span><br><span class="line">console.log(arr.sort()); //[1, 2, 4, 9]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [8, 4, 5, 2, 1, 7];</span><br><span class="line">arr.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1, 2, 4, 5, 7, 8];</span><br><span class="line"></span><br><span class="line">arr.sort((a, b) &#x3D;&gt; b - a);</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[8, 7, 5, 4, 2, 1]</span><br><span class="line"></span><br><span class="line">arr.sort((a, b) &#x3D;&gt; 0);</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[8, 7, 5, 4, 2, 1]</span><br></pre></td></tr></table></figure>

<p>下面是按课程点击数由高到低排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let lessons &#x3D; [</span><br><span class="line">	&#123; title: &quot;CSS3&quot;, click: 78 &#125;,</span><br><span class="line">	&#123; title: &quot;ES6&quot;, click: 12 &#125;,</span><br><span class="line">	&#123; title: &quot;MYSQL多表查询随意操作&quot;, click: 99 &#125;,</span><br><span class="line">	&#123; title: &quot;Node&quot;, click: 100 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let sortLessons &#x3D; lessons.sort((v1, v2) &#x3D;&gt; v2.click - v1.click);</span><br><span class="line">console.log(sortLessons);</span><br></pre></td></tr></table></figure>

<h5 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.Sort &#x3D; function (callback) &#123;</span><br><span class="line">	for (let i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">		for (let j &#x3D; 0; j &lt; this.length; j++) &#123;</span><br><span class="line">			let temp &#x3D; 0;</span><br><span class="line">			if (callback(this[i], this[j]) &lt; 0) &#123;</span><br><span class="line">					temp &#x3D; this[i];</span><br><span class="line">					this[i] &#x3D; this[j];</span><br><span class="line">					this[j] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let arr &#x3D; [1, 2, 4, 5, 3];</span><br><span class="line">arr.Sort((a, b) &#x3D;&gt; b - a);</span><br><span class="line">console.log(arr);	&#x2F;&#x2F;[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>根据数组长度结合<code>for</code> 循环来遍历数组</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">	&#123;title: &#x27;媒体查询响应式布局&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">  &#123;title: &#x27;FLEX 弹性盒模型&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">	&#123;title: &#x27;MYSQL多表查询随意操作&#x27;,category: &#x27;mysql&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; lessons.length; i++) &#123;</span><br><span class="line">  lessons[i] = `阿顺: $&#123;lessons[i].title&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">console.log(lessons);</span><br></pre></td></tr></table></figure>



<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p><code>forEach</code>使函数作用在每个数组元素上，但是<code>没有返回值</code>。</p>
<p>关于参数：</p>
<ul>
<li>参数1：value</li>
<li>参数2：index</li>
<li>参数3：arr</li>
</ul>
<p>下面例子是截取标签的五个字符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">	&#123;title: &#x27;媒体查询响应式布局&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">  &#123;title: &#x27;FLEX 弹性盒模型&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">	&#123;title: &#x27;MYSQL多表查询随意操作&#x27;,category: &#x27;mysql&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">lessons.forEach((item, index, array) =&gt; &#123;</span><br><span class="line">    item.title = item.title.substr(0, 5);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(lessons);</span><br></pre></td></tr></table></figure>



<h5 id="for-in"><a href="#for-in" class="headerlink" title="for/in"></a>for/in</h5><p>遍历时的 key 值为数组的<code>索引</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">	&#123;title: &#x27;媒体查询响应式布局&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">  &#123;title: &#x27;FLEX 弹性盒模型&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">	&#123;title: &#x27;MYSQL多表查询随意操作&#x27;,category: &#x27;mysql&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">for (const key in lessons) &#123;</span><br><span class="line">    console.log(`标题: $&#123;lessons[key].title&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="for-of"><a href="#for-of" class="headerlink" title="for/of"></a>for/of</h5><p>与 <code>for/in</code> 不同的是 <code>for/of</code> 每次循环取其中的<code>值</code>而不是索引。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">	&#123;title: &#x27;媒体查询响应式布局&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">  &#123;title: &#x27;FLEX 弹性盒模型&#x27;,category: &#x27;css&#x27;&#125;,</span><br><span class="line">	&#123;title: &#x27;MYSQL多表查询随意操作&#x27;,category: &#x27;mysql&#x27;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">for (const item of lessons) &#123;</span><br><span class="line">  console.log(`</span><br><span class="line">    标题: $&#123;item.title&#125;</span><br><span class="line">    栏目: $&#123;item.category == &quot;css&quot; ? &quot;前端&quot; : &quot;数据库&quot;&#125;</span><br><span class="line">  `);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>​    使用<code>arr.keys()、arr,values()、arr.entries()</code>创建迭代器，然后使用<code>.next()</code>方法进行迭代。</p>
<h6 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h6><ul>
<li><code>.next()</code>迭代返回值为一个对象，包含两个属性</li>
<li>value –返回当前的<code>index</code></li>
<li>done –返回当前是否迭代完毕</li>
</ul>
<p>通过迭代对象获取索引</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = [&quot;ashun&quot;, &quot;Ashun&quot;];</span><br><span class="line">const keys = as.keys();</span><br><span class="line">console.log(keys.next());	//[value:0,done:false]</span><br><span class="line">console.log(keys.next());	//[value:1,done:false]</span><br></pre></td></tr></table></figure>

<p>使用<code>for/of</code>结合<code>iterator</code>取数组所有键。因为iterator返回的是一个<code>可迭代对象</code>，而<code>for/of</code>可以遍历可迭代对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;阿顺&quot;];</span><br><span class="line"></span><br><span class="line">for (const key of arr.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.keys());	//Array Iterator &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用while遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const arr = [&quot;ashun&quot;, &quot;Ashun&quot;, &quot;Ashuntefannao.com&quot;];</span><br><span class="line"></span><br><span class="line">while ((&#123; value, done &#125; = values.keys()) &amp;&amp; !done ) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h6 id="values"><a href="#values" class="headerlink" title="values"></a>values</h6><ul>
<li><code>.next()</code>迭代返回值为一个对象，包含两个属性</li>
<li>value –返回当前的<code>value</code></li>
<li>done –返回当前是否迭代完毕</li>
</ul>
<p>通过迭代对象获取值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const arr = [&quot;ashun&quot;, &quot;Ashuntefannao.com&quot;];</span><br><span class="line"></span><br><span class="line">let iteratorVal = arr.values();</span><br><span class="line">console.log(iteratorVal.next());</span><br><span class="line">console.log(iteratorVal.next());</span><br><span class="line">console.log(iteratorVal.next());	//&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<p><code>iterator</code>结合<code>for/of</code>获取数组的所有值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;阿顺&quot;];</span><br><span class="line"></span><br><span class="line">for (const value of arr.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h6 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h6><ul>
<li><code>.next()</code>迭代返回值为一个对象，包含两个属性</li>
<li>value –值为<code>Array</code>包含当前的<code>key,value</code></li>
<li>done –返回当前是否迭代完毕</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;阿顺&quot;];</span><br><span class="line">console.log(arr.entries().next());		&#x2F;&#x2F;&#123;value: [0 , &quot;a&quot;], done: false&#125;</span><br></pre></td></tr></table></figure>

<p><code>iterator</code>结合<code>for/of</code>结合<code>解构语法</code>，获取数组的所有键值对。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;阿顺&quot;];</span><br><span class="line">for (const [key, value] of arr.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解构获取内容（对象章节会详细讲解）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = [&quot;ashun&quot;, &quot;SHUN&quot;];</span><br><span class="line">const iterator = as.entries();</span><br><span class="line"></span><br><span class="line">let &#123;done,value: [k, v]&#125; = iterator.next();</span><br><span class="line"></span><br><span class="line">console.log(v);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p><code>every((val,index,arr)=&gt;Boolean)</code>，every 接收一个callback参数，并且callback必须返回一个boolean值，判断数组中的各个元素是否符合条件。</p>
<p>只有当所有元素都符合条件时every返回true ; 若有一个不符合就返回false，并停止遍历。</p>
<p>查看班级中同学的JS成绩是否都及格</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const user = [</span><br><span class="line">  &#123; name: &quot;李四&quot;, js: 89 &#125;,</span><br><span class="line">  &#123; name: &quot;马六&quot;, js: 55 &#125;,</span><br><span class="line">  &#123; name: &quot;张三&quot;, js: 78 &#125;</span><br><span class="line">];</span><br><span class="line">const resust = user.every(user =&gt; user.js &gt;= 60);</span><br><span class="line">console.log(resust);</span><br></pre></td></tr></table></figure>

<p>标题的关键词检查</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let words = [&quot;阿顺&quot;, &quot;Ashun&quot;, &quot;烦恼&quot;];</span><br><span class="line">let title = &quot;阿顺特烦恼渴望没有烦恼&quot;;</span><br><span class="line"></span><br><span class="line">let state = words.every(function (item, index, array) &#123;</span><br><span class="line">		 return title.indexOf(item) &gt;= 0;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (state == false) console.log(&quot;标题必须包含所有关键词&quot;);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p><code>some((val,index,arr)=&gt;Boolean)</code>some在使用格式上与every相同。但是两个方法的意义不同。</p>
<p>当数组中有一个元素符合条件时就返回true，并且停止遍历。</p>
<p>下面是使用 <code>some</code> 检测规则关键词的示例，如果匹配到一个词就提示违规。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let words = [&#x27;阿顺&#x27;, &#x27;Ashun&#x27;, &#x27;烦恼&#x27;];</span><br><span class="line">let title = &#x27;阿顺特烦恼渴望没有烦恼&#x27;</span><br><span class="line"></span><br><span class="line">let state = words.some(function (item, index, array) &#123;</span><br><span class="line">	return title.indexOf(item) &gt;= 0;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (state) console.log(&#x27;标题含有违规关键词&#x27;);</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p><code>filter((val,index,arr)=&gt;Boolean)</code>，filter也接受一个callback，并且callback必须返回boolean值，通过这个boolean，过滤出符合条件的元素。</p>
<p>下面是使用<code>filter</code>获取所有的普通用户。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let users = [</span><br><span class="line">		&#123; name: &quot;阿顺&quot;, type: &quot;Controller&quot; &#125;,</span><br><span class="line">		&#123; name: &quot;李四 &quot;, type: &quot;user&quot; &#125;,</span><br><span class="line">		&#123; name: &quot;王五&quot;, type: &quot;user&quot; &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let ordinary = users.filter((val, index, arr) =&gt; val.type == &quot;user&quot;);</span><br><span class="line">console.log(ordinary);</span><br><span class="line">//[ &#123;name: &quot;李四 &quot;, type: &quot;user&quot;&#125;, &#123;name: &quot;王五 &quot;, type: &quot;user&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>我们来写一个<code>剔除元素</code>的方法来加深些技术</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Filter(arr, callback) &#123;</span><br><span class="line">		let result = [];</span><br><span class="line">		arr.forEach((val, index, arr) =&gt; &#123;</span><br><span class="line">				!callback(val, index, arr) &amp;&amp; result.push(val);</span><br><span class="line">		&#125;);</span><br><span class="line">		return result;</span><br><span class="line">&#125;</span><br><span class="line">const user = [</span><br><span class="line">	&#123; name: &quot;李四&quot;, js: 89 &#125;,</span><br><span class="line">	&#123; name: &quot;马六&quot;, js: 55 &#125;,</span><br><span class="line">	&#123; name: &quot;张三&quot;, js: 78 &#125;,</span><br><span class="line">];</span><br><span class="line">console.log(Filter(user, (val, index, arr) =&gt; val.js &gt; 60));</span><br><span class="line">//[&#123; name: &quot;马六&quot;, js: 55 &#125;]</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>在使用形式上与<code>forEach</code>相同，都能够遍历<code>Array</code>。</p>
<p>与<code>forEAch</code>的不同点：</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">map</th>
<th>forEach</th>
</tr>
</thead>
<tbody><tr>
<td align="left">返回一个新数组</td>
<td>无返回值</td>
</tr>
<tr>
<td align="left">虽然能够访问到原数组的数据，但是这些都是新的存储空间<code>值为非引用类型时</code>，每次遍历时，<code>必须返回一个值</code>，作为对应位置的元素，若不返回，则对应的元素为undefined。</td>
<td>能够直接操作原数组的各个元素</td>
</tr>
</tbody></table>
</li>
</ul>
<p>Array的元素为 <code>非引用类型</code> 数据时，map操作返回的数组与原Array<code>没有任何关系</code>，无论是整个数组，还是数组的各个元素，都是新的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user &#x3D; [&quot;ashun&quot;, &quot;Ashun&quot;, &quot;SHUN&quot;];</span><br><span class="line"></span><br><span class="line">let newUser &#x3D; user.map((val) &#x3D;&gt; &#123;</span><br><span class="line">	return val &#x3D; &quot;ASHUN&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(user);	&#x2F;&#x2F; [&quot;ashun&quot;, &quot;Ashun&quot;, &quot;SHUN&quot;]</span><br><span class="line">console.log(newUser);&#x2F;&#x2F;[&quot;ASHUN&quot;, &quot;ASHUN&quot;, &quot;ASHUN&quot;]</span><br></pre></td></tr></table></figure>

<p>Array的元素为 <code>引用类型</code> 数据时，若每次返回的是原Array对应元素的内存地址，则map操作返回的数组，整体是仍是一个新的内存地址，但是由于对<code>引用类型数据</code>操作并返回，则会影响原数组的对应元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回原Array引用类型元素的内存地址</span><br><span class="line">const user &#x3D; [</span><br><span class="line">		&#123; name: &quot;李四&quot;, js: 89 &#125;,</span><br><span class="line">		&#123; name: &quot;马六&quot;, js: 55 &#125;,</span><br><span class="line">		&#123; name: &quot;张三&quot;, js: 78 &#125;,</span><br><span class="line">];</span><br><span class="line">let newUsers &#x3D; user.map((v) &#x3D;&gt; &#123;</span><br><span class="line">		v.js &#x3D; 100;</span><br><span class="line">		return v;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(newUsers);</span><br><span class="line">console.log(user);</span><br><span class="line">&#x2F;*</span><br><span class="line">[ &#123; name: &quot;李四&quot;, js: 100 &#125;,</span><br><span class="line">	&#123; name: &quot;马六&quot;, js: 100 &#125;,</span><br><span class="line">	&#123; name: &quot;张三&quot;, js: 100 &#125; ]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>定义新变量，直接赋值，也是相同的内存地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">........</span><br><span class="line">let newUsers &#x3D; user.map((v) &#x3D;&gt; &#123;</span><br><span class="line">		let newValue &#x3D; v;		&#x2F;&#x2F;直接赋值,与上面代码没区别。</span><br><span class="line">		newValue.js &#x3D; 100;</span><br><span class="line">		return newValue;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(user);</span><br><span class="line">console.log(newUsers);</span><br></pre></td></tr></table></figure>

<p>解决：可以进行<code>浅拷贝</code>，只是赋值其值，而不共享内存地址。【后续在Object章节会详细介绍】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">........</span><br><span class="line">let newUsers &#x3D; user.map((v) &#x3D;&gt; &#123;</span><br><span class="line">		let newValue &#x3D; &#123; ...v &#125;; &#x2F;&#x2F;浅拷贝</span><br><span class="line">		newValue.js &#x3D; 100;</span><br><span class="line">		return newValue;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(user);</span><br><span class="line">&#x2F;*</span><br><span class="line">[ &#123; name: &quot;李四&quot;, js: 89 &#125;,</span><br><span class="line">	&#123; name: &quot;马六&quot;, js: 55 &#125;,</span><br><span class="line">	&#123; name: &quot;张三&quot;, js: 78 &#125; ]</span><br><span class="line">*&#x2F;</span><br><span class="line">console.log(newUsers);</span><br><span class="line">&#x2F;*</span><br><span class="line">[ &#123; name: &quot;李四&quot;, js: 100 &#125;,</span><br><span class="line">	&#123; name: &quot;马六&quot;, js: 100 &#125;,</span><br><span class="line">	&#123; name: &quot;张三&quot;, js: 100 &#125; ]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>使用 <code>reduce</code> 与 <code>reduceRight</code> 函数可以迭代数组的所有元素，<code>reduce</code> 从前开始 <code>reduceRight</code> 从后面开始。下面通过函数计算课程点击数的和。</p>
<p>第一个参数是执行函数，第二个参数为初始值</p>
<ul>
<li>传入第二个参数时将所有元素循环一遍，第二个参数为pre的初始值。</li>
<li>不传第二个参数时从cur从第二个元素开始循环，则pre的初始值为第一个元素。</li>
</ul>
<p>函数参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>prev</td>
<td>上次调用回调函数返回的结果</td>
</tr>
<tr>
<td>cur</td>
<td>当前的元素值</td>
</tr>
<tr>
<td>index</td>
<td>当前的索引</td>
</tr>
<tr>
<td>array</td>
<td>原数组</td>
</tr>
</tbody></table>
<p>统计元素出现的次数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function countArrayELem(array, elem) &#123;</span><br><span class="line">  return array.reduce((total, cur) =&gt; (total += cur == elem ? 1 : 0), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let numbers = [1, 2, 3, 1, 5];</span><br><span class="line">console.log(countArrayELem(numbers, 1)); //2</span><br></pre></td></tr></table></figure>

<p>取数组中的最大值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function arrayMax(array) &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">  	(max, elem) =&gt; (max &gt; elem ? max : elem)</span><br><span class="line">  , array[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arrayMax([1, 3, 2, 9]));</span><br></pre></td></tr></table></figure>

<p>取价格最高的商品</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let cart = [</span><br><span class="line">  &#123; name: &quot;iphone&quot;, price: 12000 &#125;,</span><br><span class="line">  &#123; name: &quot;imac&quot;, price: 25000 &#125;,</span><br><span class="line">  &#123; name: &quot;ipad&quot;, price: 3600 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function maxPrice(array) &#123;</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (goods, elem) =&gt; (goods.price &gt; elem.price ? goods : elem)</span><br><span class="line">  ,array[0]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(maxPrice(cart));</span><br></pre></td></tr></table></figure>

<p>计算购物车中的商品总价</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let cart = [</span><br><span class="line">  &#123; name: &quot;iphone&quot;, price: 12000 &#125;,</span><br><span class="line">  &#123; name: &quot;imac&quot;, price: 25000 &#125;,</span><br><span class="line">  &#123; name: &quot;ipad&quot;, price: 3600 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const total = cart.reduce(</span><br><span class="line">	(total, goods) =&gt; total += goods.price</span><br><span class="line">, 0);</span><br><span class="line">console.log(total); //40600</span><br></pre></td></tr></table></figure>

<p>获取价格超过1万的商品名称</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let goods = [</span><br><span class="line">  &#123; name: &quot;iphone&quot;, price: 12000 &#125;,</span><br><span class="line">  &#123; name: &quot;imac&quot;, price: 25000 &#125;,</span><br><span class="line">  &#123; name: &quot;ipad&quot;, price: 3600 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function getNameByPrice(array, price) &#123;</span><br><span class="line">  return array.reduce((goods, elem) =&gt; &#123;</span><br><span class="line">    if (elem.price &gt; price) &#123;</span><br><span class="line">      goods.push(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    return goods;</span><br><span class="line">  &#125;, []).map(elem =&gt; elem.name);</span><br><span class="line">&#125;</span><br><span class="line">console.table(getNameByPrice(goods, 10000));</span><br></pre></td></tr></table></figure>

<p>使用 <code>reduce</code> 实现数组去重</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 6, 2, 1];</span><br><span class="line">let filterArr = arr.reduce((pre, cur, index, array) =&gt; &#123;</span><br><span class="line">  if (pre.includes(cur) === false) &#123;</span><br><span class="line">      pre = [...pre, cur];</span><br><span class="line">  &#125;</span><br><span class="line">  return pre;</span><br><span class="line">&#125;, [])</span><br><span class="line">console.log(filterArr); // [1,2,6]</span><br></pre></td></tr></table></figure>



<h5 id="动画实例"><a href="#动画实例" class="headerlink" title="动画实例"></a>动画实例</h5><hr>
<img src="数组类型.assets/Array-reduce.gif" alt="Array-reduce.gif" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      div &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        font-size: 30px;</span><br><span class="line">      &#125;</span><br><span class="line">      span &#123;</span><br><span class="line">        color: rebeccapurple;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line">      .active &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        animation: active 0.8s 2;</span><br><span class="line">        letter-spacing: 0.4rem;</span><br><span class="line">      &#125;</span><br><span class="line">      @keyframes active &#123;</span><br><span class="line">        25% &#123;</span><br><span class="line">          color: pink;</span><br><span class="line">          transform: scale(1.2);</span><br><span class="line">        &#125;</span><br><span class="line">        40% &#123;</span><br><span class="line">          color: #f1c40f;</span><br><span class="line">          transform: scale(1.5);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">          color: red;</span><br><span class="line">          transform: scale(2);</span><br><span class="line">        &#125;</span><br><span class="line">        60% &#123;</span><br><span class="line">          color: #e67e22;</span><br><span class="line">          transform: scale(1.5);</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">          color: pink;</span><br><span class="line">          transform: scale(1.2);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">      let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      let text &#x3D; div.innerText;</span><br><span class="line">      [...text].reduce((pre, val) &#x3D;&gt; &#123;</span><br><span class="line">        pre &#x3D;&#x3D; 0 &amp;&amp; (div.innerHTML &#x3D; &quot;&quot;);</span><br><span class="line">        </span><br><span class="line">        let span &#x3D; document.createElement(&quot;span&quot;);</span><br><span class="line">        span.innerText &#x3D; val;</span><br><span class="line">        div.append(span);</span><br><span class="line"></span><br><span class="line">        span.addEventListener(&quot;mouseenter&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          e.target.classList.add(&quot;active&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        span.addEventListener(&quot;animationend&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">          e.target.classList.remove(&quot;active&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/Promise/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>JavaScript</code> 中存在很多异步操作,<code>Promise</code> 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。可以通过链式调用多个 <code>Promise</code> 达到我们的目的。</p>
<p>Promise 在各种开源库中已经实现，现在标准化后被浏览器默认支持。</p>
<blockquote>
<p>promise 是一个拥有 <code>then</code> 方法的对象或函数</p>
</blockquote>
<h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>下面通过多个示例来感受一下不使用 <code>promise</code> 时，处理相应问题的不易，及生成了不便阅读的代码。</p>
<h4 id="定时嵌套"><a href="#定时嵌套" class="headerlink" title="定时嵌套"></a>定时嵌套</h4><p>下面是一个定时器执行结束后，执行另一个定时器，这种嵌套造成代码不易阅读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createInterval(callback, delay &#x3D; 50) &#123;</span><br><span class="line">        let timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          callback(timer);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">      const div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line">      console.log(parseFloat(window.getComputedStyle(div).left));</span><br><span class="line"></span><br><span class="line">      function run() &#123;</span><br><span class="line">        createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">          div.style.left &#x3D;</span><br><span class="line">            parseFloat(window.getComputedStyle(div).left) + 2 + &quot;px&quot;;</span><br><span class="line">          &#x2F;&#x2F; console.log(&quot;left&quot;);</span><br><span class="line">          if (parseFloat(div.style.left) &gt;&#x3D; 50) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">            createInterval((timer) &#x3D;&gt; &#123;</span><br><span class="line">              div.style.width &#x3D;</span><br><span class="line">                parseFloat(window.getComputedStyle(div).width) - 2 + &quot;px&quot;;</span><br><span class="line">              &#x2F;&#x2F; console.log(&quot;width&quot;);</span><br><span class="line">              parseFloat(div.style.width) &lt;&#x3D; 0 &amp;&amp; clearInterval(timer);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><p>下面是图片后设置图片边框，也需要使用回调函数处理，代码嵌套较复杂</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function createImage(file, resolve, reject) &#123;</span><br><span class="line">  const img = new Image();</span><br><span class="line">  img.src = file;</span><br><span class="line">  img.onload = () =&gt; &#123;</span><br><span class="line">    resolve(img);</span><br><span class="line">    console.log(&quot;image Loading fulfilled&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.onerror = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;image loading fail&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  document.body.append(img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createImage(&quot;./images/img1.jpg&quot;, (img) =&gt; &#123;</span><br><span class="line">  img.style.border = &quot;5px solid pink&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>下面是异步加载外部<code>JS</code>文件，需要使用回调函数执行，并设置的错误处理的回调函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function loadJS(file, resolve, reject) &#123;</span><br><span class="line">  let script = document.createElement(&quot;script&quot;);</span><br><span class="line">  script.src = file;</span><br><span class="line">  script.onload = resolve;</span><br><span class="line">  script.onerror = reject;</span><br><span class="line">  document.body.append(script);</span><br><span class="line">&#125;</span><br><span class="line">loadJS(</span><br><span class="line">  &quot;./js/ashun.js&quot;,</span><br><span class="line">  (script) =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">    title();</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; console.log(`$&#123;err.srcElement.src&#125;  load Reject`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实例中用到的 <code>ashun.js</code> 与 <code>SHUN.js</code> 内容如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># ashun.js</span><br><span class="line">function title() &#123;</span><br><span class="line">  console.log(&quot;title method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># SHUN.js</span><br><span class="line">function run() &#123;</span><br><span class="line">  title();</span><br><span class="line">  console.log(&quot;run method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加载多个脚本时需要嵌套使用，下面<code>SHUN.js</code> 依赖 <code>ashun.js</code>，需要先加载<code>ashun.js</code> 后加载<code>SHUN.js</code></p>
<blockquote>
<p>不断的回调函数操作将产生回调地狱，使代码很难维护</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function loadJS(file,resolve,reject)&#123;……&#125;</span><br><span class="line"></span><br><span class="line">   loadJS(</span><br><span class="line">        &quot;/js/ashun.js&quot;,</span><br><span class="line">        (script) =&gt; &#123;</span><br><span class="line">          loadJS(</span><br><span class="line">            &quot;/js/SHUN.js&quot;,</span><br><span class="line">            (script) =&gt; &#123;</span><br><span class="line">              run();</span><br><span class="line">              console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">            &#125;,</span><br><span class="line">            (err) =&gt; &#123;</span><br><span class="line">              console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">          console.log(`$&#123;script.path[0].src&#125;  load Resolve`);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          console.log(`$&#123;err.srcElement.src&#125;加载失败`);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><p>使用传统的异步请求也会产生回调嵌套的问题。</p>
<p>比如若要获取商品的详情，就要分为两步</p>
<ol>
<li>先请求商品数据，得到商品的id</li>
<li>根据商品id请求获取对应商品的详情数据。</li>
</ol>
<p>以下接口无实际用途，仅作示例，可自己编写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function ajax(url, resolve, reject) &#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.open(&quot;GET&quot;, url);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onload = function() &#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      resolve(JSON.parse(this.response));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&quot;http://localhost:8888/goodslist/data, goods =&gt; &#123;</span><br><span class="line">  ajax(</span><br><span class="line">    `http://localhost:8888/category?id=$&#123;goods[&quot;id&quot;]&#125;`,</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      console.log(response[0]);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="肯德基"><a href="#肯德基" class="headerlink" title="肯德基"></a>肯德基</h4><p>下面是模拟肯德基吃饭的事情，使用 <code>promise</code> 操作异步的方式每个阶段会很清楚</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let kfc = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&quot;肯德基正在为您做餐……&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;餐品已经做好，为您上桌&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">let as = kfc.then((result) =&gt; &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">  console.log(&quot;阿顺收到消息&quot;);</span><br><span class="line">  return &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;我吃了2秒，不辣，张三你可以吃了&quot;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let zhangsan = as.then((msg) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&quot;张三收到阿顺消息：&quot; + msg);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      let msg = &quot;我吃了1秒，真好吃， 李四也尝尝吧&quot;;</span><br><span class="line">      console.log(msg);</span><br><span class="line">      resolve(msg);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">let lisi = zhangsan.then((result) =&gt; &#123;</span><br><span class="line">  console.log(&quot;李四收到消息：&quot; + result);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;李四:我吃了1秒，不错不错&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而使用以往的回调方式，就会让人苦不堪言</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function notice(msg, then) &#123;</span><br><span class="line">  then(msg);</span><br><span class="line">&#125;</span><br><span class="line">function meal() &#123;</span><br><span class="line">  notice(&quot;肯德基厨房开始做饭&quot;, (msg) =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">    notice(&quot;我是肯德基，你的餐已经做好&quot;, (msg) =&gt; &#123;</span><br><span class="line">      console.log(`阿顺收到肯德基消息: $&#123;msg&#125;`);</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        notice(&quot;张三，我吃了两秒了，不辣，你可以吃了&quot;, (msg) =&gt; &#123;</span><br><span class="line">          console.log(`张三收到阿顺消息: $&#123;msg&#125;`);</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            notice(&quot;很好吃，李四也尝尝吧&quot;, (msg) =&gt; &#123;</span><br><span class="line">              console.log(msg);</span><br><span class="line">              notice(&quot;李四收到消息&quot;, (msg) =&gt; &#123;</span><br><span class="line">                console.log(msg);</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                  console.log(&quot;李四:不错不错&quot;);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">meal();</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="异步状态"><a href="#异步状态" class="headerlink" title="异步状态"></a>异步状态</h3><p>Promise 意为承诺，就像我们去饭店用餐，点完餐后服务员会给我们一个票号，如果饭菜做好，我们凭借票号去领餐，这就代表成功状态，若由于其它原因饭菜不能够顺利做好，这就代表拒绝状态。在得到这些结果前，我们一直处于等待的状态。</p>
<ul>
<li>一个 <code>promise</code> 必须有一个 <code>then</code> 方法用于处理状态改变</li>
</ul>
<h4 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h4><p>Promise包含<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>三种状态</p>
<ul>
<li><code>pending</code> 指等待状态，初始化 <code>promise</code> 时的状态</li>
<li><code>resolve</code> 指已经解决，将 <code>promise</code> 状态设置为<code>fulfilled</code></li>
<li><code>reject</code> 指拒绝处理，将 <code>promise</code> 状态设置为<code>rejected</code></li>
<li><code>promise</code> 是生产者，通过 <code>resolve</code> 与 <code>reject</code> 函数告知结果</li>
<li><code>promise</code> 非常适合需要一定执行时间的异步任务</li>
<li>同一Promise状态一旦确定(<code>fufilled\rejected</code>),状态将不可再次更改</li>
</ul>
<p>promise 是队列状态，就像体育中的接力赛，或多米诺骨牌游戏，状态一直向后传递，当然 也可更改其中的任何一个promise的状态，来影响后续的promise。</p>
<p>promise 没有使用 <code>resolve</code> 或 <code>reject</code> 更改状态时，默认状态为 <code>pending</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">); //Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>当更改状态后</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;resolved&gt;: &quot;fulfilled&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); //Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; //Error</span><br></pre></td></tr></table></figure>

<p>若一个Promise为<code>rejected</code>状态，却没有处理，系统会发出警示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&quot;rejected&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;rejected&gt;: &quot;rejected&quot;&#125; &#x2F;&#x2F;Error:Uncaught (in promise) rejected</span><br></pre></td></tr></table></figure>

<p>使用<code>then\catch</code>处理后，不会报错，<code>then\catch</code>这些方法默认也会返回一个新的<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">        new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">); &#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>按理来说上述Promise已经确认为rejected状态，也经过了<code>then\catch</code>的onRejected回调函数处理，应该返回<code>fufilled</code>状态（<code>then\catch</code>默认返回的promise状态为fufilled），但是为什么返回pending状态呢？</p>
<ul>
<li>console.log是同步代码会立即执行，当日志信息被打印时，promise的状态还未被确认，所以返回pending</li>
<li>将打印放在宏任务队列中，可看到正确结果</li>
</ul>
<p>关于<code>任务队列</code>，下一章节会详细讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 &#x3D; promise.catch((err) &#x3D;&gt; err);</span><br><span class="line"></span><br><span class="line">console.log(promise)&#x2F;&#x2F;Promise &#123;&lt;rejected&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">console.log(p1);		&#x2F;&#x2F;Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(p1);	&#x2F;&#x2F;Promise &#123;&lt;fulfilled&gt;:&quot;rejected&quot;&#125;</span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<p><code>promise</code> 自创建时，立即执行同步任务，<code>then</code> 会放在异步微任务中执行，需要等同步任务执行后才执行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;fulfilled&quot;);</span><br><span class="line">  console.log(&quot;阿顺&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;阿顺特烦恼&quot;);</span><br><span class="line">// 阿顺 阿顺特烦恼 fulfilled</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">	resolve(&quot;fulfilled&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(alert);</span><br><span class="line">alert(&quot;阿顺特烦恼&quot;);</span><br><span class="line">promise.then((_) &#x3D;&gt; alert(&quot;ashuntefannao&quot;));</span><br></pre></td></tr></table></figure>

<p>下例在三秒后将 <code>Promise</code> 状态设置为 <code>fulfilled</code> ，然后执行 <code>then</code> 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;fulfilled&quot;);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>状态被改变后就不能再修改了，下面先通过<code>resolve</code> 改变为成功状态，表示<code>promise</code> 状态已经完成，就不能使用 <code>reject</code> 更改状态了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;操作成功&quot;);</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="动态改变"><a href="#动态改变" class="headerlink" title="动态改变"></a>动态改变</h4><p>可以在一个<code>promise</code>中，通过处理另一个<code>promise1</code>，来改变<code>promise</code>的状态。</p>
<p>当在一个<code>promise</code>中，告知状态时传入的是另一个<code>promise1</code>，则后续使用<code>then</code>或其它方法对其进行处理时，处理的已经不再是promise的状态，而是promise1。</p>
<ul>
<li>在p2中确认<code>resolve</code>状态，但在后续的<code>then</code>中却执行了<code>rejected</code>回调函数。</li>
<li>在p2中确认状态时，返回的是p1，那么后续处理的promise将是p1，p2的状态已经无意义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject(&quot;p1 reject&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#96;p2发送resolve状态&#96;);</span><br><span class="line">        resolve(p1);</span><br><span class="line">      &#125;).then(</span><br><span class="line">        (result) &#x3D;&gt; console.log(&#96;p2 处理结果:fulfilled--$&#123;result&#125;&#96;),</span><br><span class="line">        (err) &#x3D;&gt; console.log(&#96;p2 处理结果:rejected--$&#123;err&#125;&#96;)</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>一个promise 需要提供一个then方法访问promise 结果，<code>then</code> 用于当 <code>promise</code> 状态发生改变时的处理，即<code>promise</code>处理异步操作过程，<code>then</code> 用于处理结果。</p>
<p><code>promise</code> 就像 <code>饭馆</code> 中的厨房，<code>then</code> 就是我们用户，如果餐做好了即 <code>fulfilled</code> ，做不了拒绝即<code>rejected</code> 状态。那么 then 就要对不同状态处理。</p>
<ul>
<li>then 方法 <strong>必须</strong> 返回 promise，用户返回或系统自动返回</li>
<li>第一个函数在<code>resolved</code> 状态时执行，即使用<code>resolve</code>确认完成状态时，执行<code>then</code>第一个callback处理成功状态</li>
<li>第二个函数在<code>rejected</code>状态时执行，即使用<code>reject</code>确认拒绝状态时，执行第二个callback处理失败状态，该函数是可选的</li>
<li>两个callback都接收 <code>promise</code> 确认状态时传入的值做为参数</li>
<li>也可以使用<code>catch</code> 来处理失败的状态</li>
<li>如果在 <code>then</code> 中手动返回 <code>promise</code> ，下一个<code>then</code> 会在上一个then返回的<code>promise</code> 状态改变后执行</li>
</ul>
<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><p>then的语法如下，onFulfilled 函数处理 <code>fulfilled</code> 状态， onRejected函数处理 <code>rejected</code> 状态</p>
<ul>
<li>onFulfilled 或 onRejected <code>不是函数将被忽略</code></li>
<li>两个函数只会被调用一次</li>
<li>onFulfilled 在 promise 执行成功时调用</li>
<li>onRejected 在 promise 执行拒绝时调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><code>then</code> 会在 <code>promise</code> 确认状态后执行，<code>then</code> 第一个callback在 <code>resolve</code>成功状态执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    console.log(`解决：$&#123;value&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    console.log(`拒绝:$&#123;reason&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 中第二个参数在失败状态执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果只关心成功则不需要传递 <code>then</code> 的第二个参数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(msg =&gt; &#123;</span><br><span class="line">  console.log(`成功：$&#123;msg&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果只关心失败时状态，<code>then</code> 的第一个参数传递 <code>null</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;is error&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(`失败:$&#123;error&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>promise 确认状态后转入的参数，会传入到<code>then</code>对应callback的参数中，如果then没有可处理函数，会一直向后传递</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&quot;rejected&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(</span><br><span class="line">  null,</span><br><span class="line">  f =&gt; console.log(f)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;resolve&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then();</span><br><span class="line">p2.then().then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;reject&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then(() &#x3D;&gt; &#123;&#125;);</span><br><span class="line">p2.then(null, null).then(null, reject &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><ul>
<li><code>then\catch</code>等promise的方法，是对上一个promise状态的处理，而使用<code>then/catch</code>后 它们本身又会默认返回一个新的promise，且状态为<code>fulfilled</code>,所以then才可不断地链式调用。</li>
<li>当然，也可以在<code>then\catch</code>中手动返回自定义的promise，可通过这个promise，改变当前then的状态</li>
</ul>
<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>， then 默认返回的 promise 状态是 fulfilled</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       reject(&quot;promise state rejected&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(null, (err) &#x3D;&gt; console.log(err))</span><br><span class="line">       .then((_) &#x3D;&gt; console.log(&quot;then默认状态为fulfilled&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次的 <code>then</code> 都是一个全新的 <code>promise</code>，不要认为上一个 promise状态会影响以后then返回的状态</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let p1 = new Promise(resolve =&gt; &#123;</span><br><span class="line">  rejected(&quot;p1 rejected&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = p1.then(null,rej=&gt;console.log(reg));</span><br><span class="line">p2.then(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">console.log(p2); // Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(p1); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">  console.log(p2); // Promise &#123;&lt;resolved&gt;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 是对上个promise 的处理，每个 <code>then</code> 又会返回一个promise，默认传递 <code>fulfilled</code>状态，所以才可以不断地链式调用then处理promise。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  resolve =&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">  reject =&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line"># 执行结果如下</span><br><span class="line">  rejected</span><br><span class="line">  fulfilled</span><br><span class="line">  fulfilled</span><br></pre></td></tr></table></figure>

<p>如果内部手动返回 <code>promise</code> 时，后续处理的便是该 <code>promise</code>，即该promise可以改变当前then的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">         reject(&quot;promise state rejected&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">       promise</span><br><span class="line">         .then(</span><br><span class="line">           (result) &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">           (reject) &#x3D;&gt; console.log(reject)</span><br><span class="line">         )</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">         )</span><br><span class="line">         .then((res) &#x3D;&gt; &#123;</span><br><span class="line">           console.log(&quot;fufilled&quot;);</span><br><span class="line">           return Promise.reject(&quot;手动返回的promise，状态为rejected&quot;);</span><br><span class="line">         &#125;)</span><br><span class="line">         .then(</span><br><span class="line">           (res) &#x3D;&gt; console.log(&quot;fufilled&quot;),</span><br><span class="line">           (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">         );</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果如下</span><br><span class="line"> &quot;promise state rejected&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;fulfilled&quot;</span><br><span class="line"> &quot;手动返回的promise，状态为rejected&quot;</span><br></pre></td></tr></table></figure>

<p>若手动返回的不是Promise，则下一个then处理的还是 上一个then默认返回的Promise，状态为fulfilled。</p>
<ul>
<li>但是下一个then对应的处理函数，会接受上一个then返回的参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">        	console.log(rej)</span><br><span class="line">          return &quot;p1 rejected&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; p1.then((res) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#96;p2 fulfilled \n$&#123;res&#125;&#96;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> # 执行结果如下</span><br><span class="line">  &quot;promise state rejected&quot;</span><br><span class="line">  &quot;p2 fulfilled</span><br><span class="line">   p1 rejected&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(v &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个promise&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>then是处理上一个Promise的结果，只有上一个promise确认了状态，then才会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                resolve(&quot;resolved&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; console.log(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>循环调用</strong></p>
<p>如果 <code>then</code> 的返回值与所处理的 <code>promise</code> 相同将禁止执行，（避免陷入死循环）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then(() =&gt; &#123;</span><br><span class="line">  return p2;</span><br><span class="line">&#125;); // TypeError: Chaining cycle detected for promise</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a>其它类型</h4><p><strong>then able</strong>：具有then能力的类型</p>
<p>Promise 解决过程是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<ul>
<li>也就是说，如果<code>x</code>具有<code>then</code>方法，那么将会被系统认为是<code>类promise</code>的结构</li>
<li>若在Promise中返回<code>x</code>,则使用then处理Promise时，系统会尝试让原Promise的then方法接收<code>x</code>中then方法的状态</li>
</ul>
<p>包含then方法的Object可以当作promise使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              resolve(&quot;promise fulfilled&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(result);</span><br><span class="line">          return &#123;</span><br><span class="line">            then(resolve, reject) &#123;</span><br><span class="line">              setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                reject(&quot; p1 rejected&quot;);</span><br><span class="line">              &#125;, 1000);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">        p1.then(</span><br><span class="line">          (mgs) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(mgs);</span><br><span class="line">          &#125;,</span><br><span class="line">          (rej) &#x3D;&gt; console.log(rej)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Goods &#123;</span><br><span class="line">  constructor(id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goods?id&#x3D;$&#123;this.id&#125;&#96;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(ajax(&#96;http:&#x2F;&#x2F;localhost:8083&#x2F;goodsList?type&#x3D;new&#96;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(goods &#x3D;&gt; &#123;</span><br><span class="line">  return new Goods(goods.id);</span><br><span class="line">&#125;)</span><br><span class="line">.then(category &#x3D;&gt; &#123;</span><br><span class="line">  console.log(category);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然也可以是类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(</span><br><span class="line">    class &#123;</span><br><span class="line">      static then(resolve, reject) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          resolve(&quot;解决状态&quot;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;).then(</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`fulfilled: $&#123;v&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    console.log(`rejected: $&#123;v&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果对象中的 then 不是函数，则将对象做为值传递</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    then: &quot;阿顺特烦恼&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  console.log(v); //&#123;then: &quot;阿顺特烦恼&quot;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>下面使用未定义的变量同样会触发失败状态</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  as;</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; console.log(value),</span><br><span class="line">  reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果 onFulfilled 或 onRejected 抛出异常，则 p2 拒绝执行并返回拒因</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = promise.then();</span><br><span class="line">p2.then().then(null, resolve =&gt; &#123;</span><br><span class="line">  console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>catch(err=&gt;&#123;&#125;)</code>是用来接收Promise拒绝状态的。经catch处理后，默认返回的promise状态也为fulfilled</li>
<li><code>catch</code>相当于<code>then(null,onReject)</code></li>
<li>若某个promise已被<code>then(null,onReject)</code>处理，则<code>catch</code>将不会接收该拒绝状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p1 &#x3D; promise.catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          console.log(p1);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected,阿顺特烦恼</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(err))</span><br><span class="line">          .then(null, (resolve) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(resolve + &quot;,阿顺特烦恼&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;	promise rejected</span><br></pre></td></tr></table></figure>

<ul>
<li>建议使用 <code>catch</code> 处理错误</li>
<li>将 <code>catch</code> 放在最后面用于统一处理前面发生的错误</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;Notice: Promise Exception&quot;));</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.error(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 可以捕获之前所有 <code>promise</code> 的错误，所以建议将 <code>catch</code> 放在最后。下例中 <code>catch</code> 也可以捕获到了第一个 <code>then</code> 返回 的 <code>promise</code> 的错误。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&quot;err from .then &quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>错误是冒泡的操作的，下面没有任何一个<code>then</code> 定义第二个函数参数<code>onRejected</code>，将一直冒泡到 <code>catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.then(msg =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获对 <code>then</code> 抛出的错误处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;这是then 抛出的错误&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;33&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 也可以捕获其他错误，下面在 <code>then</code> 中使用了未定义的变量，将会把错误抛出到 <code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;success&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg &#x3D;&gt; &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(reason &#x3D;&gt; &#123;</span><br><span class="line">  console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;fail&quot;);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString()+&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以将上面的理解为如下代码，可以理解为内部自动执行 <code>try...catch</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但像下面的在<code>异步宏任务</code>中 <code>throw new Error</code> 将不会触发 <code>catch</code>，而使用系统错误处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    throw new Error(&quot;fail&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;).catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg + &quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>catch</code> 中发生的错误也会抛给最近的错误处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  ashun();</span><br><span class="line">&#125;)</span><br><span class="line">.then(null, error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="定制错误"><a href="#定制错误" class="headerlink" title="定制错误"></a>定制错误</h4><p>可以根据不同的错误类型进行定制操作，下面将<code>url格式错误</code>与<code>参数错误</code>分别进行了处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class ParamError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;ParamError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name = &quot;HttpError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if (!/^http/.test(url)) &#123;</span><br><span class="line">      throw new HttpError(&quot;请求地址格式错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else if (this.status == 404) &#123;</span><br><span class="line">        // throw new ParamError(&quot;用户不存在&quot;);</span><br><span class="line">        reject(new ParamError(&quot;用户不存在&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(&quot;加载失败&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(`http://localhost:8083?name=阿顺特烦恼`)</span><br><span class="line">.then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  if (error instanceof ParamError) &#123;</span><br><span class="line">    console.log(`参数错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  if (error instanceof HttpError) &#123;</span><br><span class="line">    alert(`url格式错误:$&#123;error.message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>无论状态是<code>resolve</code> 或 <code>reject</code> 都会执行此动作，<code>finally</code> 与状态无关。</p>
<ul>
<li>根据finally的特性，通常在其中做一些公共的操作，不论状态，都会执行的操作。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(&quot;reject&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve/reject状态都会执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>finally</code> 处理加载状态，当图片加载完成时移除加载图标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      .result &#123;</span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;loading&quot;&gt;loading...&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;result&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      function createImage(file) &#123;</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          let img &#x3D; new Image();</span><br><span class="line">          img.src &#x3D; file;</span><br><span class="line">          img.onload &#x3D; () &#x3D;&gt; resolve(img);</span><br><span class="line">          img.onerror &#x3D; () &#x3D;&gt; reject(&quot;加载失败&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        createImage(&quot;.&#x2F;images&#x2F;img1.jpg&quot;)</span><br><span class="line">          .then((img) &#x3D;&gt; &#123;</span><br><span class="line">            document.body.append(img);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; &quot;加载成功&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            document.querySelector(&quot;.result&quot;).innerHTML &#x3D; err;</span><br><span class="line">          &#125;)</span><br><span class="line">          .finally(() &#x3D;&gt; &#123;</span><br><span class="line">            document.querySelector(&quot;div&quot;).style.display &#x3D; &quot;none&quot;;</span><br><span class="line">            document.querySelector(&quot;.result&quot;).style.display &#x3D; &quot;block&quot;;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><h5 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h5><p>下面是将 <code>ajax</code> 请求使用 <code>promise</code> 处理，代码结构清晰了很多</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&quot;http://localhost:8083/goodsList?name=new&quot;)</span><br><span class="line">.then(goods =&gt;ajax(`http://localhost:8083/category?id=$&#123;goods[&quot;id&quot;]&#125;`))</span><br><span class="line">.then(data =&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function loadJS(file) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">            script.src &#x3D; file;</span><br><span class="line">            document.body.append(script);</span><br><span class="line">            script.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              resolve(script);</span><br><span class="line">            &#125;;</span><br><span class="line">            script.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              reject(script);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        loadJS(&quot;.&#x2F;js&#x2F;ashun.js&quot;)</span><br><span class="line">          .then((script) &#x3D;&gt; &#123;</span><br><span class="line">            title();</span><br><span class="line">            console.log(&quot;ashun.js finishLaod&quot;);</span><br><span class="line">            return script;</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((ashunjs) &#x3D;&gt; &#123;</span><br><span class="line">            return loadJS(&quot;.&#x2F;js&#x2F;SHUN.js&quot;).then((script) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(&quot;SHUN.js finishLaod&quot;);</span><br><span class="line">              run();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((script) &#x3D;&gt; console.log(&#96;$&#123;script.src&#125;：加载失败&#96;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>下面是封装的<code>timeout</code> 函数，使用定时器操作更加方便</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function timeout(times) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, times);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(3000)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;3秒后执行&quot;);</span><br><span class="line">    return timeout(1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;执行上一步的promise后1秒执行&quot;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>使用Promise封装 <code>setInterval</code> 定时器并实现动画效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background: pink;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        function interval(callback, delay &#x3D; 5) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            let id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">              callback(id, resolve);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div &#x3D; document.querySelector(&quot;div&quot;);</span><br><span class="line"></span><br><span class="line">        function run() &#123;</span><br><span class="line">          const step &#x3D; 2;</span><br><span class="line">          interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">            let left &#x3D; parseFloat(window.getComputedStyle(div).left);</span><br><span class="line">            if (left &gt;&#x3D; 200) &#123;</span><br><span class="line">              clearInterval(timer);</span><br><span class="line">              resolve(&quot;left end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            div.style.left &#x3D; left + step + &quot;px&quot;;</span><br><span class="line">          &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; &#123;</span><br><span class="line">              console.log(result);</span><br><span class="line">              return interval((timer, resolve) &#x3D;&gt; &#123;</span><br><span class="line">                let width &#x3D; parseFloat(window.getComputedStyle(div).width);</span><br><span class="line">                if (width &lt;&#x3D; 0) &#123;</span><br><span class="line">                  clearInterval(timer);</span><br><span class="line">                  resolve(&quot;width end&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                div.style.width &#x3D; width - step + &quot;px&quot;;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">            .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        div.addEventListener(&quot;click&quot;, run);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><ul>
<li>每个 <code>then</code> 都是一个promise，<code>then</code>会默认返回一个promise，且状态为fulfilled。</li>
<li>如果在 <code>then</code> 中手动返回一个新<code>promsie</code>，只当这个新的<code>promise</code> 确认状态后，才会继承执行下一个 <code>then</code></li>
</ul>
<h5 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h5><p>下面是对同一个 <code>promise</code> 分别使用不同的 <code>then</code> 进行操作 ，每个<code>then</code> 都得到了同一个promise 结果，这不是链式操作，实际使用意义不大。</p>
<img src="Promise.assets/Promise_then_1.png" alt="Promise_then_1" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(title &#x3D;&gt; &#123;</span><br><span class="line">  title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">  console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashuntefannao</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>promise</code> 中的 <code>then</code> 方法可以链式调用，<code>then</code> 方法的返回值会传递到下一个<code>then</code> 方法对应的处理函数中。</p>
<ul>
<li><code>then</code> 会返回一个<code>promise</code> ，所以如果有多个<code>then</code> 时会连续执行</li>
<li><code>then</code> 返回的值会做为当前<code>promise</code> 的结果</li>
</ul>
<p>下面是链式操作的 <code>then</code>，即始没有 <code>return</code> 也是会执行，因为每个<code>then</code> 默认会返回<code>promise</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashun&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun</span><br><span class="line">    return title;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((title) &#x3D;&gt; &#123;</span><br><span class="line">    title +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    console.log(title); &#x2F;&#x2F;阿顺特烦恼-Ashun-Ashuntefannao</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 方法可以返回一个新的<code>promise</code> 对象，等返回的<code>promise</code> 确认状态后，才会执行后面的 <code>then</code>。后面的<code>then</code> 方法就是对新返回的<code>promise</code> 状态的处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;第一个promise&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;第二个promise&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Promise类还提供一些静态方法，能够更好的处理异步操作。</p>
<ul>
<li>这些静态方法参数中若传入<code>非Promise</code>数据类型，则会将其转化为<code>Promise</code>,除了<code>reject</code>静态方法会默认将其转化为<code>Promise.resolve</code>,其余静态方法都会将其转化为<code>Promise.resolve</code>,数据本身作为返回结果。</li>
</ul>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p>使用 <code>promise.resolve(msg)</code> 方法可以快速的返回一个状态为resolve的promise对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(Promise.resolve(&quot;fulfilled&quot;));	//Promise &#123;&lt;fulfilled&gt;: &quot;fulfilled&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          reject(&quot;promise state: rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        promise</span><br><span class="line">          .then(null, (rej) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(rej);</span><br><span class="line">            return Promise.resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若传入值为promise，后续then处理的是传入的promsie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(Promise.reject(&quot;阿顺特烦恼&quot;)).catch((rej) &#x3D;&gt;console.log(rej));</span><br></pre></td></tr></table></figure>

<p>下面将请求结果缓存，如果再次请求时直接返回带值的 <code>promise</code></p>
<ul>
<li>为了演示使用了定时器，你也可以在后台设置延迟响应</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function query(name) &#123;</span><br><span class="line">  const cache = query.cache || (query.cache = new Map());</span><br><span class="line">  if (cache.has(name)) &#123;</span><br><span class="line">    console.log(&quot;走缓存了&quot;);</span><br><span class="line">    return Promise.resolve(cache.get(name));</span><br><span class="line">  &#125;</span><br><span class="line">  return ajax(`http://localhost:8083/users?name=$&#123;name&#125;`).then(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">      cache.set(name, response);</span><br><span class="line">      console.log(&quot;没走缓存&quot;);</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  query(&quot;阿顺&quot;).then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>如果是 <code>then able</code> (具有then能力，类似promise)对象，会将对象包装成promise处理，这与其他promise处理方式一样的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.resolve(as).then(value =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.resolve</code>,数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getName() &#123;</span><br><span class="line">  return &quot;ashun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Promise.resolve(getName).then((result) &#x3D;&gt; console.log(result()));</span><br><span class="line">&#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>



<h4 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h4><p>和 <code>Promise.resolve</code> 类似，<code>reject</code> 生成一个拒绝状态的<code>promise</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Promise.reject(&quot;fail&quot;).catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Project.reject</code> 设置状态</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve(&quot;阿顺特烦恼&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(v =&gt; &#123;</span><br><span class="line">  if (v != &quot;Ashuntefannao&quot;) return Promise.reject(new Error(&quot;not Ashuntefannao&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若传入非Promise数据，默认将其转化为<code>Promise.reject</code>数据本身作为<code>Promise.reject</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;name:&quot;Ashun&quot;&#125;;</span><br><span class="line">Promise.reject(obj).catch((reason) &#x3D;&gt; console.log(reason.name));</span><br><span class="line">&#x2F;&#x2F;Ashun</span><br></pre></td></tr></table></figure>



<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>使用<code>Promise.all(promiseArr)</code> 方法可以同时执行多个异步操作，比如页面加载时同进获取课程列表与推荐课程。</p>
<ul>
<li>任何一个 <code>Promise</code> 执行失败就会调用 <code>catch</code>方法</li>
<li>任何一个<code>Promise</code>没有确认状态，则all默认返回的promise状态也为pending，也就不会执行后续的then</li>
<li>适用于一次发送多个异步操作</li>
<li>参数必须是可迭代类型，如Array/Set</li>
<li>成功后返回包含 <code>promise</code> 结果的有序数组</li>
<li>若传入<code>非Promise</code>数据，则将其自动转化为<code>Promise.resolve</code>，数据本身作为返回值</li>
</ul>
<p>下例中当 <code>p1、p2</code> 两个 Promise 状态都为 <code>fulfilled</code> 时，p3状态才为<code>fulfilled</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 = new Promise((resolve) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&quot;p2 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p3 = Promise.all([p1, p2]).then(</span><br><span class="line">          (result) =&gt; console.log(result),</span><br><span class="line">          (err) =&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>若其中有一个promise状态为reject，则将调用<code>Promise.all()</code>后续<code>then</code>中的<code>onReject</code>，或<code>catch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;)</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2]).then(</span><br><span class="line">          (result) &#x3D;&gt; console.log(result),</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">…………</span><br><span class="line">let p3 &#x3D; Promise.all([p1, p2]).catch(</span><br><span class="line">          (err) &#x3D;&gt; console.log(err)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>若某个状态为<code>rejected</code>的Promise已经被自身的<code>then</code>处理 , 那么该Promise最后返回的状态是<code>fulfilled</code>,(<strong>then默认返回状态为fulfilled的Promise</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&quot;p1 state: fulfilled&quot;);</span><br><span class="line">          &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            reject(&quot;p2 state: reject&quot;);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">        &#125;).then(null, (err) &#x3D;&gt; err);</span><br><span class="line">        let p3 &#x3D; Promise.all([p1, p2])</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((err) &#x3D;&gt; console.log(&quot;有promise状态为rejected&quot;));</span><br><span class="line">          </span><br><span class="line">        &#x2F;&#x2F; [&quot;p1 state: fulfilled&quot;, &quot;p2 state: reject&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据用户名获取用户，有任何一个用户获取不到时 <code>promise.all</code> 状态失败，执行 <code>catch</code> 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status == 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [&quot;阿顺&quot;, &quot;张三&quot;].map(name =&gt; &#123;</span><br><span class="line">  return ajax(`$&#123;api&#125;/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>可以将其他<code>非promise</code> 数据添加到 <code>all</code> 中，它将被处理成 <code>Promise.resolve</code>，数据本身会被当做<code>Promise.resolve</code>的返回值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let getName = () =&gt; &quot;Ashun&quot;;</span><br><span class="line">        let Age = 18;</span><br><span class="line">        let promise = new Promise((resolve) =&gt; resolve(&quot;阿顺特烦恼&quot;));</span><br><span class="line">        Promise.all([getName, Age, promise]).then((result) =&gt;</span><br><span class="line">          console.log(result)</span><br><span class="line">        );</span><br><span class="line">        // [ƒ, 18, &quot;阿顺特烦恼&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h4><p><code>Promise.allSettled(PromsieArr)</code>，<strong>会将所有的Promsie视为已解决状态</strong>，会<code>忽略拒绝状态</code>的Promise，</p>
<p>拒绝状态的Promise信息，也会返回到最终的结果中。</p>
<ul>
<li>返回包含Promise状态和结果的有序数组</li>
<li><code>[&#123;status:resolve/reject,value/reason&#125;,&#123;…&#125;]</code></li>
</ul>
<p>下面的p2 返回状态为 <code>rejected</code> ，但<code>promise.allSettled</code> 不关心，<code>promise.allSettled</code>始终将自身状态设置为 <code>fulfilled</code> 。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          resolve(&quot;p1 resolved&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          reject(&quot;p2 rejected&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Promise.allSettled([p1, p2]).then((msg) =&gt; &#123;</span><br><span class="line">          console.log(msg);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line"> [</span><br><span class="line">	 &#123;status: &quot;fulfilled&quot;, value: &quot;p1 resolve&quot;&#125;,</span><br><span class="line">	 &#123;status: &quot;rejected&quot;, reason: &quot;p2 rejected&quot;&#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<p>下面是获取用户信息，但不关注某个用户是否获取不成功</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const api = &quot;http://localhost:8083&quot;;</span><br><span class="line">const promises = [</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=阿顺`),</span><br><span class="line">  ajax(`$&#123;api&#125;/users?name=张三`)</span><br><span class="line">];</span><br><span class="line">Promise.allSettled(promises).then(response =&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中若传入非promise数据类型，内部会转化为<code>Promise.resolve</code>,数据本身作为返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">				];</span><br><span class="line">Promise.allSettled(arr).then((result) &#x3D;&gt; console.log(result));</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">[</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: ƒ&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;,</span><br><span class="line">	&#123;status: &quot;fulfilled&quot;, value: 18&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>使用<code>Promise.race(promiseArr)</code> 能够处理容错异步，且返回最快确定状态的Promise结果，和<code>race</code>单词一样哪个Promise快用哪个，哪个先返回用哪个。</p>
<ul>
<li>以最快返回的promise为准</li>
<li>如果最快返加的状态为<code>rejected</code> 那整个<code>Promise.rece</code>状态为<code>rejected</code>执行cache</li>
<li>如果参数不是promise，内部将自动转为<code>Promise.resolve</code></li>
</ul>
<p>下例体现<code>Promise.rece</code>的特性，哪个Promise最先确定状态，就返回谁的处理结果。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第一个Promise&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个异步&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([p1, p2])</span><br><span class="line">.then(results =&gt; &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg =&gt; &#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// &quot;第二个异步&quot;</span><br></pre></td></tr></table></figure>

<p>可用其设置请求最长相应时间，下例：若请求在2秒内没有返回结果，则<code>promise.race</code> 状态失败,将会执行<code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const api &#x3D; &quot;http:&#x2F;&#x2F;localhost:8083&quot;;</span><br><span class="line">const promises &#x3D; [</span><br><span class="line">  ajax(&#96;$&#123;api&#125;&#x2F;users.php?name&#x3D;阿顺&#96;),</span><br><span class="line">  new Promise((a, b) &#x3D;&gt;</span><br><span class="line">    setTimeout(() &#x3D;&gt; b(new Error(&quot;request fail&quot;)), 2000)</span><br><span class="line">  )</span><br><span class="line">];</span><br><span class="line">Promise.race(promises)</span><br><span class="line">.then(response &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promises &#x3D; [</span><br><span class="line">          new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              resolve(&quot;请求成功&quot;);</span><br><span class="line">            &#125;, 1200);</span><br><span class="line">          &#125;),</span><br><span class="line">          new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              reject(&quot;请求超时&quot;);</span><br><span class="line">            &#125;, 1100);</span><br><span class="line">          &#125;),</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(promises)</span><br><span class="line">          .then((result) &#x3D;&gt; console.log(result))</span><br><span class="line">          .catch((reason) &#x3D;&gt; console.log(reason));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数不是promise，内部将自动转为<code>Promise.resolve</code>,且数据本身作为<code>Promise.resolve</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let arr &#x3D; [</span><br><span class="line">          function () &#123;</span><br><span class="line">            return &quot;ashun&quot;;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; name: &quot;ASHUN&quot; &#125;,</span><br><span class="line">          18,</span><br><span class="line">        ];</span><br><span class="line">        Promise.race(arr).then((result) &#x3D;&gt; console.log(result())); &#x2F;&#x2F;ashun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>如果在<code>then</code>中手动返回<code>promise</code> 时，后面的<code>then</code> 就是对返回的 <code>promise</code> 的处理</li>
<li>通过链式调用then，不断处理返回的Promsie，解决任务队列中的任务。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let promise = Promise.resolve();</span><br><span class="line">let p1 = promise.then(() =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p1`);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(() =&gt; &#123;</span><br><span class="line">  return new Promise((a, b) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`p2`);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let promise &#x3D; Promise.resolve();</span><br><span class="line">        promise &#x3D; promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;第一个then&quot;);</span><br><span class="line">            resolve(2);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(3);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        promise &#x3D; promise.then((index) &#x3D;&gt; &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;第$&#123;index&#125;个then&#96;);</span><br><span class="line">            resolve(4);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Array.map</code> 构建的队列，有以下几点需要说明</p>
<ul>
<li><code>then</code> 内部返回的 <code>Promise</code> 更改外部的 <code>promise</code> 变量</li>
<li>为了让任务继续下去，执行完任务需要将 <code>promise</code> 状态修改为 <code>fulfilled</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          let promise = Promise.resolve();</span><br><span class="line">          tasks.map((val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果</span><br><span class="line">shun-1</span><br><span class="line">第1个任务执行完毕，第2个任务开始执行</span><br><span class="line">Ashun-2</span><br><span class="line">第2个任务执行完毕，第3个任务开始执行</span><br><span class="line">Ashuntefannao-3</span><br></pre></td></tr></table></figure>

<p>下面再来通过 <code>reduce</code> 来实现队列</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function queue(tasks) &#123;</span><br><span class="line">          tasks.reduce((promise, val, index) =&gt; &#123;</span><br><span class="line">            promise = promise.then((result) =&gt; &#123;</span><br><span class="line">              result &amp;&amp; console.log(result);</span><br><span class="line">              return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                resolve(</span><br><span class="line">                  `第$&#123;index + 1&#125;个任务执行完毕，第$&#123;index + 2&#125;个任务开始执行`</span><br><span class="line">                );</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">          &#125;, Promise.resolve());</span><br><span class="line">        &#125;</span><br><span class="line">        queue([&quot;shun-1&quot;, &quot;Ashun-2&quot;, &quot;Ashuntefannao-3&quot;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="高可用封装"><a href="#高可用封装" class="headerlink" title="高可用封装"></a>高可用封装</h4><p>上例中处理是在队列中完成，不方便业务定制，下面将Promise处理在剥离到外部</p>
<p><strong>后台请求处理类</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export default function(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列处理类</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export default function(promises) &#123;</span><br><span class="line">  promises.reduce((promise, next) =&gt; promise.then(next), Promise.resolve())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后台脚本</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$users = [</span><br><span class="line">    1 =&gt; &quot;小明&quot;,</span><br><span class="line">    2 =&gt; &quot;李四&quot;,</span><br><span class="line">    3 =&gt; &quot;张三&quot;</span><br><span class="line">];</span><br><span class="line">sleep(1);</span><br><span class="line">echo $users[$_GET[&#x27;id&#x27;]];</span><br></pre></td></tr></table></figure>

<p><strong>使用队列</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import queue from &#x27;./queue.js&#x27;</span><br><span class="line">  import axios from &#x27;./axios.js&#x27;</span><br><span class="line">  queue(</span><br><span class="line">    [1, 2, 3].map(v =&gt; () =&gt;</span><br><span class="line">      axios(`user.php?id=$&#123;v&#125;`).then(user =&gt; console.log(user))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p> <code>async/await</code> 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。</p>
<ul>
<li><code>async/await</code> 本质还是promise，只是更简洁的语法糖书写</li>
<li><code>async/await</code> 使用更清晰的结构来替换 promise.then/catch 的方式</li>
<li><code>async/await</code>能够让异步代码，以<strong>同步的形式</strong>按顺序执行</li>
<li><code>async</code>声明的函数，会自动返回一个Promise。</li>
<li><code>await</code>必须在<code>async</code>声明的函数中使用。</li>
</ul>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>下面在 <code>fun</code> 函数前加上async，函数将默认返回一个状态为fulfilled的promise，函数体中使用return返回的数据，可以在后续的then中接收到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">				return &quot;阿顺特烦恼&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">fun().then((result) &#x3D;&gt; console.log(result));</span><br></pre></td></tr></table></figure>

<p>若要按顺序处理多个异步代码块，使用传统的<code>promise.then/catch</code>在整个代码结构上，不如使用<code>async/await</code>清晰。</p>
<p>下例通过处理相同的问题，进行对比</p>
<p>使用传统<code>Promise</code>处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function promise(text) &#123;</span><br><span class="line">          return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(text || &quot;第一个then&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        promise()</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第二个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">            return promise(&quot;第三个then&quot;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .then((result) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>async/await</code>处理可观察到，代码是按照同步形式执行的，结构更加清晰，代码量也减少了许多。</p>
<ul>
<li><code>await</code>相当于<code>then</code>，能够传递Promise的返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        async function promise(text) &#123;</span><br><span class="line">          return text || &quot;第一个then&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result1 &#x3D; await promise();</span><br><span class="line">          console.log(result1);</span><br><span class="line">          let result2 &#x3D; await promise(&quot;第二个then&quot;);</span><br><span class="line">          console.log(result2);</span><br><span class="line">          let result3 &#x3D; await promise(&quot;第三个then&quot;);</span><br><span class="line">          console.log(result3);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code>关键词后面紧跟Promise，使用 <code>await</code> 关键词，可以接收所处理的Promise的返回值，并且等待该Promise确定状态后，才可执行后面的代码。</p>
<ul>
<li><code>await</code> 后面一般是promise，如果不是直接返回</li>
<li><code>await</code> 必须放在 async 定义的函数中使用</li>
<li><code>await</code> 用于替代 <code>then</code> 使编码更优雅</li>
</ul>
<p>下例会在 await 这行等待promise执行，直到 promise 确认状态后才执行后续代码。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">  const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;Ashuntefannao&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">  let result = await promise;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>我们知道：在then中不能够返回所处理的Promise本身，会产生死循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; Promise.resolve().then((_) &#x3D;&gt; p1);</span><br></pre></td></tr></table></figure>

<p>同理在<code>async</code>声明的函数中，也不能使用<code>await</code>处理函数本身。</p>
<ul>
<li>等待fun返回的promise确认状态，而fun在调用时，又会等待自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fun() &#123;</span><br><span class="line">	await fun();</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>下面是请求后台获取用户课程成绩的示例</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function user() &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将操作放在立即执行函数中完成</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=向军`);</span><br><span class="line">  let lessons = await ajax(</span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>下面是使用async 设置定时器，并间隔时间来输出内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function sleep(ms = 2000) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function run() &#123;</span><br><span class="line">  for (const value of [&quot;阿顺特烦恼&quot;, &quot;Ashun&quot;]) &#123;</span><br><span class="line">    await sleep();</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>



<h4 id="加载进度"><a href="#加载进度" class="headerlink" title="加载进度"></a>加载进度</h4><p>下面是模拟请求后台查看进度，进度条展示的效果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 0px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">        color: white;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> &#123;			</span><br><span class="line"> 				//随机产生小于3秒的请求时间。</span><br><span class="line">        function randomTime() &#123;</span><br><span class="line">          let max = 3;</span><br><span class="line">          let min = 1;</span><br><span class="line">          let multiple = Math.floor(Math.random() * (1000 - 100 + 1) + 100);</span><br><span class="line">          return Math.floor(Math.random() * (max - min + 1) + min) * multiple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">				//模拟请求延时。</span><br><span class="line">        async function request() &#123;</span><br><span class="line">          return new Promise((resolve) =&gt; setTimeout(resolve, randomTime()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let div = document.querySelector(&quot;.loading&quot;);</span><br><span class="line">        //请求任务队列</span><br><span class="line">        let requsets = [request, request, request, request, request];</span><br><span class="line">        let sum = 0;</span><br><span class="line">        requsets.map(async (req) =&gt; &#123;</span><br><span class="line">          await req();</span><br><span class="line">          let percent = ++sum / requsets.length;</span><br><span class="line">          div.style.width = percent * 200 + &quot;px&quot;;</span><br><span class="line">          if (percent == 1) &#123;</span><br><span class="line">            div.innerHTML = &quot;加载完毕&quot;;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            div.innerHTML = percent * 100 + &quot;%&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="then-able"><a href="#then-able" class="headerlink" title="then able"></a>then able</h4><p>和 Promise 一样，await 也可以操作<code>then able</code> 对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    let user = ajax(`http://localhost:8083/user?name=$&#123;this.name&#125;`);</span><br><span class="line">    resolve(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async function get() &#123;</span><br><span class="line">  let user = await new User(&quot;阿顺&quot;);</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        async function run() &#123;</span><br><span class="line">          let result &#x3D; await user;</span><br><span class="line">          console.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">        run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象、类中的方法，也可以用<code>async/await</code>处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let user &#x3D; &#123;</span><br><span class="line">          name: &quot;阿顺&quot;,</span><br><span class="line">          then(resolve, reject) &#123;</span><br><span class="line">            return Promise.resolve().then((_) &#x3D;&gt;</span><br><span class="line">              setTimeout(resolve.bind(null, this.name), 1000)</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        let obj &#x3D; &#123;</span><br><span class="line">          async getName() &#123;</span><br><span class="line">            let result &#x3D; await user;</span><br><span class="line">            console.log(result);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    let user &#x3D; await ajax(</span><br><span class="line">      &#96;http:&#x2F;&#x2F;localhost:8083&#x2F;users?name&#x3D;$&#123;name&#125;&#96;</span><br><span class="line">    );</span><br><span class="line">    user.name +&#x3D; &quot;-Ashuntefannao&quot;;</span><br><span class="line">    return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new User().get(&quot;阿顺&quot;).then(resolve &#x3D;&gt; &#123;</span><br><span class="line">  console.log(resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="声明形式"><a href="#声明形式" class="headerlink" title="声明形式"></a>声明形式</h4><p>函数声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let get = async function(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line">get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对象方法声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">  	return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">as.get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>立即执行函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let user = await ajax(`http://localhost:8083/users?name=&quot;阿顺&quot;`);</span><br><span class="line">  let lessons = await ajax( </span><br><span class="line">    `http://localhost:8083/lessons?id=$&#123;user.id&#125;`</span><br><span class="line">  );</span><br><span class="line">  console.log(lessons);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>类方法中的使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  async get(name) &#123;</span><br><span class="line">    return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User().get(&quot;阿顺&quot;).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>async 内部发生错误，会将返回的promise状态置为rejected 状态，所以可以使用<code>catch</code> 来处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function as() &#123;</span><br><span class="line">  console.log(shun);</span><br><span class="line">&#125;</span><br><span class="line">as().catch(error =&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是异步请求数据不存在时的错误处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function get(name) &#123;</span><br><span class="line">  return await ajax(`http://localhost:8083/users?name=$&#123;name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(&quot;阿顺小哥&quot;).catch(error =&gt; &#123;</span><br><span class="line">  alert(&quot;用户不存在&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若await后的<code>promise</code> 被拒绝，并且没有使用<code>then\catch</code>处理，将抛出异常，可以使用 <code>try...catch</code> 处理错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let users = [&quot;阿顺&quot;, &quot;Ashun&quot;, &quot;shun&quot;];</span><br><span class="line"></span><br><span class="line">        async function getUser(name) &#123;</span><br><span class="line">        	let test = users.includes(name);</span><br><span class="line">          try &#123;</span><br><span class="line">            await new Promise((res, rej) =&gt; &#123;</span><br><span class="line">              console.log(test);</span><br><span class="line">              test ? res(test) : rej(`$&#123;name&#125; not find`);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getUser(&quot;阿顺A&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 await 时当前面的出现失败且未处理，后面的将不可以执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>如果对前一个错误进行了处理，后面的 await 可以继续执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  await Promise.reject(&quot;fail&quot;).catch(e =&gt; console.log(e));</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>try...catch</code> 特性忽略不必要的错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function promiseQueue() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&quot;fail&quot;);</span><br><span class="line">  &#125; catch (error) &#123;&#125;</span><br><span class="line">  await Promise.resolve(&quot;success&quot;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promiseQueue();</span><br></pre></td></tr></table></figure>

<p>也可以将多个 await 放在 try…catch 中统一处理错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function get(type) &#123;</span><br><span class="line">  const host = &quot;http://localhost:8083/&quot;</span><br><span class="line">  try &#123;</span><br><span class="line">    const goods = await ajax(`$&#123;host&#125;/goodsList?type=$&#123;type&#125;`);</span><br><span class="line">    const category = await ajax(`$&#123;host&#125;/category?id=$&#123;goods.id&#125;`);</span><br><span class="line">    console.log(lessons);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(&quot;商品不存在&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">get(&quot;new&quot;);</span><br></pre></td></tr></table></figure>



<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><p>有时需要多个await 同时执行，有以下几种方法处理，下面多个await 将产生等待</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function p1() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashuntefannao&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function p2() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;Ashun&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await p1();</span><br><span class="line">  await p2();</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>使用 <code>Promise.all()</code> 处理多个promise并行执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">async function promises() &#123;</span><br><span class="line">  await Promise.all([p1(), p2()]);</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>

<p>先执行返回promise，再使用await处理结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">async function promises() &#123;</span><br><span class="line">  let a1 = p1();</span><br><span class="line">  let a2 = p2();</span><br><span class="line">  await a1;</span><br><span class="line">  await a2;</span><br><span class="line">&#125;</span><br><span class="line">promises();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>对象是包括属性与方法的数据类型，JS中大部分类型都是对象如 <code>String/Number/Math/RegExp/Date</code> 等等。</p>
<p>传统的函数编程会有错中复杂的依赖很容易创造意大利式面条代码。</p>
<p><strong>面向过程编程</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let name = &quot;阿顺&quot;;</span><br><span class="line">let grade = [</span><br><span class="line">  &#123; lesson: &quot;js&quot;, score: 99 &#125;,</span><br><span class="line">  &#123; lesson: &quot;vue&quot;, score: 85 &#125;</span><br><span class="line">];</span><br><span class="line">function average(grade, name) &#123;</span><br><span class="line">  const total = grade.reduce((t, a) =&gt; t + a.score, 0);</span><br><span class="line">  return name + &quot;:&quot; + total / grade.length + &quot;分&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(average(grade, name));</span><br></pre></td></tr></table></figure>

<p><strong>面向对象编程</strong></p>
<p>下面使用对象编程的代码结构清晰，也减少了函数的参数传递，也不用担心函数名的覆盖</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;,</span><br><span class="line">  grade: [</span><br><span class="line">    &#123; lesson: &quot;js&quot;, score: 99 &#125;,</span><br><span class="line">    &#123; lesson: &quot;vue&quot;, score: 85 &#125;</span><br><span class="line">  ],</span><br><span class="line">  average() &#123;</span><br><span class="line">    const total = this.grade.reduce((t, a) =&gt; t + a.score, 0);</span><br><span class="line">    return this.name + &quot;:&quot; + total / this.grade.length + &quot;分&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(user.average());</span><br></pre></td></tr></table></figure>



<h4 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h4><p>OOP：**Object Oriented Programming **</p>
<p>特点：封装、继承、抽象、多态</p>
<ul>
<li>对象是属性和方法的集合即封装</li>
<li>将复杂功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响即抽象</li>
<li>继承是通过代码复用减少冗余代码</li>
<li>根据不同形态的对象产生不同结果即多态</li>
</ul>
<h4 id="基本声明"><a href="#基本声明" class="headerlink" title="基本声明"></a>基本声明</h4><p>使用字面量形式声明对象是最简单的方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;阿顺&#x27;,</span><br><span class="line">  getName:function() &#123;</span><br><span class="line">  	return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName()); //阿顺</span><br></pre></td></tr></table></figure>

<p><code>ES6</code>属性与方法简写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let name = &quot;阿顺&quot;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  get() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.get()); //阿顺</span><br></pre></td></tr></table></figure>

<p>其实字面量形式在系统内部也是使用构造函数 <code>new Object</code>创建的，后面会详细介绍构造函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;&#125;;</span><br><span class="line">let Ashun = new Object();</span><br><span class="line">console.log(as, Ashun);</span><br><span class="line">console.log(as.constructor);</span><br><span class="line">console.log(Ashun.constructor);</span><br></pre></td></tr></table></figure>



<h4 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h4><p>Object中包含属性和方法，属性用来标记Object的特点或状态，方法用来操作属性或完成其它功能。</p>
<p>定义在对象中的函数我们称为方法，下面定义了学生对象，并提供了计算平均成绩的方法。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let ashun = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;,</span><br><span class="line">  age: 21,</span><br><span class="line">  grade: &#123;</span><br><span class="line">    math: 88,</span><br><span class="line">    english: 67</span><br><span class="line">  &#125;,</span><br><span class="line">  //平均成绩</span><br><span class="line">  avgGrade: function() &#123;</span><br><span class="line">    let total = 0;</span><br><span class="line">    for (const key in this.grade) &#123;</span><br><span class="line">      total += this.grade[key];</span><br><span class="line">    &#125;</span><br><span class="line">    return total / this.propertyCount(&quot;grade&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  //获取属性数量</span><br><span class="line">  propertyCount: function(property) &#123;</span><br><span class="line">		return Object.keys(this[property]).reduce((pre, val) =&gt; (pre += 1),0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(ashun.avgGrade());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个学生需要手动创建一个对象，设置对应的属性和方法，这显然是不实际的，后面章节构造函数就可以解决这个问题</p>
</blockquote>
<hr>
<h4 id="引用特性"><a href="#引用特性" class="headerlink" title="引用特性"></a>引用特性</h4><p>对象和函数、数组一样是引用类型，即复制只会复制引用地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123; name: &quot;阿顺&quot; &#125;;</span><br><span class="line">let user = as;</span><br><span class="line">user.name = &quot;Ashun&quot;;</span><br><span class="line">console.log(as.name); //Ashun</span><br></pre></td></tr></table></figure>

<p>对象做为函数参数使用时也不会产生完全赋值，传递的依旧是内存地址，内外共用一个对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123; age: 15 &#125;;</span><br><span class="line">function as(user) &#123;</span><br><span class="line">  user.age += 3;</span><br><span class="line">&#125;</span><br><span class="line">as(user);</span><br><span class="line">console.log(user.age); //18</span><br></pre></td></tr></table></figure>

<p><code>引用类型变量</code>之间的比较是对<code>内存地址</code>的比较所以使用 <code>==</code> 或 <code>===</code> 结果一样。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;&#125;;</span><br><span class="line">let js = as;</span><br><span class="line">let tfn = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(as == js); //true</span><br><span class="line">console.log(as === js); //true</span><br><span class="line"></span><br><span class="line">console.log(as == tfn); //false</span><br><span class="line">console.log(as === tfn); //false</span><br></pre></td></tr></table></figure>

<h6 id="Object-is-arg1-arg2"><a href="#Object-is-arg1-arg2" class="headerlink" title="Object.is(arg1,arg2)"></a>Object.is(arg1,arg2)</h6><p>该方法用于判断二者是否恒等，其中注意的是，<code>Object.is</code>方法在<code>===</code>的基础上，做了一些特殊情况的优化。具体来说就是+0和-0，NaN和NaN。</p>
<p><code>0===-0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(-0 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F;true</span><br><span class="line">console.log(Object.is(0, -0));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p><code>NaN===NaN</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(NaN &#x3D;&#x3D; NaN); &#x2F;&#x2F;false</span><br><span class="line">console.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F;false</span><br><span class="line">console.log(Object.is(NaN, NaN));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>我们也可使用全局静态方法<code>isNaN</code>进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a&#x3D; 1 &#x2F; &quot;s&quot;</span><br><span class="line">console.log(isNaN(a)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><code>this</code> 指当前对象的引用，始终建议在代码内部使用<code>this</code> 而不要使用对象名，不同对象的this只指向当前对象。</p>
<p>下例是不使用 <code>this</code> 时发生错误的场景</p>
<ul>
<li>删除了<code>as</code> 变量，但在函数体内还在使用<code>as</code>变量造成错误</li>
<li>使用 <code>this</code> 后，始终指向到当前引用地址，就不会有这个问题</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">	show() &#123;</span><br><span class="line">		return as.name;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let user = as;</span><br><span class="line">as = null;</span><br><span class="line">console.log(user.show()); //TypeError: Cannot read property &#x27;name&#x27; of null</span><br></pre></td></tr></table></figure>

<p>改用<code>this</code> 后一切正常</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">	show() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let user = as;</span><br><span class="line">as = null;</span><br><span class="line">console.log(user.show());	//阿顺</span><br></pre></td></tr></table></figure>



<h4 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h4><p>使用<code>...</code>可以将对象的各个属性展开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function upload(params) &#123;</span><br><span class="line">  let config &#x3D; &#123;</span><br><span class="line">    type: &quot;*.jpeg,*.png&quot;,</span><br><span class="line">    size: 10000</span><br><span class="line">  &#125;;</span><br><span class="line">  params &#x3D; &#123; ...config, ...params &#125;;	&#x2F;&#x2F;传参覆盖默认值</span><br><span class="line">  console.log(params);</span><br><span class="line">&#125;</span><br><span class="line">upload(&#123; size: 999 &#125;);</span><br></pre></td></tr></table></figure>

<p><code>...</code>用作收集时，还是用数组形式<code>[]</code>包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;ashun&quot; &#125;;</span><br><span class="line">function test(...obj) &#123;</span><br><span class="line">		console.log(obj);</span><br><span class="line">&#125;</span><br><span class="line">test(as);	&#x2F;&#x2F;[&#123;…&#125;]</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><h5 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h5><p>对象直接参与计算时，系统会根据计算的场景在 <code>string/number/default</code> 间转换。</p>
<ul>
<li>如果声明需要字符串类型，调用顺序为 <code>toString &gt; valueOf</code></li>
<li>如果场景需要数值类型，调用顺序为 <code>valueOf &gt; toString</code></li>
<li>声明不确定时使用 <code>default</code> ，大部分对象的 <code>default</code> 会当数值使用</li>
<li>若对象中同时定义了<code>Symbol.toPrimitive</code>方法，则会优先执行其中对数据类型转化的处理</li>
</ul>
<p>下面的数值对象会在数学运算时转换为 <code>number</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let ashun = new Number(1);</span><br><span class="line">console.log(ashun + 5); //6</span><br></pre></td></tr></table></figure>

<p>如果参数字符串运长时会转换为 <code>string</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let ashun = new Number(1);</span><br><span class="line">console.log(ashun + &quot;5&quot;); //15</span><br></pre></td></tr></table></figure>

<p>下面当不确定转换声明时使用 <code>default</code> ，大部分<code>default</code>转换使用 <code>number</code> 转换。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let ashun = new Number(1);</span><br><span class="line">console.log(ashun == &quot;1&quot;); //true</span><br></pre></td></tr></table></figure>



<h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>内部自定义<code>Symbol.toPrimitive</code>方法用来处理所有的转换场景</p>
<p><code>Symbol.toPrimitive</code> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123;</span><br><span class="line">	num: 1,</span><br><span class="line">	str: &quot;ashun&quot;,</span><br><span class="line">	[Symbol.toPrimitive]: function (hint) &#123;</span><br><span class="line">		if (hint &#x3D;&#x3D; &quot;number&quot;) return this.num;</span><br><span class="line">		if (hint &#x3D;&#x3D; &quot;string&quot;) return this.str;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(+as); &#x2F;&#x2F;1</span><br><span class="line">console.log(String(as)); &#x2F;&#x2F;ashun</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  num: 1,</span><br><span class="line">  [Symbol.toPrimitive]: function() &#123;</span><br><span class="line">    return this.num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(as+ 1); //2</span><br><span class="line">console.log(as+&quot;1&quot;)	//11</span><br></pre></td></tr></table></figure>



<h5 id="valueOf-toString"><a href="#valueOf-toString" class="headerlink" title="valueOf/toString"></a>valueOf/toString</h5><p>可以自定义<code>valueOf</code> 与 <code>toString</code> 方法用来转换，转换并不限制返回类型。</p>
<p>下例能验证:</p>
<ul>
<li>如果声明需要字符串类型，调用顺序为 <code>toString &gt; valueOf</code></li>
<li>如果场景需要数值类型，调用顺序为 <code>valueOf &gt; toString</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = &#123;</span><br><span class="line">  name: &quot;Ashun&quot;,</span><br><span class="line">  num: 1,</span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line">    console.log(&quot;valueOf&quot;);</span><br><span class="line">    return this.num;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function() &#123;</span><br><span class="line">    console.log(&quot;toString&quot;);</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(as + 5); //valueOf 4</span><br><span class="line">console.log(`$&#123;as&#125;阿顺`); //toString Ashun阿顺</span><br></pre></td></tr></table></figure>

<p>若对象中在定义<code>toString/valueOf</code>方法的同时，又定义了<code>Symbol.toPrimitive</code>方法，则会优先执行其中对数据类型转化的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  name: &quot;Ashun&quot;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]: function (hint) &#123;</span><br><span class="line">    if (hint &#x3D;&#x3D; &quot;string&quot;) return &quot;Ashuntefannao&quot;;</span><br><span class="line">    if (hint &#x3D;&#x3D; &quot;number&quot;) return 7;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(String(obj)); &#x2F;&#x2F;Ashuntefannao</span><br><span class="line">console.log(++obj);   &#x2F;&#x2F;8</span><br></pre></td></tr></table></figure>



<h5 id="与"><a href="#与" class="headerlink" title="==与==="></a><code>==</code>与<code>===</code></h5><p>对于==与===，我们已经不陌生了，==判定的是等式两边的值是否相同，但===是严格等于，不仅要求值相等，还要满足类型相同。</p>
<p>但是对于使用==判断时，对于不同的场景，也涉及到了类型的转换</p>
<ul>
<li>等式两边类型相同，就比较值的大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1 &#x3D;&#x3D; 2) &#x2F;&#x2F;false</span><br><span class="line">console.log(&quot;abc&quot; &#x3D;&#x3D; &quot;abc&quot;) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<ul>
<li>等式两边为<code>null</code>|<code>undefined</code>时，返回<code>true</code><ul>
<li>aa已定义，但是未赋值，为<code>null</code></li>
<li>由于<code>null==undefined</code>得<code>aa == undefined</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let aa;</span><br><span class="line">console.log(aa &#x3D;&#x3D; null);</span><br><span class="line">console.log(aa &#x3D;&#x3D; undefined);</span><br><span class="line">console.log(null &#x3D;&#x3D; undefined);</span><br></pre></td></tr></table></figure>

<ul>
<li>其中一方为Number，则会先转化为Number再比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  name: &quot;Ashun&quot;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj &#x3D;&#x3D; 123);</span><br><span class="line">console.log(1 &#x3D;&#x3D; true);</span><br><span class="line">console.log(1 &#x3D;&#x3D; &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  name: &quot;Ashun&quot;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(true &#x3D;&#x3D; obj);</span><br></pre></td></tr></table></figure>

<h6 id="如何让if-a-1-amp-amp-a-2-条件成立？"><a href="#如何让if-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="如何让if(a == 1 &amp;&amp; a == 2)条件成立？"></a>如何让if(a == 1 &amp;&amp; a == 2)条件成立？</h6><p>其实就是上一个问题的应用，利用类型转化的过程，在其中做操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  num: 1,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return this.num++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2);</span><br></pre></td></tr></table></figure>




<hr>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构，在数组章节已经介绍过。</p>
<ul>
<li>建设使用 <code>var/let/const</code> 声明</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>下面是基本使用语法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let info = &#123; name: &quot;阿顺&quot;, site: &quot;Ashuntefannao.com&quot; &#125;;</span><br><span class="line">	let &#123; name: n, site: u &#125; = info;</span><br><span class="line">	console.log(n, u); // 阿顺 Ashuntefannao.com</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">//如果属性名与变量相同可以省略属性定义`ES6简写形式`。</span><br><span class="line">	let info = &#123; name: &quot;阿顺&quot;, site: &quot;Ashuntefannao.com&quot; &#125;;</span><br><span class="line">	let &#123; name &#125; = info;</span><br><span class="line">	console.log(name); // 阿顺</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回值直接解构到变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function user(&#123; name, type &#125;) &#123;</span><br><span class="line">	console.log(name, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let as = &#123; name: &quot;Ashun&quot;, type: &quot;Controller&quot; &#125;;</span><br><span class="line">user(as);</span><br></pre></td></tr></table></figure>

<p>系统函数解构练习，这没有什么意义只是加深解构印象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const &#123;random,min,max&#125; =Math;</span><br><span class="line">console.log(random,max);</span><br></pre></td></tr></table></figure>

<p>可以直接使用变量赋值对象属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let name = &quot;阿顺&quot;,url = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">//标准写法如下</span><br><span class="line">&#123;</span><br><span class="line">	let as = &#123; name: name, url: url &#125;;</span><br><span class="line">	console.log(as);  //&#123;name: &quot;阿顺&quot;, url: &quot;Ashuntefannao.com&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6简写形式</span><br><span class="line">&#123;</span><br><span class="line">	let as = &#123; name, url &#125;;</span><br><span class="line">	console.log(as); //&#123;name: &quot;阿顺&quot;, url: &quot;Ashuntefannao.com&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>可以操作多层复杂数据结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &#123;</span><br><span class="line">  name:&#x27;阿顺&#x27;,</span><br><span class="line">  lessons:&#123;</span><br><span class="line">    title:&#x27;JS&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const &#123;name,lessons:&#123;title&#125;&#125;  = as;</span><br><span class="line">console.log(name,title); //阿顺 JS</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// &quot;use strict&quot;;</span><br><span class="line">(&#123; name, url &#125; = &#123; name: &quot;阿顺&quot;, url: &quot;Ashuntefannao.com&quot; &#125;);</span><br><span class="line">console.log(name, url);</span><br></pre></td></tr></table></figure>

<p>还是建议使用<code>let</code>等赋值声明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let &#123; name, url &#125; = &#123; name: &quot;阿顺&quot;, url: &quot;Ashuntefannao.com&quot; &#125;;</span><br><span class="line">console.log(name, url);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>为变量设置默认值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let [Name, site = &quot;Ashuntefannao.com&quot;] = [&quot;阿顺&quot;];</span><br><span class="line">console.log(site); //Ashuntefannao.com</span><br><span class="line"></span><br><span class="line">let &#123; name, url, type = &quot;Controller&quot; &#125; = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">	url: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(type); //Controller</span><br></pre></td></tr></table></figure>

<p>使用默认值特性可以方便的对参数预设</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function createElement(options) &#123;</span><br><span class="line">	let &#123;</span><br><span class="line">		name = &quot;div&quot;,</span><br><span class="line">		width = &quot;200px&quot;,</span><br><span class="line">		height = &quot;100px&quot;,</span><br><span class="line">		backgroundColor = &quot;red&quot;,</span><br><span class="line">	&#125; = options;</span><br><span class="line"></span><br><span class="line">	const dom = document.createElement(name);</span><br><span class="line">	dom.style.width = width;</span><br><span class="line">	dom.style.height = height;</span><br><span class="line">	dom.style.backgroundColor = backgroundColor;</span><br><span class="line">	document.body.appendChild(dom);</span><br><span class="line">&#125;</span><br><span class="line">createElement(&#123;</span><br><span class="line">backgroundColor: &quot;green&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可使用<code>展开语法</code>或<code>Object.assign</code>，将默认obj与传入的options合并。（<code>Object.assign</code>后面章节会详细介绍）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createElement(options) &#123;</span><br><span class="line">	let preset &#x3D; &#123;</span><br><span class="line">		name: &quot;div&quot;,</span><br><span class="line">		width: &quot;200px&quot;,</span><br><span class="line">		height: &quot;100px&quot;,</span><br><span class="line">		backgroundColor: &quot;red&quot;,</span><br><span class="line">	&#125;;</span><br><span class="line">	preset &#x3D; Object.assign(preset, options);</span><br><span class="line">	&#x2F;&#x2F;preset &#x3D; &#123; ...preset, ...options &#125;;</span><br><span class="line">	const dom &#x3D; document.createElement(preset.name);</span><br><span class="line">	for (const key in preset) &#123;</span><br><span class="line">		key !&#x3D; &quot;name&quot; &amp;&amp; (dom.style[key] &#x3D; preset[key]);</span><br><span class="line">	&#125;</span><br><span class="line">	document.body.appendChild(dom);</span><br><span class="line">&#125;</span><br><span class="line">createElement(&#123;</span><br><span class="line">	backgroundColor: &quot;#16a085&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><hr>
<p>数组参数的使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function as([a, b]) &#123;</span><br><span class="line">	console.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">as([&#x27;阿顺&#x27;, &#x27;SHUN&#x27;]);</span><br></pre></td></tr></table></figure>

<p>对象参数使用方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function getUser(&#123;name,url,type=&#x27;Controller&#x27;&#125;) &#123;</span><br><span class="line">	console.log(name,url,type);</span><br><span class="line">&#125;</span><br><span class="line">getUser(&#123;name:&#x27;阿顺&#x27;,url:&#x27;Ashuntefannao.com&#x27;&#125;); //阿顺 Ashuntefannao.com Controller</span><br></pre></td></tr></table></figure>

<p>对象解构传参</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function user(name, &#123; sex, age &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(name, sex, age); //阿顺 男 18</span><br><span class="line">&#125;</span><br><span class="line">user(&quot;阿顺&quot;, &#123; sex: &quot;男&quot;, age: 18 &#125;);</span><br></pre></td></tr></table></figure>









<h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><h5 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h5><p><code>对象的属性名类型为:String</code></p>
<p>对象的属性名最终都会转为<code>字符串</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123; 1: &quot;ashun&quot;, &quot;1&quot;: &quot;Ashuntefannao&quot; &#125;;</span><br><span class="line">console.table(obj); //&#123;1:&quot;Ashuntefannao&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>使用对象做为键名时，也会将对象转为字符串后使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123; 1: &quot;ashun&quot;, &quot;1&quot;: &quot;Ashuntefannao&quot; &#125;;</span><br><span class="line"></span><br><span class="line">let as = &#123; [obj]: &quot;阿顺&quot; &#125;;</span><br><span class="line">console.table(as);</span><br><span class="line"></span><br><span class="line">console.log(as[obj.toString()]);</span><br><span class="line">console.log(as[&quot;[object Object]&quot;]);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h5><ul>
<li><code>obj.prop</code></li>
<li><code>obj[prop]</code><ul>
<li>当属性名称：不合法时、为变量时，可通过<code>[prop]</code>进行设置。</li>
</ul>
</li>
<li><code>Object.defineProperty(obj,prop,&#123;desc…&#125;)</code><ul>
<li>设置属性的描述，若该属性不存在，则添加该属性到obj上。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">user.name &#x3D; &quot;Ashun&quot;;</span><br><span class="line">user[&quot;user-type&quot;] &#x3D; &quot;Controller&quot;;</span><br><span class="line">let like &#x3D; &quot;like&quot;;</span><br><span class="line">user[like] &#x3D; &quot;javascript&quot;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(user, &quot;age&quot;, &#123;</span><br><span class="line">	value: 18,</span><br><span class="line">	writable: true,</span><br><span class="line">	enumerable: true,</span><br><span class="line">	configurable: true,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(user);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#123;name: &quot;Ashun&quot;, user-type: &quot;Controller&quot;, like: &quot;javascript&quot;, age: 18&#125;</span><br></pre></td></tr></table></figure>





<h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><p><code>delete obj.prop</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">user.name &#x3D; &quot;Ashun&quot;;</span><br><span class="line">user[&quot;user-type&quot;] &#x3D; &quot;Controller&quot;;</span><br><span class="line">let like &#x3D; &quot;like&quot;;</span><br><span class="line">user[like] &#x3D; &quot;javascript&quot;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(user, &quot;age&quot;, &#123;</span><br><span class="line">	value: 18,</span><br><span class="line">	writable: true,</span><br><span class="line">	enumerable: true,</span><br><span class="line">	configurable: true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for (const key of Object.keys(user)) &#123;</span><br><span class="line">		key !&#x3D;&#x3D; &quot;name&quot; &amp;&amp; delete user[key];</span><br><span class="line">&#125;</span><br><span class="line">console.log(user);	&#x2F;&#x2F;&#123;name:&quot;Ashun&quot;&#125;</span><br></pre></td></tr></table></figure>



<h5 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h5><ul>
<li>在访问某属性的同时，赋值即可<ul>
<li><code>obj.prop=value</code></li>
<li><code>obj[prop]=value</code></li>
</ul>
</li>
<li><code>Object.defineProperty(obj,propName,&#123;…desc&#125;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let type&#x3D;&quot;type&quot;;</span><br><span class="line">let user &#x3D; &#123;</span><br><span class="line">	name: &quot;defult&quot;,</span><br><span class="line">	age: &quot;18&quot;,</span><br><span class="line">	[type]: &quot;user&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">user.name &#x3D; &quot;Ashun&quot;;</span><br><span class="line">user[type] &#x3D; &quot;Controller&quot;;</span><br><span class="line">console.log(user);	&#x2F;&#x2F;&#123;name: &quot;Ashun&quot;, age: &quot;18&quot;, type: &quot;Controller&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;</span><br><span class="line">	name: &quot;Ashun&quot;,</span><br><span class="line">	age: &quot;18&quot;,</span><br><span class="line">	type: &quot;user&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(user, &quot;type&quot;, &#123;</span><br><span class="line">	value: &quot;Controller&quot;,</span><br><span class="line">	writable: true,</span><br><span class="line">	enumerable: true,</span><br><span class="line">	configurable: true,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(user.type); &#x2F;&#x2F;Controller</span><br></pre></td></tr></table></figure>



<h5 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h5><h6 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h6><p><code>obj.hasOwnProperty(prop)</code>检测对象<code>自身</code>是否包含指定的属性，<code>不检测原型链上继承的属性</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123; name: &#x27;阿顺&#x27;&#125;;</span><br><span class="line">console.log(obj.hasOwnProperty(&#x27;name&#x27;)); //true</span><br></pre></td></tr></table></figure>

<p>不检测原型链上继承的属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let arr = [&quot;阿顺&quot;];</span><br><span class="line">	console.log(arr.hasOwnProperty(&quot;length&quot;)); //true</span><br><span class="line">	console.log(arr.hasOwnProperty(&quot;concat&quot;)); //false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	let Admin=&#123;type:&quot;Controler&quot;&#125;</span><br><span class="line">	let as=&#123;name:&quot;阿顺&quot;,age:18&#125;;</span><br><span class="line">	as.__proto__=Admin;</span><br><span class="line">	console.log(as.hasOwnProperty(&quot;age&quot;))//true</span><br><span class="line">	console.log(as.type);	//Controler</span><br><span class="line">	console.log(as.hasOwnProperty(&quot;type&quot;))//false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="in"><a href="#in" class="headerlink" title="in"></a>in</h6><p><code>prop in obj</code> 使用<code>in</code>关键字，能够判断某属性是否在obj<code>本身或原型链上</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot; &#125;;</span><br><span class="line">let site &#x3D; &#123;</span><br><span class="line">	web: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置site为as的新原型</span><br><span class="line">Object.setPrototypeOf(as, site);</span><br><span class="line">&#x2F;&#x2F; as.__proto__ &#x3D; site;</span><br><span class="line">console.dir(as);</span><br><span class="line"></span><br><span class="line">console.log(&quot;name&quot; in as); &#x2F;&#x2F;true</span><br><span class="line">console.log(&quot;web&quot; in as); &#x2F;&#x2F;true</span><br><span class="line">console.log(as.hasOwnProperty(&quot;web&quot;)); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="获取属性名"><a href="#获取属性名" class="headerlink" title="获取属性名"></a>获取属性名</h5><h6 id="获取普通属性"><a href="#获取普通属性" class="headerlink" title="获取普通属性"></a>获取普通属性</h6><p>以下方式只能够获取普通属性，不能够获取属性名为Symbol类型的属性。</p>
<ul>
<li><code>for/in</code></li>
<li><code>Object.getOwnPropertyNames(obj)</code></li>
<li><code>Object.keys(obj)</code></li>
</ul>
<p>使用<code>Object的静态方法</code>或<code>Reflect</code>获得的属性名称，都是某<strong>obj本身的prop</strong>，如果使用<code>for/in</code>会遍历到<code>原型上</code>的普通属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Admin &#x3D; &#123; type: &quot;Controller&quot; ,[Symbol(&quot;Admin&quot;)]: &quot;Admin&quot;&#125;;</span><br><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol(&quot;as&quot;)]: &quot;ashun&quot; &#125;;</span><br><span class="line">Object.setPrototypeOf(as, Admin);</span><br><span class="line"></span><br><span class="line">for (const key in as) console.log(key);	&#x2F;&#x2F;name age type</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(as));		 	&#x2F;&#x2F;[&quot;name&quot;,&quot;age&quot;]</span><br><span class="line">console.log(Object.keys(as));										 	&#x2F;&#x2F;[&quot;name&quot;,&quot;age&quot;]</span><br><span class="line">console.log(Object.getOwnPropertySymbols(as));		&#x2F;&#x2F;[Symbol(as)]</span><br><span class="line">console.log(Reflect.ownKeys(as));									&#x2F;&#x2F;[&quot;name&quot;, &quot;age&quot;, Symbol(as)]</span><br></pre></td></tr></table></figure>

<p>当我们使用ES6的<code>class</code>声明构造函数时，就不用考虑<code>for/in</code>循环遍历原型属性的问题了</p>
<ul>
<li>内部默认严格模式</li>
<li>class声明的方法自动添加到原型链，且自动设置各个方法的属性特征描述为<code>enumerable:false</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">          constructor(options) &#123;</span><br><span class="line">            for (let [key, val] of Object.entries(options)) &#123;</span><br><span class="line">              this[key] &#x3D; val;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          show() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">          &#125;</span><br><span class="line"> 				&#125;</span><br><span class="line">let p1 &#x3D; new Person(&#123; name: &quot;Ashun&quot;, age: 18, type: &quot;Controller&quot; &#125;);</span><br><span class="line">console.log(Object.keys(p1)); [&quot;name&quot;,&quot;age&quot;,&quot;type&quot;]</span><br><span class="line">for (let key in p1) &#123;</span><br><span class="line">	console.log(key);		&#x2F;&#x2F;name,age,type	而没有show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h6 id="获取Symbol"><a href="#获取Symbol" class="headerlink" title="获取Symbol"></a>获取Symbol</h6><ul>
<li><code>getOwnPropertySymbols</code> 该方法<code>只返回</code>属性名称类型为Symbol的属性名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol()]: &quot;ashun&quot; &#125;;</span><br><span class="line">console.log(Object.getOwnPropertySymbols(as)); &#x2F;&#x2F;[Symbol()]</span><br></pre></td></tr></table></figure>



<hr>
<h6 id="获取所有属性"><a href="#获取所有属性" class="headerlink" title="获取所有属性"></a>获取所有属性</h6><ul>
<li><code>Reflect.ownKeys</code>，该方法能够返回所有类型的属性名，包括Symbol。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol()]: &quot;ashun&quot; &#125;;</span><br><span class="line">console.log(Reflect.ownKeys(as));	&#x2F;&#x2F;[&quot;name&quot;, &quot;age&quot;, Symbol()]</span><br></pre></td></tr></table></figure>



<h5 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h5><h6 id="普通访问"><a href="#普通访问" class="headerlink" title="普通访问"></a>普通访问</h6><ul>
<li><code>obj.prop</code></li>
<li><code>obj[prop]</code></li>
</ul>
<h6 id="查看描述"><a href="#查看描述" class="headerlink" title="查看描述"></a>查看描述</h6><ul>
<li><code>Object.getOwnPropertyDescriptors(obj)</code></li>
<li><code>Object.getOwnPropertyDescriptor(obj,&quot;propName&quot;)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Admin &#x3D; &#123; type: &quot;Controller&quot;, [Symbol(&quot;Admin&quot;)]: &quot;Admin&quot; &#125;;</span><br><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol(&quot;as&quot;)]: &quot;ashun&quot; &#125;;</span><br><span class="line">Object.setPrototypeOf(as, Admin);</span><br><span class="line"></span><br><span class="line">console.log(as.type); &#x2F;&#x2F;Controller</span><br><span class="line">console.log(as[&quot;age&quot;]); &#x2F;&#x2F;18</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(as, &quot;name&quot;));</span><br><span class="line">&#x2F;&#x2F;&#123;value: &quot;阿顺&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(as));</span><br><span class="line">&#x2F;&#x2F;&#123;name: &#123;…&#125;, age: &#123;…&#125;, Symbol(as): &#123;…&#125;&#125;</span><br></pre></td></tr></table></figure>



<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>使用 <code>Object.assign()</code> 静态方法，能够将多个Object的属性值进行合并。当prop的值为非引用类型时，可以用来做深拷贝。</p>
<p>从一个或多个对象复制属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">let as = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">as = Object.assign(as, &#123; a: 3 &#125;, &#123; m: 9 &#125;);</span><br><span class="line">console.log(as); 	//&#123;a: 3, b: 2, m: 9&#125;</span><br></pre></td></tr></table></figure>

<p>可以让传递的参数覆盖默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(options) &#123;</span><br><span class="line">		let preset &#x3D; &#123;</span><br><span class="line">			name: &quot;default&quot;,</span><br><span class="line">			age: 18,</span><br><span class="line">			type: &quot;user&quot;,</span><br><span class="line">		&#125;;</span><br><span class="line">		return (preset &#x3D; Object.assign(preset, options));</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(&#123; name: &quot;Ashun&quot;, type: &quot;Controller&quot; &#125;));</span><br><span class="line">&#x2F;&#x2F;&#123;name: &quot;Ashun&quot;, age: 18, type: &quot;Controller&quot;&#125;</span><br></pre></td></tr></table></figure>



<h5 id="传址操作"><a href="#传址操作" class="headerlink" title="传址操作"></a>传址操作</h5><p>对象是引用类型赋值是传址操作，后面会介绍对象的深、浅拷贝操作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">	name: &#x27;阿顺&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">let as = &#123;</span><br><span class="line">	stu: user</span><br><span class="line">&#125;;</span><br><span class="line">as.stu.name = &#x27;Ashun&#x27;;</span><br><span class="line">console.log(user.name);//Ashun</span><br></pre></td></tr></table></figure>



<h5 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h5><p>对象属性可以通过<code>表达式计算</code>定义，这在动态设置属性或执行属性方法时很好用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let id = 0;</span><br><span class="line">const user = &#123;</span><br><span class="line">  [`id-$&#123;id++&#125;`]: id,</span><br><span class="line">  [`id-$&#123;id++&#125;`]: id,</span><br><span class="line">  [`id-$&#123;id++&#125;`]: id</span><br><span class="line">&#125;;</span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure>

<p>使用计算属性为文章定义键名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const lessons = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;媒体查询响应式布局&quot;,</span><br><span class="line">    category: &quot;css&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;FLEX 弹性盒模型&quot;,</span><br><span class="line">    category: &quot;css&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;MYSQL多表查询随意操作&quot;,</span><br><span class="line">    category: &quot;mysql&quot;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">let lessonObj = lessons.reduce((obj, cur, index) =&gt; &#123;</span><br><span class="line">  obj[`$&#123;cur[&quot;category&quot;]&#125;-$&#123;index&#125;`] = cur;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">console.log(lessonObj); //&#123;css-0: &#123;…&#125;, css-1: &#123;…&#125;, mysql-2: &#123;…&#125;&#125;</span><br><span class="line">console.log(lessonObj[&quot;css-1&quot;]); //&#123;title: &quot;FLEX 弹性盒模型&quot;, category: &quot;css&quot;&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>可以使用系统提供的迭代器API，迭代遍历Object。</p>
<p>这些方法，只能够得到：<strong>对象本身的、可枚举的属性</strong></p>
<ul>
<li><code>Object.keys(obj)</code></li>
<li><code>Object.values(obj)</code></li>
<li><code>Object.entries(obj)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol(&quot;as&quot;)]: &quot;ashun&quot; &#125;;</span><br><span class="line">console.log(Object.keys(as));			&#x2F;&#x2F;[&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">console.log(Object.values(as));		&#x2F;&#x2F;[&quot;阿顺&quot;, 18]</span><br><span class="line">console.log(Object.entries(as));	&#x2F;&#x2F;[[&quot;name&quot;,&quot;阿顺&quot;], [&quot;age&quot;,18]]</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h4><p>之前已经接触过了Object的循环遍历。</p>
<ul>
<li>可使用<code>for/in</code>遍历Keys (但会遍历到原型上的属性)</li>
<li>不能直接使用<code>for/of</code>遍历Object<ul>
<li>由于系统内部没有为Object提供<code>for/of</code>遍历的接口 (Object不可迭代)（遍历Object的属性值，应该由用户决定），所以不能够直接使用<code>for/of</code>遍历。</li>
<li>但是<code>for/of</code>可以结合迭代器，对Object进行遍历。（内置迭代方法，返回的是可迭代数据类型，所以可以使用<code>for/of</code>进行遍历）</li>
</ul>
</li>
</ul>
<h5 id="for-in"><a href="#for-in" class="headerlink" title="for/in"></a>for/in</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol(&quot;as&quot;)]: &quot;ashun&quot; &#125;;</span><br><span class="line">for (const key in as) &#123;</span><br><span class="line">	console.log(key,as[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name ashun</span><br><span class="line">&#x2F;&#x2F;age 18</span><br></pre></td></tr></table></figure>



<h5 id="for-of"><a href="#for-of" class="headerlink" title="for/of"></a>for/of</h5><p>结合<code>Object.keys()</code>遍历属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let as &#x3D; &#123; name: &quot;阿顺&quot;, age: 18, [Symbol(&quot;as&quot;)]: &quot;ashun&quot; &#125;;</span><br><span class="line">for (const key of Object.keys(as)) &#123;</span><br><span class="line">	console.log(key, as[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;name 阿顺</span><br><span class="line">&#x2F;&#x2F;age 18</span><br></pre></td></tr></table></figure>

<p>结合<code>Object.values()</code>遍历值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">for (const val of Object.values(as)) &#123;</span><br><span class="line">  console.log(val);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;阿顺 18</span><br></pre></td></tr></table></figure>

<p>结合<code>Object.entries()</code>同时获取key、value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">for (const [key, val] of Object.entries(as)) &#123;</span><br><span class="line">	console.log(key, val);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;name 阿顺</span><br><span class="line">&#x2F;&#x2F;age 18</span><br></pre></td></tr></table></figure>

<p>添加元素DOM练习</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let lessons = [</span><br><span class="line">  &#123; name: &quot;js&quot;, click: 23 &#125;,</span><br><span class="line">  &#123; name: &quot;node&quot;, click: 192 &#125;</span><br><span class="line">];</span><br><span class="line">let ul = document.createElement(&quot;ul&quot;);</span><br><span class="line">for (const val of lessons) &#123;</span><br><span class="line">  let li = document.createElement(&quot;li&quot;);</span><br><span class="line">  li.innerHTML = `课程:$&#123;val.name&#125;,点击数:$&#123;val.click&#125;`;</span><br><span class="line">  ul.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(ul);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="拷贝对象"><a href="#拷贝对象" class="headerlink" title="拷贝对象"></a>拷贝对象</h3><ul>
<li><p>深浅拷贝一般只考虑引用类型，因为引用类型有传址的概念。</p>
<ul>
<li>浅拷贝：直接赋值，赋予的是引用类型的地址，新旧变量引用同一个内存空间</li>
<li>深拷贝：通过一些操作，让新变量只是copy引用类型数据的值，而不是地址，深拷贝过后，新旧变量只是内容相同，内存地址不同。</li>
</ul>
</li>
<li><p>非引用类型的赋值、合并操作都是深拷贝，因为非引用类型是传值。</p>
</li>
</ul>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>简单的赋值、合并都是浅拷贝。</p>
<ul>
<li>遍历赋值</li>
<li><code>Object.assign()</code></li>
<li>展开语法<code>...</code></li>
</ul>
<p>使用<code>for/in</code>执行对象浅拷贝</p>
<ul>
<li>obj.user为引用类型，直接赋值传址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; user: &#123; name: &quot;ASHUN&quot; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">let as &#x3D; &#123;&#125;;</span><br><span class="line">for (const key in obj) &#123;</span><br><span class="line">	as[key] &#x3D; obj[key];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">as.user.name &#x3D; &quot;shun&quot;;</span><br><span class="line">console.log(obj.user.name); &#x2F;&#x2F;shun</span><br></pre></td></tr></table></figure>



<p><code>Object.assign</code> 函数可简单的实现浅拷贝，它是将两个或多个对象的属性叠加后，追加到前面的对象中，后面的对象属性会覆盖前面对象的同名属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; user: &#123; name: &quot;Ashun&quot; , type: &quot;Controller&quot;&#125; &#125;;</span><br><span class="line">let b &#x3D; &#123; user: &#123; name: &quot;SHUN&quot; &#125; &#125;;</span><br><span class="line">let c &#x3D; &#123; user: &#123; name: &quot;shun&quot; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(a, b, c);</span><br><span class="line">console.log(a); 	&#x2F;&#x2F;&#123;user:&#123;name: &quot;shun&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">let newobj &#x3D; &#123;&#125;;</span><br><span class="line">newobj[&quot;user&quot;] &#x3D; Object.assign(a.user, b.user, c.user);</span><br><span class="line">console.log(newobj.user);	&#x2F;&#x2F;&#123;name: &quot;shun&quot;, type: &quot;Controller&quot;&#125;</span><br><span class="line">newobj.user.name &#x3D; &quot;SHUN&quot;;</span><br><span class="line">console.log(a.user.name); &#x2F;&#x2F; SHUN</span><br></pre></td></tr></table></figure>

<p>非引用类型深拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">let as &#x3D; &#123;</span><br><span class="line">	stu: Object.assign(&#123;&#125;, user),</span><br><span class="line">&#125;;</span><br><span class="line">as.stu.name &#x3D; &quot;Ashun&quot;;</span><br><span class="line">console.log(user.name); &#x2F;&#x2F;阿顺</span><br></pre></td></tr></table></figure>



<p>使用展示语法<code>...</code>也可以实现浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; user: &#123; name: &quot;Ashun&quot;, type: &quot;Controller&quot; &#125; &#125;;</span><br><span class="line">let b &#x3D; &#123; user: &#123; name: &quot;SHUN&quot; &#125; &#125;;</span><br><span class="line">let c &#x3D; &#123; user: &#123; name: &quot;shun&quot; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">a &#x3D; &#123; ...a, ...b, ...c &#125;;</span><br><span class="line">console.log(a); &#x2F;&#x2F;&#123;user:&#123;name: &quot;shun&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>非引用类型为深拷贝。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">let as = &#123; ...obj &#125;;</span><br><span class="line">as.name = &quot;ashun&quot;;</span><br><span class="line"></span><br><span class="line">console.log(obj.name); //阿顺</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><strong>深拷贝</strong>是完全的复制一个对象，两个对象是完全独立的对象，新旧对象仅仅是内容相同，两个对象的内存地址不同。</p>
<p>深拷贝方式：</p>
<ul>
<li>递归深入层级，进行数据深拷贝</li>
<li><code>JSON.parse(JSON.stringify(obj))</code><ul>
<li>该方式缺点: 不能拷贝obj中的method、属性值为undefined的属性。</li>
</ul>
</li>
</ul>
<p>浅拷贝不会将深层的非引用类型数据复制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">	user: &#123;</span><br><span class="line">		name: &quot;SHUN&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function copy(object) &#123;</span><br><span class="line">	let obj = &#123;&#125;;</span><br><span class="line">	for (const key in object) &#123;</span><br><span class="line">		obj[key] = object[key];</span><br><span class="line">	&#125;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newObj = copy(obj);</span><br><span class="line">newObj.user.name = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">console.log(obj.user.name);//Ashuntefannao.com</span><br></pre></td></tr></table></figure>



<p><strong>递归深入层级，进行数据的深拷贝</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function copy(obj) &#123;</span><br><span class="line">	let newObj &#x3D; obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">	for (const key in obj) &#123;</span><br><span class="line">		newObj[key] &#x3D; typeof obj[key] &#x3D;&#x3D; &quot;object&quot; ? copy(obj[key]) : obj;</span><br><span class="line">	&#125;</span><br><span class="line">	return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123; </span><br><span class="line">	user: &#123; name: &quot;Ashun&quot;, Array: [1, 2, 3] &#125;,</span><br><span class="line">  test() &#123;&#125;,</span><br><span class="line">  type:undefined </span><br><span class="line">&#125;;</span><br><span class="line">let newobj &#x3D; copy(obj);</span><br><span class="line">newobj.user.name &#x3D; &quot;ASHUN&quot;;</span><br><span class="line">newobj.user.Array &#x3D; &#123;&#125;;</span><br><span class="line">newobj.test &#x3D; &#123;&#125;;</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(newobj);</span><br></pre></td></tr></table></figure>

<p><strong><code>JSON.parse(JSON.stringify(obj))</code></strong></p>
<ul>
<li>不能拷贝method</li>
<li>不能拷贝属性值为undefined的属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function copy(obj) &#123;</span><br><span class="line">	return JSON.parse(JSON.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123; </span><br><span class="line">	user: &#123; name: &quot;Ashun&quot;, Array: [1, 2, 3] &#125;,</span><br><span class="line">  test() &#123;&#125;,</span><br><span class="line">  type:undefined </span><br><span class="line">&#125;;</span><br><span class="line">let newobj &#x3D; copy(obj);</span><br><span class="line">newobj.user.name &#x3D; &quot;SHUN&quot;;</span><br><span class="line">newobj.user.Array &#x3D; &#123;&#125;;</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(newobj);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h3><p>对象可以通过<code>自定义工厂函数</code>和<code>内置构造函数</code>或<code>自定义的构造函数</code>创建。</p>
<h4 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h4><p>在函数中<code>返回对象</code>的函数称为工厂函数，工厂函数有以下优点</p>
<ul>
<li>减少重复创建相同类型对象的代码</li>
<li>修改工厂函数的方法影响所有同类对象</li>
</ul>
<p>使用字面量创建对象需要复制属性与方法结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const as = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const shun = &#123;</span><br><span class="line">  name: &quot;SHUN&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用工厂函数可以简化这个过程</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function stu(name) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name,</span><br><span class="line">    show() &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const as = stu(&quot;阿顺&quot;);</span><br><span class="line">as.show();</span><br><span class="line">const shun = stu(&quot;SHUN&quot;);</span><br><span class="line">shun.show();</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>和工厂函数相似构造函数也用于<code>创建对象</code>，它的上下文为新的对象实例。</p>
<ul>
<li>命名规范：构造函数名每个单词首字母大写即<code>Pascal</code> </li>
<li><code>this</code>指当前创建的对象</li>
<li>不需要返回<code>this</code>系统会自动完成</li>
<li>需要使用<code>new</code>关键词生成对象</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.show = function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  //不需要返回，系统会自动返回</span><br><span class="line">  // return this;</span><br><span class="line">&#125;</span><br><span class="line">const ashun = new Student(&quot;阿顺&quot;);</span><br><span class="line">ashun.show();</span><br><span class="line">const shun = new Student(&quot;SHUN&quot;);</span><br><span class="line">shun.show();</span><br></pre></td></tr></table></figure>

<p>如果构造函数返回对象，通过new构造函数实例化后的对象就是返回的对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function ArrayObject(...values) &#123;</span><br><span class="line">  const arr = new Array();</span><br><span class="line">  arr.push.apply(arr, values);</span><br><span class="line">  arr.string = function(sym = &quot;|&quot;) &#123;</span><br><span class="line">    return this.join(sym);</span><br><span class="line">  &#125;;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">const array = new ArrayObject(1, 2, 3);</span><br><span class="line">console.log(array);</span><br><span class="line">console.log(array.string(&quot;-&quot;));</span><br></pre></td></tr></table></figure>

<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>构造函数中的<code>this</code>默认是一个空对象，然后构造函数处理后把这个空对象变得有值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺&quot;);</span><br></pre></td></tr></table></figure>

<p>构造函数的实例化过程，相当于创建一个空对象，并为其赋予属性。然后再隐式设置这个对象的原型。</p>
<p>可以改变构造函数中的空对象，即让构造函数this指向到另一个对象。再为这个对象设置原型即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">	this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123;&#125;;</span><br><span class="line">User.call(obj, &quot;阿顺&quot;);</span><br><span class="line">Object.setPrototypeOf(obj,User.prototype)</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h4><p>在严格模式下<code>独立存在的函数</code>中的<code>this</code>值为undefined，这是为了防止无意的修改window对象</p>
<p>注意: </p>
<ul>
<li>这里考虑的this，是构造函数生成对象的<code>方法中出现的this</code>。(下例中的show方法)</li>
<li>不是考虑构造函数中的this，因为构造函数虽然也是独立存在的函数，但是在使用<code>new</code>实例化后，其中的this会自动指向当前的实例。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function User() &#123;</span><br><span class="line">  this.show = function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User();</span><br><span class="line">as.show(); //User</span><br><span class="line"></span><br><span class="line">let show = as.show;		//让as.show函数体在全局执行,在严格模式下,其中的this为undefined</span><br><span class="line">show(); //undefined</span><br></pre></td></tr></table></figure>

<p>将函数体改为箭头函数<code>()=&gt;&#123;&#125;</code>能够解决。因为箭头函数没有自身的this指向，会自动继承上下文的this。在通过new构造函数实例化时，里面的this已经绑定到了当前实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function User() &#123;</span><br><span class="line">  this.show &#x3D; ()&#x3D;&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let as &#x3D; new User();</span><br><span class="line">as.show(); &#x2F;&#x2F;User</span><br><span class="line"></span><br><span class="line">let show &#x3D; as.show;</span><br><span class="line">show(); &#x2F;&#x2F;User</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="内置构造"><a href="#内置构造" class="headerlink" title="内置构造"></a>内置构造</h4><p>JS中大部分数据类型都是通过构造函数创建的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const num = new Number(99);</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line"></span><br><span class="line">const string = new String(&quot;阿顺特烦恼&quot;);</span><br><span class="line">console.log(string.valueOf());</span><br><span class="line"></span><br><span class="line">const boolean = new Boolean(true);</span><br><span class="line">console.log(boolean.valueOf());</span><br><span class="line"></span><br><span class="line">const date = new Date();</span><br><span class="line">console.log(date.valueOf());</span><br><span class="line"></span><br><span class="line">const regexp = new RegExp(&quot;\\d+&quot;);</span><br><span class="line">console.log(regexp.test(99));	//true</span><br><span class="line"></span><br><span class="line">let as= new Object();</span><br><span class="line">as.name = &quot;阿顺&quot;;</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>字面量创建的对象，内部也是调用了<code>Object</code>构造函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//字面量创建对象</span><br><span class="line">const as = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(as.constructor); //ƒ Object() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line">//构造函数创建对象</span><br><span class="line">const ashun = new Object();</span><br><span class="line">ashun.title = &quot;Ashuntefannao&quot;;</span><br><span class="line">console.log(ashun.constructor); //ƒ Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>在<code>JS</code>中函数也是一个对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function as(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(as.toString());</span><br><span class="line">console.log(as.length);</span><br></pre></td></tr></table></figure>

<p>函数是由系统内置的 <code>Function</code> 构造函数创建的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function as(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(as.constructor);</span><br></pre></td></tr></table></figure>

<p>下面是使用内置构造函数创建的函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const User = new Function(`name`,`</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.show = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;;</span><br><span class="line">`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const zs = new User(&quot;张三&quot;);</span><br><span class="line">console.log(zs.show());</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="抽象特性"><a href="#抽象特性" class="headerlink" title="抽象特性"></a>抽象特性</h3><p>将复杂功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响即抽象。</p>
<p>下面的手机就是抽象的好例子，只开放几个按钮给用户，复杂的工作封装在手机内部，程序也应该如此。</p>
<p>​    【引用图片】</p>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>下例将对象属性封装到构造函数内部</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name,type=&quot;user&quot;)&#123;</span><br><span class="line">	this.name=name;</span><br><span class="line">	this.type=type;</span><br><span class="line">	this.info=()=&gt;&#123;</span><br><span class="line">		return this.type==&quot;Controller&quot;?`管理员`:`普通用户`;</span><br><span class="line">	&#125;	</span><br><span class="line">	this.show=()=&gt;&#123;</span><br><span class="line">		return `$&#123;name&#125; 是 $&#123;this.info()&#125;`	</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let as=new User(&quot;ashun&quot;,&quot;Controller&quot;);</span><br><span class="line">console.log( as.show())</span><br><span class="line">let lisi=new User(&quot;lisi&quot;);</span><br><span class="line">console.log(lisi.show())</span><br></pre></td></tr></table></figure>

<h4 id="抽象封装"><a href="#抽象封装" class="headerlink" title="抽象封装"></a>抽象封装</h4><p>上例中的方法和属性仍然可以在外部访问到，但是为了实现抽象和数据的安全性，有些属性和方法不需要被外部访问，比如 <code>info</code>方法只是在内部使用，不需要被外部访问到，若外部访问修改，这会破坏程序的内部逻辑。</p>
<ul>
<li>将不需要暴露的属性、方法，使用普通声明形式，而不是追加到this（实例）上。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name,type=&quot;user&quot;)&#123;</span><br><span class="line">	let data=&#123;name,type&#125;;</span><br><span class="line">	let info=()=&gt;&#123;</span><br><span class="line">		return data.type==&quot;Controller&quot;?`管理员`:`普通用户`;</span><br><span class="line">	&#125;	</span><br><span class="line">	 this.show=()=&gt;&#123;</span><br><span class="line">		return `$&#123;data.name&#125; 是 $&#123;info()&#125;`	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">let as=new User(&quot;ashun&quot;,&quot;Controller&quot;);</span><br><span class="line">console.log( as.show())</span><br><span class="line">let lisi=new User(&quot;lisi&quot;);</span><br><span class="line">console.log(lisi.show());</span><br><span class="line">console.log(lisi.info)//undefined</span><br></pre></td></tr></table></figure>

<h3 id="属性特征"><a href="#属性特征" class="headerlink" title="属性特征"></a>属性特征</h3><p>JS中可以对属性的特性进行访问和控制。</p>
<h4 id="查看特征"><a href="#查看特征" class="headerlink" title="查看特征"></a>查看特征</h4><ul>
<li><code>Object.getOwnPropertyDescriptor(obj,&quot;prop&quot;)</code></li>
<li><code>Object.getOwnPropertyDescriptors(obj)</code></li>
</ul>
<p>使用 <code>Object.getOwnPropertyDescriptor</code>查看对象属性的描述。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const as=&#123;</span><br><span class="line">	name:&quot;ashun&quot;,</span><br><span class="line">	age:18,</span><br><span class="line">	type:&quot;Controller&quot;	</span><br><span class="line">&#125;;</span><br><span class="line">console.log(JSON.stringify(Object.getOwnPropertyDescriptor(as,&quot;type&quot;),null,2));</span><br></pre></td></tr></table></figure>

<p>使用 <code>Object.getOwnPropertyDescriptors</code>查看对象所有属性的描述</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const as=&#123;</span><br><span class="line">	name:&quot;ashun&quot;,</span><br><span class="line">	age:18,</span><br><span class="line">	type:&quot;Controller&quot;	</span><br><span class="line">&#125;;</span><br><span class="line">let desc = Object.getOwnPropertyDescriptors(as);</span><br><span class="line">console.log(JSON.stringify(desc, null, 2));</span><br></pre></td></tr></table></figure>

<p>属性包括以下四种特性</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>configurable</td>
<td>是否可删除该属性、是否可以再次配置属性描述特征</td>
<td>true</td>
</tr>
<tr>
<td>enumerable</td>
<td>(是否可枚举)对象属性是否可通过for-in循环，或迭代方法读取</td>
<td>true</td>
</tr>
<tr>
<td>writable</td>
<td>对象属性值是否可修改</td>
<td>true</td>
</tr>
<tr>
<td>value</td>
<td>对象属性的默认值</td>
<td>undefined</td>
</tr>
</tbody></table>
<h4 id="设置特征"><a href="#设置特征" class="headerlink" title="设置特征"></a>设置特征</h4><ul>
<li><code>Object.defineProperty(obj,&quot;prop&quot;,&#123;...desc&#125;)</code> </li>
<li><code>Object.defineProperties(obj,&#123; prop1:&#123;...desc&#125;, ...propN:&#123;...desc&#125;)</code> </li>
</ul>
<p>使用<code>Object.defineProperty</code> 方法修改某属性的属性特性，通过下面的设置，属性name将不能被删除、修改、<code>for/in</code>或迭代方法遍历。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(user, &quot;name&quot;, &#123;</span><br><span class="line">  value: &quot;Ashun&quot;,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过执行以下代码对上面配置进行测试，请分别打开注释进行测试</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// 不允许修改=&gt;writable</span><br><span class="line">// user.name = &quot;SHUN&quot;; //Error</span><br><span class="line"></span><br><span class="line">// 不能遍历=&gt;enumerable</span><br><span class="line">// console.log(Object.keys(user));</span><br><span class="line"></span><br><span class="line">//不允许删除=&gt;configurable</span><br><span class="line">// delete user.name;</span><br><span class="line">// console.log(user);</span><br><span class="line"></span><br><span class="line">//不允许配置=&gt;configurable</span><br><span class="line">// Object.defineProperty(user, &quot;name&quot;, &#123;</span><br><span class="line">//   value: &quot;阿顺&quot;,</span><br><span class="line">//   writable: true,</span><br><span class="line">//   enumerable: false,</span><br><span class="line">//   configurable: false</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure>

<p>使用 <code>Object.defineProperties</code> 可以一次设置多个属性的属性特征，具体参数和上面介绍的一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let user &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperties(user, &#123;</span><br><span class="line">  name: &#123; value: &quot;阿顺&quot;, writable: false &#125;,</span><br><span class="line">  age: &#123; value: 18 &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(user);</span><br><span class="line">user.name &#x3D; &quot;SHUN&quot;; &#x2F;&#x2F;TypeError</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="禁止添加"><a href="#禁止添加" class="headerlink" title="禁止添加"></a>禁止添加</h4><p><code>Object.preventExtensions(obj)</code> 禁止向obj添加属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.preventExtensions(user);</span><br><span class="line">user.age = 18; //Error</span><br></pre></td></tr></table></figure>

<p><code>Object.isExtensible(obj)</code> 判断是否能向obj中添加属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.preventExtensions(user);</span><br><span class="line">console.log(Object.isExtensible(user)); //false</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="封闭对象"><a href="#封闭对象" class="headerlink" title="封闭对象"></a>封闭对象</h4><p><code>Object.seal(obj)</code>方法封闭一个对象，<code>阻止添加新属性</code>并将所有现有属性的属性特征的<code>configurable</code>选项标记为 <code>false</code></p>
<ul>
<li><p>相当于<code>Object.preventExtensions(obj)</code>与<code>configurable:false</code>的结合。</p>
</li>
<li><p>不能够增加、删除属性。</p>
</li>
<li><p>不能再次配置属性的特征描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">let user &#x3D; &#123;</span><br><span class="line">  name: &quot;阿顺&quot;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.seal(user);</span><br><span class="line">console.log(Object.isSealed(user));</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  JSON.stringify(Object.getOwnPropertyDescriptors(user), null, 2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">delete user.name; </span><br><span class="line">console.log(Object.keys(user));  &#x2F;&#x2F;[&quot;name&quot;,&quot;age&quot;]</span><br></pre></td></tr></table></figure>

<p><code>Object.isSealed(obj)</code> 判断obj是否被封闭。 </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.seal(user);</span><br><span class="line">console.log(Object.isSealed(user)); //true</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h4><p><code>Object.freeze(obj)</code> 冻结对象后不允许添加、删除、修改属性，<code>writable、configurable</code>都标记为<code>false</code></p>
<ul>
<li>相当于<code>Object.preventExtensions()</code>与<code>writable:false、configurable:false</code>的结合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user &#x3D; &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(user);</span><br><span class="line">user.name &#x3D; &quot;Ashun&quot;; &#x2F;&#x2F;Error</span><br></pre></td></tr></table></figure>

<p><code>Object.isFrozen()</code>方法判断一个对象是否被冻结</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;阿顺&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(user);</span><br><span class="line">console.log(Object.isFrozen(user)); //true</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><h4 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="属性种类"><a href="#属性种类" class="headerlink" title="属性种类"></a>属性种类</h5><p>在JavaScript中，对象的属性有两种</p>
<ul>
<li>数据属性</li>
<li>访问器属性</li>
<li>同名称属性只能在访问器属性和数据属性任选其一，不能共同存在，也就是说：一个属性若不是数据属性，则就是访问器属性。</li>
</ul>
<p>两种类型的属性又分别对应着不同的属性特征</p>
<ul>
<li>数据属性-&gt;数据属性特征</li>
<li>访问器属性-&gt;访问器属性特征</li>
</ul>
<p><strong>数据属性:</strong> 直接配置数据的属性。能够被外部直接访问和修改。与其对应的数据属性特征，就是之前介绍到的四个属性特征：<code>value、writable、enumerable、configurable</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user&#x3D;&#123;</span><br><span class="line">	name:&quot;ashun&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(user,&quot;name&quot;));</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">		value: &quot;ashun&quot;, </span><br><span class="line">		writable: true, </span><br><span class="line">		enumerable: true, </span><br><span class="line">		configurable: true</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问器属性:</strong> 该类型的属性，所有的访问、修改操作都需要通过<code>getter/setter</code>访问器，进行处理。具有的属性特征:<code>get、set、enumerable、configurable</code></p>
<ul>
<li>相对于<strong>数据属性</strong>，<strong>访问器属性</strong>不具有<code>value、writable</code>特征，与之替代的是<code>get、set</code>。</li>
<li>因为访问器属性，不像数据属性一样(直接设置属性值)，所以不具有value特征，</li>
<li>并且访问器属性值是否可改写，与是否有对应的setter直接挂钩（只有getter则为只读，也就不能改写）,所以也就没有了writable特征，将其替代为了set特征。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user&#x3D;&#123;</span><br><span class="line">	get name()&#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;,</span><br><span class="line">	set name(name)&#123;</span><br><span class="line">		this.name&#x3D;name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(user,&quot;name&quot;));</span><br><span class="line">&#x2F;&#x2F;&#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="访问器属性不能够管理自身"><a href="#访问器属性不能够管理自身" class="headerlink" title="访问器属性不能够管理自身"></a>访问器属性不能够管理自身</h5><p>需要注意的是，属性访问器不能够管理自身，因为会导致<code>死循环调用</code>。</p>
<ul>
<li>外部使用<code>user.name</code>访问该属性时，会走get访问器，但是在get的return语句中又访问了该属性，又会调用get访问器，周而复始，死循环产生</li>
<li>同理，外部使用<code>user.name=&quot;Ashun&quot;</code>进行赋值，会走set，但是在set的赋值语句中又会调用set访问器。</li>
<li>所以，一般都会让访问器属性管理数据属性或变量对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">	get name() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;,</span><br><span class="line">	set name(name) &#123;</span><br><span class="line">		return (this.name &#x3D; name);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.name; &#x2F;&#x2F;Error</span><br><span class="line">user.name&#x3D;&quot;Ashun&quot;&#x2F;&#x2F;Error</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h4><p><code>getter</code>方法用于<code>获得属性值</code>，<code>setter</code>方法用于<code>设置属性</code>，这是JS提供的存取器特性即使用函数来管理属性。</p>
<ul>
<li>用于避免错误的赋值</li>
<li>需要动态监测值的改变</li>
</ul>
<p>向对是地用户的年龄数据使用访问器监控控制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const User = &#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		name: &quot;Ashun&quot;,</span><br><span class="line">		age: null,</span><br><span class="line">	&#125;,</span><br><span class="line">	get age() &#123;</span><br><span class="line">		return `$&#123;this.data.name&#125;的年龄为:$&#123;this.data.age&#125;`;</span><br><span class="line">	&#125;,</span><br><span class="line">	set age(value) &#123;</span><br><span class="line">		if (typeof value != &quot;number&quot; || value &gt; 100 || value &lt; 10)</span><br><span class="line">			throw new Error(&quot;年龄格式错误！&quot;);</span><br><span class="line">		this.data.age = value;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">User.age = 18;</span><br><span class="line">console.log(User.age);	//Ashun的年龄为:18</span><br><span class="line">User.age = 7;	//Error: 年龄格式错误！</span><br></pre></td></tr></table></figure>

<p>下面使用getter设置只读的课程总价</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Lesson = &#123;</span><br><span class="line">  lists: [</span><br><span class="line">    &#123; name: &quot;javascript&quot;, price: 100 &#125;,</span><br><span class="line">    &#123; name: &quot;mysql&quot;, price: 212 &#125;,</span><br><span class="line">    &#123; name: &quot;CSS3&quot;, price: 98 &#125;</span><br><span class="line">  ],</span><br><span class="line">  get total() &#123;</span><br><span class="line">    return this.lists.reduce((p, v) =&gt; p + v.price, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Lesson.total); //410</span><br><span class="line">Lesson.total = 999; //无效</span><br><span class="line">console.log(Lesson.total); //410</span><br></pre></td></tr></table></figure>

<p>下面通过设置站网站名称与网址体验<code>getter/setter</code>批量设置属性的使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let web = &#123;</span><br><span class="line">	name: &quot;阿顺&quot;,</span><br><span class="line">	url: &quot;Ashuntefannao.com&quot;,</span><br><span class="line">	get site() &#123;</span><br><span class="line">		return `$&#123;this.name&#125;-$&#123;this.url&#125;`;</span><br><span class="line">	&#125;,</span><br><span class="line">	set site(message) &#123;</span><br><span class="line">		[this.name, this.url] = message.split(&quot;,&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(web.site);</span><br><span class="line">web.site = &quot;顺子,Ashun.com&quot;;</span><br><span class="line">console.log(web.site);</span><br></pre></td></tr></table></figure>

<p>下面是设置token储取的示例，将业务逻辑使用<code>getter/setter</code>处理更方便，也方便其他业务的复用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Request = &#123;</span><br><span class="line">  get token() &#123;</span><br><span class="line">    let con = localStorage.getItem(&#x27;token&#x27;);</span><br><span class="line">    if (!con) &#123;</span><br><span class="line">    	alert(&#x27;请登录后获取token&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	return con;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  set token(con) &#123;</span><br><span class="line">  	localStorage.setItem(&#x27;token&#x27;, con);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Request.token = &#x27;ashun&#x27;</span><br><span class="line">console.log(Request.token);</span><br></pre></td></tr></table></figure>

<p>定义内部私有属性</p>
<ul>
<li>使用setter、getter定义一个与实际属性对应的形式属性，通过这个形式属性名称让外部操作。</li>
<li>这只是形式上的内部私有属性，用户还是能通过实际属性名称进行访问。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const user = &#123;</span><br><span class="line">	_name:&quot;user&quot;,</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    if (value.length &lt;= 3) &#123;</span><br><span class="line">      throw new Error(&quot;用户名不能小于三位&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.name = &quot;阿顺特烦恼&quot;;</span><br><span class="line">console.log(user.name);</span><br><span class="line">console.log(user._name);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通过描述设置访问器属性"><a href="#通过描述设置访问器属性" class="headerlink" title="通过描述设置访问器属性"></a>通过描述设置访问器属性</h4><p>下例在构造函数中，设置this的访问器属性描述<code>getter/setter</code>，当实例化为对象时，自动为对象配置对应访问器属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name, age) &#123;</span><br><span class="line">        let Data &#x3D; &#123; name, age &#125;;</span><br><span class="line">        Object.defineProperties(this, &#123;</span><br><span class="line">          name: &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              return &#96;name：$&#123;Data.name&#125;&#96;;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(value) &#123;</span><br><span class="line">              Data.name &#x3D; value;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          age: &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              return &#96;age：$&#123;Data.age&#125;&#96;;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(value) &#123;</span><br><span class="line">              Data.age &#x3D; value;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">let as &#x3D; new User(&quot;阿顺&quot;, 18);</span><br><span class="line">console.log(as.name);	&#x2F;&#x2F;name：阿顺</span><br><span class="line">as.name &#x3D; &quot;SHUN&quot;;</span><br><span class="line">console.log(as.name);	&#x2F;&#x2F;age：SHUN</span><br></pre></td></tr></table></figure>

<p>上面的代码也可以使用语法糖 <code>class</code>定义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let Data = Symbol();</span><br><span class="line">      class User &#123;</span><br><span class="line">        constructor(name, age) &#123;</span><br><span class="line">          this[Data] = &#123; name, age &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        get name() &#123;</span><br><span class="line">          return `name:$&#123;this[Data].name&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">        set name(val) &#123;</span><br><span class="line">          this[Data].name = val;</span><br><span class="line">        &#125;</span><br><span class="line">        get age() &#123;</span><br><span class="line">          return `age:$&#123;this[Data].age&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">        set age(val) &#123;</span><br><span class="line">          this[Data].age = val;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;Ashun&quot;, 18);</span><br><span class="line">console.log(as.age);	//age:18</span><br><span class="line">as.name = &quot;SHUN&quot;;</span><br><span class="line">console.log(as.name);	//name:SHUN</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="闭包访问器"><a href="#闭包访问器" class="headerlink" title="闭包访问器"></a>闭包访问器</h4><p>下面结合闭包特性对属性进行访问控制</p>
<ul>
<li>下例中访问器定义在函数中，并接收参数v</li>
<li>在get() 中通过闭包返回 v</li>
<li>在set() 中修改了v，这会影响get()访问的闭包数据v</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123; name: &quot;Ashun&quot;, age: 18 &#125;;</span><br><span class="line">      function observer(obj, key, val) &#123;</span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">            console.log(val);</span><br><span class="line">            return val;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newVal) &#123;</span><br><span class="line">            val = newVal;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">for (let [key, val] of Object.entries(user)) &#123;</span><br><span class="line">	observer(user, key, val);</span><br><span class="line">&#125;</span><br><span class="line">user.name;	//Ashun</span><br><span class="line">user.name = &quot;SHUN&quot;;</span><br><span class="line">user.name;	//SHUN</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="代理拦截"><a href="#代理拦截" class="headerlink" title="代理拦截"></a>代理拦截</h3><p>代理<code>proxy</code>（拦截器）是对象的访问控制，<code>setter/getter</code> 是对单个对象属性的控制，而<code>proxy是对整个对象的控制</code>。</p>
<ul>
<li>读写属性时代码更简洁</li>
<li>对象的多个属性控制统一交给代理完成</li>
<li>严格模式下 <code>set</code> 必须返回布尔值</li>
<li>可代理多种引用类型：<code>Object,Array,Functoin</code></li>
</ul>
<h4 id="代理对象属性"><a href="#代理对象属性" class="headerlink" title="代理对象属性"></a>代理对象属性</h4><p>下例为使用proxy代理对象</p>
<ul>
<li><code>new Proxy(obj,&#123; get(obj,prop)&#123;…&#125; , set(obj,prop,val)&#123;…&#125; &#125;)</code></li>
<li>通过<code>set</code>设置值后需要返回Boolean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;</span><br><span class="line">	name: &quot;Ashun&quot;,</span><br><span class="line">	age: 18,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy &#x3D; new Proxy(user, &#123;</span><br><span class="line">	get(obj, prop) &#123;</span><br><span class="line">		return &#96;通过proxy访问：$&#123;obj[prop]&#125;&#96;;</span><br><span class="line">	&#125;,</span><br><span class="line">	set(obj, prop, value) &#123;</span><br><span class="line">		obj[prop] &#x3D; value;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(proxy.name);&#x2F;&#x2F;通过proxy访问：Ashun</span><br><span class="line">proxy.name &#x3D; &quot;SHUN&quot;;</span><br><span class="line">console.log(proxy.name);&#x2F;&#x2F;通过proxy访问：SHUN</span><br></pre></td></tr></table></figure>

<h4 id="代理函数"><a href="#代理函数" class="headerlink" title="代理函数"></a>代理函数</h4><p>如果代理以函数方式执行时，会执行代理中定义的 <code>apply</code> 方法。</p>
<ul>
<li>apply参数说明：函数，上下文对象，代理函数接收的参数(<code>类型必须为Array</code>)</li>
</ul>
<p>下面使用 <code>apply</code> 计算函数执行时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">	return num == 1 ? 1 : num * factorial(num - 1);</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(factorial, &#123;</span><br><span class="line">	apply(func, context, args) &#123;</span><br><span class="line">		console.time(&quot;run&quot;);</span><br><span class="line">		console.log(func.call(context, ...args));</span><br><span class="line">		console.timeEnd(&quot;run&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">      </span><br><span class="line">proxy.apply(this, [3]);	//传入的参数类型必须为Array</span><br></pre></td></tr></table></figure>



<h4 id="代理数组"><a href="#代理数组" class="headerlink" title="代理数组"></a>代理数组</h4><p>下例中对数组进行代理，用于截取标题操作，同代理对象：设置<code>get(arr,key)、set(arr,key,val)</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const stringDot = &#123;</span><br><span class="line">	get(arr, key) &#123;</span><br><span class="line">		const maxLeng = 5;</span><br><span class="line">		let currentTitle = arr[key].title;</span><br><span class="line">		return currentTitle.length &gt; 5</span><br><span class="line">		 ? currentTitle.substr(0, maxLeng).concat(&quot;.&quot;.repeat(3))</span><br><span class="line"> 		 : currentTitle;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">      const lessons = [</span><br><span class="line">        &#123;</span><br><span class="line">          title: &quot;媒体查询响应式布局&quot;,</span><br><span class="line">          category: &quot;css&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &quot;FLEX 弹性盒模型&quot;,</span><br><span class="line">          category: &quot;css&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &quot;MYSQL多表查询随意操作&quot;,</span><br><span class="line">          category: &quot;mysql&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">const stringDotProxy = new Proxy(lessons, stringDot);</span><br><span class="line">console.log(stringDotProxy[0]);	//媒体查询响...</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><img src="对象.assets/Proxy_v-model.gif" alt="Proxy_v-model" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;label&gt; s-model&#x3D;&quot;test1&quot;&lt;input s-model&#x3D;&quot;test1&quot; &#x2F;&gt;&lt;&#x2F;label&gt;&lt;br &#x2F;&gt;</span><br><span class="line">    &lt;label&gt; s-bind&#x3D;&quot;test1&quot;&lt;input s-bind&#x3D;&quot;test1&quot; &#x2F;&gt;&lt;&#x2F;label&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">    &lt;label&gt; s-model&#x3D;&quot;test2&quot;&lt;input s-model&#x3D;&quot;test2&quot; &#x2F;&gt;&lt;&#x2F;label&gt;&lt;br &#x2F;&gt;</span><br><span class="line">    &lt;label&gt; s-bind&#x3D;&quot;test2&quot;&lt;input s-bind&#x3D;&quot;test2&quot; &#x2F;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let proxy &#x3D; new Proxy(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          set(obj, prop, val) &#123;</span><br><span class="line">            obj[prop] &#x3D; val;</span><br><span class="line">            let doms &#x3D; document.querySelectorAll(</span><br><span class="line">              &#96;[s-model&#x3D;$&#123;prop&#125;],[s-bind&#x3D;$&#123;prop&#125;]&#96;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            console.log(obj[prop]);</span><br><span class="line">            doms.forEach((v) &#x3D;&gt; (v.value &#x3D; obj[prop]));</span><br><span class="line">            return true;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      let models &#x3D; document.querySelectorAll(&#96;[s-model]&#96;);</span><br><span class="line">      models.forEach((ele) &#x3D;&gt;</span><br><span class="line">        ele.addEventListener(&quot;input&quot;, function () &#123;</span><br><span class="line">          let prop &#x3D; this.getAttribute(&quot;s-model&quot;);</span><br><span class="line">          proxy[prop] &#x3D; this.value;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h4><img src="对象.assets/Proxy_formTest.gif" alt="Proxy_formTest" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">[validate]&#123;</span><br><span class="line">	border:3px dotted #ccc; </span><br><span class="line">	margin:5px 0px;</span><br><span class="line">	border-radius:5px;</span><br><span class="line">	outline:none;</span><br><span class="line">	height:20px;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.err&#123;</span><br><span class="line">	border:3px dotted red; </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; validate rule&#x3D;&quot;min:3,max:6&quot;  &#x2F;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; validate rule&#x3D;&quot;isNumber,min:3&quot;  &#x2F;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">class Validate&#123;</span><br><span class="line">	static min(val,len)&#123;</span><br><span class="line">		return val.length&gt;len;</span><br><span class="line">	&#125;</span><br><span class="line">	static max(val,len)&#123;</span><br><span class="line">		return val.length&lt;len;</span><br><span class="line">	&#125;</span><br><span class="line">	static isNumber(val)&#123;</span><br><span class="line">		return &#x2F;^\d+$&#x2F;.test(val);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function makePoxy(Arr)&#123;</span><br><span class="line">return new Proxy(Arr,&#123;</span><br><span class="line">	</span><br><span class="line">	get(arr,key)&#123;</span><br><span class="line">		return arr[key];</span><br><span class="line">	&#125;,</span><br><span class="line">	set(arr,key,val)&#123;</span><br><span class="line">		let rules&#x3D;arr[key].getAttribute(&quot;rule&quot;).split(&quot;,&quot;);</span><br><span class="line">		console.log(rules,key);</span><br><span class="line">		</span><br><span class="line">		let check&#x3D;rules.every((val)&#x3D;&gt;&#123;</span><br><span class="line">			let Switch&#x3D;val.split(&quot;:&quot;);</span><br><span class="line">			return 	Validate[Switch[0]](arr[key].value,Switch[1]);</span><br><span class="line">		&#125;);</span><br><span class="line">		arr[key].classList[check?&quot;remove&quot;:&quot;add&quot;](&quot;err&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">&#125;);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let doms&#x3D;document.querySelectorAll(&quot;[validate]&quot;);</span><br><span class="line">let proxy&#x3D;new makePoxy(doms);</span><br><span class="line"></span><br><span class="line">doms.forEach(function(ele,i)&#123;</span><br><span class="line">	ele.addEventListener(&quot;input&quot;,function()&#123;</span><br><span class="line">			proxy[i]&#x3D;this;	</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/DOM/</url>
    <content><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>DOM 即Document Object Model 文档对象模型。如果对HTML很了解使用DOM并不复杂。</p>
<p>通过js操作界面元素，操作的对象即DOM。</p>
<p>浏览器在加载页面时会生成DOM对象，以供我们使用JS控制页面元素。</p>
<h4 id="文档渲染"><a href="#文档渲染" class="headerlink" title="文档渲染"></a>文档渲染</h4><p>浏览器会将HTML文本内容进行渲染，并生成相应的JS对象，同时会对不符规则的标签进行处理。</p>
<ul>
<li>浏览器会将标签规范后渲染页面</li>
<li>目的一让页面可以正确呈现</li>
<li>目的二可以生成统一的JS可操作对象</li>
</ul>
<h5 id="标签修复"><a href="#标签修复" class="headerlink" title="标签修复"></a>标签修复</h5><p>在html文件中，若只有内容<code>阿顺特烦恼</code>而<strong>没有任何标签时</strong>，浏览器会自动修复成以下格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">阿顺特烦恼</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>下面H1标签结束错误并且属性也没有引号，浏览器在渲染中会进行修复</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1 id=ashun&gt;阿顺特烦恼&lt;h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>处理后的结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;ashun&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="表格处理"><a href="#表格处理" class="headerlink" title="表格处理"></a>表格处理</h5><p>表格tabel中不允许有内容，浏览器在渲染过程中会进行处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  阿顺特烦恼</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;阿顺&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>渲染后会添加tbody标签并将table中的字符移出到table标签外部</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">阿顺特烦恼</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">  	&lt;tr&gt;</span><br><span class="line">      &lt;th&gt;阿顺&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h5 id="标签移动"><a href="#标签移动" class="headerlink" title="标签移动"></a>标签移动</h5><p>所有内容要写在BODY标签中，下面的SCRIPT标签写在了BODY后面，浏览器渲染后也会进行处理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.dir(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>渲染后处理的结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.dir(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="操作时机"><a href="#操作时机" class="headerlink" title="操作时机"></a>操作时机</h4><p>需要保证浏览器已经渲染了内容才可以读取的节点对象，下例将无法读取到节点对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">  console.log(node); //null</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>不过我们可以将脚本通过事件放在页面渲染完执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = () =&gt; &#123;</span><br><span class="line">    const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">    console.log(node);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>或使用定时器将脚本设置为异步执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">   	const node = document.getElementById(&#x27;as&#x27;);</span><br><span class="line">    console.log(node)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>为脚本设置<code>type=&quot;module&quot;</code>,会延迟解析模块脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">   	const node &#x3D; document.getElementById(&#39;as&#39;);</span><br><span class="line">    console.log(node)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;h1 id&#x3D;&quot;as&quot;&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>或将脚本设置在外部文件并使用<code>defer/async</code>属性加载，即会等到DOM解析后迟延执行</p>
<ul>
<li>仅引入外部脚本时有效</li>
<li>多个外部脚本使用<code>defer/async</code>属性加载，不能够保证加载的前后顺序，当模块之间存在依赖时要注意</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;as&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;as&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h4><p>JS中获取html内容的对象，称为DOM节点对象（node)，即然是对象就包括操作NODE的属性和方法</p>
<ul>
<li>包括12种类型的节点对象</li>
<li>常用了节点为document、标签元素节点、文本节点、注释节点</li>
<li>节点均继承自Node类型，所以拥有相同的属性或方法</li>
<li>document是DOM操作的起始节点</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;body id=&quot;as&quot;&gt;</span><br><span class="line">  &lt;!-- 阿顺特烦恼 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	// document节点 noteType为9</span><br><span class="line">  console.log(document.nodeType)</span><br><span class="line">  </span><br><span class="line">  // 第一个子节点为&lt;!DOCTYPE html&gt;，且nodetype为10</span><br><span class="line">  console.log(document.childNodes.item(0).nodeType)</span><br><span class="line">  </span><br><span class="line">  // body 是标签节点 nodeType为1</span><br><span class="line">  console.log(document.body.nodeType) </span><br><span class="line">  </span><br><span class="line">  // body的属性节点nodeType 为2</span><br><span class="line">  console.log(document.body.attributes[0].nodeType)</span><br><span class="line">  </span><br><span class="line">	// body的第一个节点为文本节点，nodeType为3</span><br><span class="line">  console.log(document.body.childNodes.item(0).nodeType)</span><br><span class="line">  </span><br><span class="line">  // body的第二个节点为注释，nodeType类型为8</span><br><span class="line">  console.log(document.body.childNodes[1].nodeType)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在浏览器渲染过程中会将文档内容生成为不同的对象，来对下例中的h1标签进行讨论，其他节点情况相似</p>
<ul>
<li>不同类型节点由专有的构造函数创建对象</li>
<li>使用console.dir 可以打印出DOM节点对象结构</li>
<li>节点也是对象所以也具有JS对象的特征</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1 id=&quot;as&quot;&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function prototype(el) &#123;</span><br><span class="line">    console.log(el.__proto__)</span><br><span class="line">    el.__proto__ ? prototype(el.__proto__) : &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  prototype(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最终得到的节点的原型链为</p>
<table>
<thead>
<tr>
<th>原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>根对象</td>
</tr>
<tr>
<td>EventTarget</td>
<td>提供事件支持</td>
</tr>
<tr>
<td>Node</td>
<td>提供parentNode等节点操作方法</td>
</tr>
<tr>
<td>Element</td>
<td>提供getElementsByTagName、querySelector等方法</td>
</tr>
<tr>
<td>HTMLElement</td>
<td>所有元素的基础类，提供className、nodeName等方法</td>
</tr>
<tr>
<td>HTMLHeadingElement</td>
<td>Head标题元素类</td>
</tr>
</tbody></table>
<p>为标签元素和表单元素添加内容截取方法substr</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    &lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      class Utils &#123;</span><br><span class="line">      	//检查是否为表单元素</span><br><span class="line">        static isForm(node) &#123;</span><br><span class="line">          return node instanceof HTMLInputElement;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取原型</span><br><span class="line">        static getPrototype(node) &#123;</span><br><span class="line">          let prototypes = [];</span><br><span class="line">          let test = node.__proto__;</span><br><span class="line">          if (test) &#123;</span><br><span class="line">            prototypes.push(test);</span><br><span class="line">            prototypes.push(...Utils.getPrototype(test));</span><br><span class="line">          &#125;</span><br><span class="line">          return prototypes;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      Node.prototype.substr = function (m, n) &#123;</span><br><span class="line">        if (Utils.isForm(this)) &#123;</span><br><span class="line">          return this.value.substr(m, n);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return this.innerText.substr(m, n);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      //表单测试</span><br><span class="line">      let input = document.querySelector(&quot;input&quot;);</span><br><span class="line">      console.log(input.substr(0, 2));</span><br><span class="line">      console.log(Utils.getPrototype(input));</span><br><span class="line">      //标签测试</span><br><span class="line">      let div = document.querySelector(&quot;div&quot;);</span><br><span class="line">      console.log(div.substr(0, 2));</span><br><span class="line">      console.log(Utils.getPrototype(div));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对象特征"><a href="#对象特征" class="headerlink" title="对象特征"></a>对象特征</h4><p>即然DOM与我们其他JS创建的对象特征相仿，所以也可以为DOM对象添加属性或方法。</p>
<p>对于系统应用的属性，应该明确含义不应该随意使用，比如ID是用于标识元素唯一属性，不能用于其他目地</p>
<ul>
<li>后会会讲到其他解决方案，来自定义属性，下面的直接修改ID属性是不建议的</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let as = document.getElementById(&quot;as&quot;);</span><br><span class="line">as.id = &quot;Ashun&quot;;</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>title用于鼠标停留时显示提示文档也不应该用于其他目地</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  as.title = &#x27;Ashun&#x27;</span><br><span class="line">  console.log(as)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面是为对象合并属性的示例</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  Object.assign(as, &#123;</span><br><span class="line">    color: &#x27;red&#x27;,</span><br><span class="line">    change() &#123;</span><br><span class="line">      this.innerHTML = &#x27;Ashun&#x27;</span><br><span class="line">      this.style.color = this.color</span><br><span class="line">    &#125;,</span><br><span class="line">    onclick() &#123;</span><br><span class="line">      this.change()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>合并对象属性更改样式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  Object.assign(as.style, &#123;</span><br><span class="line">    color: &#x27;white&#x27;,</span><br><span class="line">    backgroundColor: &#x27;red&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DOCUMENT"><a href="#DOCUMENT" class="headerlink" title="DOCUMENT"></a>DOCUMENT</h3><p>document是window对象的属性，是由HTMLDocument类实现的实例。</p>
<ul>
<li>document包含 DocumentType（唯一）或 html元素（唯一）或 comment等元素</li>
</ul>
<p>原型链中也包含Node，所以可以使用有关节点操作的方法如nodeType/NodeName等</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.dir(document.nodeType)</span><br><span class="line">console.dir(document.nodeName)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关使用Document操作cookie与本地储存将会在相应章节中介绍</p>
</blockquote>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>下面通过节点的<code>nodeType</code>来获取html元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let html = [...document.childNodes].filter((node) =&gt; &#123;</span><br><span class="line">  if (node.nodeType === 1) &#123;</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)[0]</span><br><span class="line">console.log(html)</span><br></pre></td></tr></table></figure>

<p>获取整个html元素：<code>document.documentElement</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(document.documentElement)</span><br></pre></td></tr></table></figure>

<h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>使用<code>title</code>获取和设置文档标题</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//获取文档标题内容</span><br><span class="line">console.log(document.title)</span><br><span class="line"></span><br><span class="line">//设置文档标签内容</span><br><span class="line">document.title = &#x27;阿顺特烦恼-Ashun&#x27;</span><br></pre></td></tr></table></figure>

<p>获取<code>body</code>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.body</span><br></pre></td></tr></table></figure>

<p>获取当前<code>URL</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(document.URL)</span><br></pre></td></tr></table></figure>

<p><code>domain</code>获取域名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">document.domain</span><br></pre></td></tr></table></figure>

<p><code>referrer</code>获取来源地址</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">console.log(document.referrer)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>不同类型的节点拥有不同属性，下面是节点属性的说明与示例</p>
<h4 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h4><p>nodeType指以数值返回节点类型</p>
<table>
<thead>
<tr>
<th>nodeType</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>元素节点</td>
</tr>
<tr>
<td>2</td>
<td>属性节点</td>
</tr>
<tr>
<td>3</td>
<td>文本节点</td>
</tr>
<tr>
<td>8</td>
<td>注释节点</td>
</tr>
<tr>
<td>9</td>
<td>document对象</td>
</tr>
</tbody></table>
<p>下面是节点nodeType的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ashun&quot;&gt;&lt;!-- 阿顺特烦恼 --&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; document.querySelector(&#96;#app&#96;)</span><br><span class="line">  console.log(node.nodeType) &#x2F;&#x2F;1</span><br><span class="line">  console.log(node.firstChild);&#x2F;&#x2F; #text&#123;…&#125;</span><br><span class="line">  console.log(node.firstChild.nodeType) &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">  const as &#x3D; document.querySelector(&#39;.ashun&#39;)</span><br><span class="line">  console.log(as.childNodes[0].nodeType) &#x2F;&#x2F;8</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用对象的原型检测节点类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">let p = document.querySelector(&#x27;p&#x27;)</span><br><span class="line">console.log(h1 instanceof HTMLHeadingElement) //true</span><br><span class="line">console.log(p instanceof HTMLHeadingElement) //false</span><br><span class="line">console.log(p instanceof Element) //true</span><br></pre></td></tr></table></figure>

<p>下面递归获取所有标签元素，并返回符合html嵌套结构的数据。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  &lt;div id=&quot;as&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;strong&gt;阿顺特烦恼&lt;/strong&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;p1&gt;ashun&lt;span&gt;ashuna&lt;/span&gt;&lt;/p1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">				function childTag(node) &#123;</span><br><span class="line">          let result = [];</span><br><span class="line">          [...node.childNodes].map((v) =&gt; &#123;</span><br><span class="line">            if (v.nodeType === 1) &#123;</span><br><span class="line">              result.push(&#123; node: v, childs: childTag(v) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          return result;</span><br><span class="line">        &#125;</span><br><span class="line">        let as = document.getElementById(&quot;as&quot;);</span><br><span class="line">        console.log(childTag(as));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>优化：当没有子节点时，childs为null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">result.push(&#123; node: v, childs: childTag(v).length ? childTag(v) : null &#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h4><p>nodeName指定节点的名称</p>
<ul>
<li>获取值为大写形式</li>
</ul>
<table>
<thead>
<tr>
<th>nodeType种类</th>
<th>nodeName返回结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>元素名称如DIV</td>
</tr>
<tr>
<td>2</td>
<td>属性名称</td>
</tr>
<tr>
<td>3</td>
<td>#text</td>
</tr>
<tr>
<td>8</td>
<td>#comment</td>
</tr>
</tbody></table>
<p>下面来操作 nodeName</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺特烦恼 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.nodeName) //DIV</span><br><span class="line">  console.log(node.firstChild.nodeName) //#text</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(as.childNodes[0].nodeName) //#comment</span><br><span class="line">  console.log(as.attributes.class.nodeName);//calss</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="tagName"><a href="#tagName" class="headerlink" title="tagName"></a>tagName</h4><p>nodeName可以获取不限于节点种类的名称，tagName仅能用于获取标签元素节点名称</p>
<ul>
<li>tagName存在于Element类的原型中</li>
<li>元素上使用tagName与nodeName无异</li>
<li>获取值为大写形式</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;ashun&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  console.log(node.tagName) //H1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h4><p>使用nodeValue或data函数获取节点值，也可以使用节点的data属性获取节点内容</p>
<table>
<thead>
<tr>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>3</td>
<td>文本内容</td>
</tr>
<tr>
<td>8</td>
<td>注释内容</td>
</tr>
</tbody></table>
<p>下面来看nodeValue的示例</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.nodeValue) //null</span><br><span class="line">  console.log(node.innerHTML)</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.as&#x27;)</span><br><span class="line">  console.log(as.firstChild.nodeValue) //ASHUN</span><br><span class="line"></span><br><span class="line">  const ashun = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(ashun.childNodes[0].nodeValue) // 阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用data属性获取节点内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  阿顺特烦恼</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.childNodes[0].data)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="树状节点"><a href="#树状节点" class="headerlink" title="树状节点"></a>树状节点</h4><p>下面获取标签树状结构即多级标签结构，来加深一下nodeType/nodeName等知识</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function element(node) &#123;</span><br><span class="line">        if (node.nodeType != 1) return</span><br><span class="line"></span><br><span class="line">        return Array.from(node.childNodes)</span><br><span class="line">            .filter(node =&gt; node.nodeType == 1)</span><br><span class="line">            .map(node =&gt; (&#123;</span><br><span class="line">                name: node.nodeName,</span><br><span class="line">                children: element(node),</span><br><span class="line">            &#125;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let nodes = element(document.documentElement)</span><br><span class="line">    console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="节点集合"><a href="#节点集合" class="headerlink" title="节点集合"></a>节点集合</h3><p>Nodelist与HTMLCollection都是包含多个节点标签的集合，大部分功能也是相同的。</p>
<ul>
<li><code>getElementsBy...</code>等方法、<code>node.children</code> 返回的是HTMLCollection</li>
<li><code>querySelectorAll </code>、<code>node.childNodes</code> 返回的是 NodeList</li>
<li>二者都是<code>类数组</code>结构，可直接通过下标访问dom，但不能直接使用Array的方法，二者都可以迭代，二者也存在差异</li>
</ul>
<p><strong>HTMLCollection</strong></p>
<ul>
<li>不可使用<code>for/each</code>遍历</li>
<li>只是元素集合，包含dom元素</li>
</ul>
<p><strong>NodeList</strong></p>
<ul>
<li>可使用<code>for/each</code>遍历</li>
<li>querySelectorAll 返回的虽然是 NodeList ，但是实际上是元素集合（只包含元素），并且是静态的（其他接口返回的HTMLCollection和NodeList都是live的）</li>
<li>NodeList是节点集合（可以包含元素，也可以包含文本节点）</li>
</ul>
<p>nodelist包含文本节点</p>
<img src="C:/Users/张佳顺/Desktop/study1.assets/image-20210411170505383.png" alt="image-20210411170505383" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;a&quot;&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;cc&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">console.log(document.getElementsByClassName(&#39;a&#39;)[0].childNodes);&#x2F;&#x2F;nodelist</span><br><span class="line">console.log(document.getElementsByClassName(&#39;a&#39;)[0].children);&#x2F;&#x2F;Htmlcollection</span><br></pre></td></tr></table></figure>

<p>HTMLCollection不可使用for/each遍历操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let htmlCollection &#x3D; document.getElementsByClassName(&quot;shun&quot;);</span><br><span class="line">let nodeList &#x3D; document.querySelectorAll(&quot;.shun&quot;);</span><br><span class="line"></span><br><span class="line">nodeList.forEach((v) &#x3D;&gt; console.log(v));</span><br><span class="line">htmlCollection.forEach((v) &#x3D;&gt; console.log(v)); &#x2F;&#x2F;forEach is not a function</span><br></pre></td></tr></table></figure>



<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>Nodelist与HTMLCollection包含length属性，记录了节点元素的数量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    console.log(nodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h4><p>有时使用数组方法来操作节点集合，这就需要将节点集合转化为数组类型，有以下几种方式可以实现。</p>
<ol>
<li>使用call调用原型方法</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  let arr = Array.prototype.slice.call(elements, 0)</span><br><span class="line">  console.log(arr)</span><br><span class="line">  arr.map((item) =&gt; &#123;</span><br><span class="line">    item.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Array.from转换</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  console.log(Array.from(elements))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下面使用点语法转换节点为数组</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  ;[...elements].map((item) =&gt; &#123;</span><br><span class="line">    item.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">      this.style.textTransform = &#x27;uppercase&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="item"><a href="#item" class="headerlink" title="item"></a>item</h4><p>Nodelist与HTMLCollection提供了item()方法来根据索引获取元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes.item(0))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用数组索引获取更方便</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes[0])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="namedItem"><a href="#namedItem" class="headerlink" title="namedItem"></a>namedItem</h4><p>HTMLCollection具有namedItem方法可以按name或id属性来获取元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes.namedItem(&#x27;as&#x27;))</span><br><span class="line">   console.dir(nodes.namedItem(&#x27;astfn&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用属性方式获取</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;as&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  console.dir(nodes[&#x27;as&#x27;]);</span><br><span class="line">  console.dir(nodes.astfn)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>即HTMLCollection，可以通过属性的形式，获取对应 <code>索引、id属性、name属性</code> 的dom元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 name&#x3D;&quot;as&quot;&gt;ASHUN&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let items &#x3D; document.getElementsByTagName(&#39;h1&#39;)</span><br><span class="line">  console.log(items[0])</span><br><span class="line">  console.log(items[&quot;astfn&quot;])</span><br><span class="line">  console.log(items[&#39;as&#39;])</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="常用元素"><a href="#常用元素" class="headerlink" title="常用元素"></a>常用元素</h4><p>系统针对特定标签提供了快速选择的方式</p>
<p>下面展示的是获取所有a标签<code>document.links</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;&quot;&gt;Ashuntefannao&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.links;</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>获取特定元素方法如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>document.documentElement</td>
<td>文档节点即html标签节点</td>
</tr>
<tr>
<td>document.body</td>
<td>body标签节点</td>
</tr>
<tr>
<td>document.head</td>
<td>head标签节点</td>
</tr>
<tr>
<td>document.links</td>
<td>超链接集合</td>
</tr>
<tr>
<td>document.anchors</td>
<td>所有锚点集合</td>
</tr>
<tr>
<td>document.forms</td>
<td>form表单集合</td>
</tr>
<tr>
<td>document.images</td>
<td>图片集合</td>
</tr>
</tbody></table>
<hr>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>节点是父子级嵌套与前后兄弟关系，使用DOM提供的API可以获取这种关系的元素。</p>
<ul>
<li><strong>文本和注释也是节点，所以也在匹配结果中</strong></li>
<li>若只想获取dom元素，而不希望获得其它类型的节点，可以参考后续的<strong>元素关系</strong></li>
</ul>
<h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>节点是根据HTML内容产生的，所以也存在父子、兄弟、祖先、后代等节点关系，下例中的代码就会产生这种多重关系</p>
<ul>
<li>h1与ul是兄弟关系</li>
<li>span与li是父子关系</li>
<li>ul与span是后代关系</li>
<li>span与ul是祖先关系</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span&gt;Ashuntefannao&lt;/span&gt;</span><br><span class="line">    &lt;strong&gt;ashun&lt;/strong&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>下面是通过节点关系获取相应元素的方法</p>
<table>
<thead>
<tr>
<th>节点属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>childNodes</td>
<td>获取所有子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>获取父节点</td>
</tr>
<tr>
<td>firstChild</td>
<td>子节点中第一个</td>
</tr>
<tr>
<td>lastChild</td>
<td>子节点中最后一个</td>
</tr>
<tr>
<td>nextSibling</td>
<td>下一个兄弟节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>上一个兄弟节点</td>
</tr>
</tbody></table>
<p>子节点集合与首、尾节点获取</p>
<ul>
<li>文本也是node所以也会在匹配当中</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;阿顺&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#app`)</span><br><span class="line">  console.log(node.childNodes) //所有子节点</span><br><span class="line">  console.log(node.firstChild) //第一个子节点是文本节点（换行符和空白字符）</span><br><span class="line">  console.log(node.lastChild) //最后一个子节点也是文本节点（换行符和空白字符）</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;astfn&quot; data&#x3D;&quot;as&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ashun&quot;&gt;阿顺&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; app.querySelector(&#96;.shun&#96;)</span><br><span class="line">  console.log(node.parentNode) &#x2F;&#x2F;div#app</span><br><span class="line">  console.log(node.childNodes) &#x2F;&#x2F;文本节点</span><br><span class="line">  console.log(node.nextSibling) &#x2F;&#x2F;下一个兄弟节点是文本节点（换行符和空白字符）</span><br><span class="line">  console.log(node.previousSibling) &#x2F;&#x2F;上一个节点也是文本节点（换行符和空白字符）</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>document是顶级节点html标签的父节点是document</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.parentNode === document)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下例是查找元素的所有父节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;as&quot;&gt;ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function parentNodes(node) &#123;</span><br><span class="line">    let nodes &#x3D; []</span><br><span class="line">    while ((node &#x3D; node.parentNode)) nodes.push(node)</span><br><span class="line">    return nodes</span><br><span class="line">  &#125;</span><br><span class="line">  const el &#x3D; document.getElementById(&#39;as&#39;)</span><br><span class="line">  const nodes &#x3D; parentNodes(el)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>获取所有的后代元素SPAN的内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span&gt;Ashuntefannao&lt;/span&gt;</span><br><span class="line">  &lt;h2&gt;</span><br><span class="line">    &lt;span&gt;ASHUN&lt;/span&gt;</span><br><span class="line">  &lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function getChildDom(parent, dom) &#123;</span><br><span class="line">  	let doms = [];</span><br><span class="line">  	for (let elem of parent.childNodes) &#123;</span><br><span class="line">   		if (elem.nodeName === dom.toUpperCase()) doms.push(elem);</span><br><span class="line">    	doms = doms.concat(getChildDom(elem, dom));</span><br><span class="line">      // doms.push(...getChildDom(elem, dom));</span><br><span class="line">  	&#125;</span><br><span class="line">   	return doms;</span><br><span class="line">  &#125;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const nodes = getChildNodeByName(app, &#x27;span&#x27;)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="元素关系"><a href="#元素关系" class="headerlink" title="元素关系"></a>元素关系</h3><p>使用childNodes等获取的节点<code>包括文本与注释</code>，但这不是我们常用的，系统也提供了只操作元素的方法。</p>
<table>
<thead>
<tr>
<th>节点属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>parentElement</td>
<td>获取父元素</td>
</tr>
<tr>
<td>children</td>
<td>获取所有子元素</td>
</tr>
<tr>
<td>childElementCount</td>
<td>子标签元素的数量</td>
</tr>
<tr>
<td>firstElementChild</td>
<td>第一个子标签</td>
</tr>
<tr>
<td>lastElementChild</td>
<td>最后一个子标签</td>
</tr>
<tr>
<td>previousElementSibling</td>
<td>上一个兄弟标签</td>
</tr>
<tr>
<td>nextElementSibling</td>
<td>下一个兄弟标签</td>
</tr>
<tr>
<td>contains</td>
<td>返回布尔值，判断传入的节点是否为该节点的后代节点</td>
</tr>
</tbody></table>
<p>以下实例展示怎样通过元素关系获取元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;&lt;!-- 阿顺 --&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  console.log(app.children) //所有子元素</span><br><span class="line">  console.log(app.firstElementChild) //第一个子元素 div.astfn</span><br><span class="line">  console.log(app.lastElementChild) //最后一个子元素 div.ashun</span><br><span class="line"></span><br><span class="line">  const as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  console.log(as.parentElement) //父元素 div#app</span><br><span class="line"></span><br><span class="line">  console.log(as.previousElementSibling) //上一个兄弟元素 div.astfn</span><br><span class="line">  console.log(as.nextElementSibling) //下一个兄弟元素 div.ashun</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>html标签的父节点是document，但父标签节点不存在</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.parentNode === document) //true</span><br><span class="line">  console.log(document.documentElement.parentElement) //null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><p>系统提供了丰富的选择节点（NODE）的操作方法，下面我们来一一说明</p>
<h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h4><p>使用ID选择是非常方便的选择具有ID值的节点元素，但注意ID应该是唯一的</p>
<ul>
<li>只能通过document对象调用</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.getElementById(&#x27;as&#x27;)</span><br><span class="line">  console.dir(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面自定义函数来支持批量按ID选择元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function getByElementIds(ids) &#123;</span><br><span class="line">    return ids.map((id) =&gt; document.getElementById(id))</span><br><span class="line">  &#125;</span><br><span class="line">  let nodes = getByElementIds([&#x27;as&#x27;, &#x27;app&#x27;])</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>拥有ID的元素可做为WINDOW的属性进行访问</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果声明了变量这种访问方式将无效，所以并不建议使用这种方式访问对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = &#x27;ashun&#x27;</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>getElementById只能通过document访问，不能通过元素读取拥有ID的子元素，下面的操作将产生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">  &lt;div id=&quot;as&quot;&gt;阿顺&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const node = app.getElementById(&#x27;as&#x27;) //app.getElementById is not a function</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementByName"><a href="#getElementByName" class="headerlink" title="getElementByName"></a>getElementByName</h4><p>使用getElementByName获取<strong>设置了name属性的元素</strong>，虽然在DIV等元素上同样有效，但一般用来对表单元素进行操作时使用。</p>
<ul>
<li>返回NodeList节点列表对象</li>
<li>NodeList顺序为元素在文档中的顺序</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const div = document.getElementsByName(&#x27;astfn&#x27;)</span><br><span class="line">  console.dir(div)</span><br><span class="line">  const input = document.getElementsByName(&#x27;username&#x27;)</span><br><span class="line">  console.dir(input)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h4><p>使用getElementsByTagName用于按标签名获取元素</p>
<ul>
<li>返回HTMLCollection元素集合</li>
<li>是不区分大小的获取</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const divs = document.getElementsByTagName(&#x27;DIV&#x27;)</span><br><span class="line">  console.dir(divs)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通配符</strong></p>
<p>可以使用通配符 ***** 获取所有元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;*&#x27;)</span><br><span class="line">  console.dir(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h4><p>getElementsByClassName用于按class样式属性值获取元素集合</p>
<ul>
<li>设置多个值时顺序无关，指包含这些class属性的元素</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;astfn shun title&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByClassName(&#x27;shun&#x27;)</span><br><span class="line">  console.log(nodes.length) //2</span><br><span class="line"></span><br><span class="line">  //查找包含class属性包括 astfn 与 shun 的元素</span><br><span class="line">  const tags = document.getElementsByClassName(&#x27;astfn shun&#x27;)</span><br><span class="line">  console.log(tags.length) //1</span><br></pre></td></tr></table></figure>



<h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><h4 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h4><p>结合节点列表的length属性，使用for遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div name=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    console.log(nodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Nodelist节点列表可以使用forEach来进行遍历，但HTMLCollection则不可以</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">  nodes.forEach((node, key) =&gt; &#123;</span><br><span class="line">    console.log(node)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>节点集合对象不是Array，原型中不存在map方法，但可以借用Array的原型map方法实现遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">  Array.prototype.map.call(nodes, (node, index) =&gt; &#123;</span><br><span class="line">    console.log(node, index)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from用于将类数组转为组件，并提供第二个迭代函数。所以可以借用Array.from实现遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  Array.from(nodes, (node, index) =&gt; &#123;</span><br><span class="line">    console.log(node, index)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以先使用Array.from将节点列表转为Array，再使用Array的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div name&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class="line">  let astfn&#x3D;Array.from(nodes).filter(v&#x3D;&gt;v.id&#x3D;&#x3D;&#x3D;&quot;astfn&quot;);</span><br><span class="line">  console.log(astfn)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="forOf"><a href="#forOf" class="headerlink" title="forOf"></a>forOf</h4><p>节点集合是类数组的可迭代对象所以可以使用for…of进行遍历</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;div name=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  for (const item of nodes) &#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>也可使用<code>for/of</code>结合Object迭代器进行遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;astfn&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div name&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class="line">  for (let [key, dom] of Object.entries(nodes)) &#123;</span><br><span class="line">        console.log(key, dom);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let key of Object.keys(nodes)) console.log(key);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let dom of Object.values(nodes)) console.log(dom);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h3><p>在CSS中可以通过样式选择器修饰元素样式，在DOM操作中也可以使用这种方式查找元素。使用过jQuery库的朋友，应该对这种选择方式印象深刻。</p>
<p>使用getElementsByTagName等方式选择元素不够灵活，建议使用下面的样式选择器操作，更加方便灵活</p>
<h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h4><p>使用querySelectorAll根据CSS选择器获取Nodelist节点列表</p>
<ul>
<li><code>获取的NodeList节点列表是静态的，添加或删除元素后不变</code></li>
<li>可以链式调用，即 既是document的接口，也是dom元素的接口。可以获取对应dom的子孙dom</li>
</ul>
<p>获取所有div元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; document.getElementById(&#39;app&#39;)</span><br><span class="line">  const nodes &#x3D; app.querySelectorAll(&#39;div&#39;)</span><br><span class="line">  console.log(nodes.length) &#x2F;&#x2F;2</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>可以在其中应用css选择器规则，获取对应的节点列表</p>
<ul>
<li>获取id为app的dom中class为ashun的子节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; class&#x3D;&quot;ashun&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let nodes&#x3D;document.querySelectorAll(&quot;#app .ashun&quot;);</span><br><span class="line"> console.log(nodes.length);&#x2F;&#x2F;2</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据属性选择器获取元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;title&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; data&#x3D;&quot;as&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let nodes&#x3D;document.querySelectorAll(&quot;#app [data&#x3D;&#39;as&#39;]&quot;);</span><br><span class="line"> console.log(nodes[0]);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h4><p>querySelector使用CSS选择器获取一个元素，下面是根据属性获取单个元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;astfn&quot; data=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = app.querySelector(`#astfn[data=&#x27;as&#x27;]`)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>若存在多个相同属性的元素，则只获取第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;astfn&quot; class&#x3D;&quot;ashun&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;ashun&quot;&gt;ASHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node &#x3D; app.querySelector(&#96;.ashun&#96;)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="matches"><a href="#matches" class="headerlink" title="matches"></a>matches</h4><p><code>node.matches(cssSelector)</code>用于检测<strong>某元素</strong>是否与 <strong>指定的样式选择器匹配</strong>，下面过滤掉所有name属性的LI元素。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;li&gt;Ashuntefannao&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;ASHUN&lt;/li&gt;</span><br><span class="line">  &lt;li name=&quot;as&quot;&gt;阿顺&lt;/li&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  const nodes = [...app.querySelectorAll(&#x27;li&#x27;)].filter((node) =&gt; &#123;</span><br><span class="line">    return !node.matches(`[name]`)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(nodes)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="closest"><a href="#closest" class="headerlink" title="closest"></a>closest</h4><p>查找最近的符合选择器的祖先元素（包括自身），下例查找父级拥有 <code>.comment</code>类的元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;comment&quot;&gt;</span><br><span class="line">  &lt;ul class=&quot;comment&quot;&gt;</span><br><span class="line">    &lt;li&gt;阿顺特烦恼&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const li = document.getElementsByTagName(&#x27;li&#x27;)[0]</span><br><span class="line">  const node = li.closest(`.comment`)</span><br><span class="line">  console.log(node)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="动态与静态获取"><a href="#动态与静态获取" class="headerlink" title="动态与静态获取"></a>动态与静态获取</h3><ul>
<li><p>下面讨论的是 元素/节点<strong>集合</strong> 的动态与静态，而不是某个元素/节点的动态与静态。</p>
</li>
<li><p>获取某个元素都是静态的。</p>
</li>
</ul>
<p>通过 getElementsByTagname 等getElementsBy… 函数获取的Nodelist与HTMLCollection集合是动态的，即有元素添加或移动操作将实时反映最新状态。</p>
<ul>
<li>使用getElement…返回的都是动态的集合</li>
<li>使用querySelectorAll返回的是静态集合</li>
</ul>
<h4 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h4><p>下例中通过按钮动态添加元素后，获取的元素集合是动态的，而不是上次获取的固定快照。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;button id=&quot;add&quot;&gt;添加元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.getElementsByTagName(&#x27;h1&#x27;)</span><br><span class="line">  console.log(elements)</span><br><span class="line">  let button = document.querySelector(&#x27;#add&#x27;)</span><br><span class="line">  button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    document.querySelector(&#x27;body&#x27;).insertAdjacentHTML(&#x27;beforeend&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)</span><br><span class="line">    console.log(elements)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<p>document.querySelectorAll获取的集合是静态的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;button id=&quot;add&quot;&gt;添加元素&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let elements = document.querySelectorAll(&#x27;h1&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(elements.length)</span><br><span class="line">  let button = document.querySelector(&#x27;#add&#x27;)</span><br><span class="line">  button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    document.querySelector(&#x27;body&#x27;).insertAdjacentHTML(&#x27;beforeend&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)</span><br><span class="line">    console.log(elements.length)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用静态"><a href="#使用静态" class="headerlink" title="使用静态"></a>使用静态</h4><p>如果需要保存静态集合，则需要对集合进行复制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;astfn&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;ashun&quot;&gt;ASHUN&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const nodes = document.getElementsByTagName(&#x27;div&#x27;)</span><br><span class="line">  const clone = Array.prototype.slice.call(nodes)</span><br><span class="line">  console.log(nodes.length);//2</span><br><span class="line">  document.body.appendChild(document.createElement(&#x27;div&#x27;))</span><br><span class="line">  console.log(nodes.length);//3</span><br><span class="line">  console.log(clone.length);//2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h3><p>即在js中能够直接通过属性的方式，访问/操作DOM元素的属性。元素的标准属性具有相对应的DOM对象属性</p>
<ul>
<li>操作属性<code>区分大小写</code></li>
<li>多个单词属性命名规则为第一个单词小写，其他单词驼峰式命名</li>
<li>属性值是多类型并不全是字符串，也可能是对象等</li>
<li>事件处理程序属性值为函数</li>
<li>style属性为CSSStyleDeclaration对象</li>
<li>DOM对象不同生成的属性也不同</li>
</ul>
<h4 id="属性别名"><a href="#属性别名" class="headerlink" title="属性别名"></a>属性别名</h4><p>有些属性名与JS关键词冲突，系统已经起了别名</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>className</td>
</tr>
<tr>
<td>for</td>
<td>htmlFor</td>
</tr>
</tbody></table>
<h4 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h4><p>元素的标准属性可以直接进行操作，下面是直接设置元素的className</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;as&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;ashun&quot;&gt;Ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(`#app`)</span><br><span class="line">  app.className = &#x27;astfn ashun&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面设置图像元素的标准属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let img = document.images[0]</span><br><span class="line">  img.src = &#x27;https://www.Ashuntefannao.com/icon.jpg&#x27;</span><br><span class="line">  img.alt = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用hidden隐藏元素</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.hidden = true</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过style属性改变行内样式</p>
<ul>
<li>js操作Dom属性时，多个单词属性命名规则为第一个单词小写，其他单词驼峰式命名</li>
<li>js中的背景颜色<code>backgroundColor</code>,css中<code>backgorund-color</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; document.querySelector(&#39;#app&#39;)</span><br><span class="line">  app.addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    this.style.backgroundColor &#x3D; &quot;red&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="多类型值"><a href="#多类型值" class="headerlink" title="多类型值"></a>多类型值</h4><p>大部分属性值是都是字符串，但并不是全部，下例中需要转换为数值后进行数据运算</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;age&quot; value=&quot;88&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let input = document.getElementsByName(&#x27;age&#x27;).item(0)</span><br><span class="line">  input.value = parseInt(input.value) + 100</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面表单checked属性值为Boolean类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;label for=&quot;hot&quot;&gt; &lt;input id=&quot;hot&quot; type=&quot;checkbox&quot; name=&quot;hot&quot; /&gt;热门 &lt;/label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`[name=&#x27;hot&#x27;]`)</span><br><span class="line">  node.addEventListener(&#x27;change&#x27;, function () &#123;</span><br><span class="line">    console.log(this.checked)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>属性值<code>并非</code>都与HTML定义的值一样，下面返回的href属性值是完整链接</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#Ashuntefannao&quot; id=&quot;home&quot;&gt;阿顺特烦恼&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#home`)</span><br><span class="line">  console.log(node.href)	</span><br><span class="line">  //http://127.0.0.1:5500/dom.html#Ashuntefannao</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="元素特征"><a href="#元素特征" class="headerlink" title="元素特征"></a>元素特征</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>对于标准的属性可以直接通过DOM属性的方式进行操作，但对于标签的 非标准的定制属性 则不可以。但JS提供了方法来控制标准或非标准的属性</p>
<p>可以理解为元素的属性分两个地方保存，DOM属性中记录标准属性，特征中记录标准和定制属性</p>
<ul>
<li>使用特征操作时属性名称不区分大小写</li>
<li>特征值都为字符串类型</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getAttribute(“prop”)</td>
<td>获取属性值</td>
</tr>
<tr>
<td>setAttribute(“prop”,”value”)</td>
<td>设置属性/添加属性</td>
</tr>
<tr>
<td>removeAttribute(“prop”)</td>
<td>删除属性</td>
</tr>
<tr>
<td>hasAttribute(“prop”)</td>
<td>属性检测</td>
</tr>
</tbody></table>
<p>特征是可迭代对象，下面使用for…of来进行遍历操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;add&quot; class&#x3D;&quot;add&quot;&gt;添加元素&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     let attrs &#x3D; document.querySelector(&quot;#add&quot;).attributes;</span><br><span class="line">      console.log(attrs);	&#x2F;&#x2F;NamedNodeMap &#123;…&#125;</span><br><span class="line">      for (const &#123; name, value &#125; of nameNodeMap) &#123;</span><br><span class="line">        console.log(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>getAttribute</code>获取的属性值都为<code>字符串</code>，所以若要获取数值类型需要进行转换</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;age&quot; value=&quot;88&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let input = document.getElementsByName(&#x27;age&#x27;).item(0)</span><br><span class="line">  let value = input.getAttribute(&#x27;value&#x27;) * 1 + 100</span><br><span class="line">  input.setAttribute(&#x27;value&#x27;, value)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用removeAttribute删除元素的class属性，并通过hasAttribute进行检测删除结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;ashun&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let as = document.querySelector(&#x27;.ashun&#x27;)</span><br><span class="line">  as.removeAttribute(&#x27;class&#x27;)</span><br><span class="line">  console.log(as.hasAttribute(&#x27;class&#x27;)) //false</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>特征值与HTML定义的值是<code>一致的</code>，这和标准属性进行访问是不同的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#Ashuntefannao&quot; id=&quot;home&quot;&gt;后盾人&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const node = document.querySelector(`#home`)</span><br><span class="line">  </span><br><span class="line">  // http://127.0.0.1:5500/dom.html#Ashuntefannao</span><br><span class="line">  console.log(node.href)</span><br><span class="line">  </span><br><span class="line">  // #Ashuntefannao</span><br><span class="line">  console.log(node.getAttribute(&#x27;href&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><p>元素提供了attributes 属性可以只读的获取元素的属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-content=&quot;阿顺&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)；</span><br><span class="line">  console.log(astfn.attributes);</span><br><span class="line">  console.dir(astfn.attributes[&#x27;class&#x27;].nodeValue) //astfn</span><br><span class="line">  console.dir(astfn.attributes[&#x27;data-content&#x27;].nodeValue) //阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="自定义特征"><a href="#自定义特征" class="headerlink" title="自定义特征"></a>自定义特征</h4><p>虽然可以随意定义特征并使用getAttribute等方法管理，但很容易造成与标签的现在或未来属性重名。建议使用以data-为前缀的自定义特征处理，针对这种定义方式JS也提供了接口方便操作。</p>
<ul>
<li>元素中以data-为前缀的属性会添加到内置的data属性集中</li>
<li>使用<code>dom.dataset</code>可获取对应dom的data属性集</li>
<li>改变dataset的值也会影响到元素上</li>
</ul>
<p>下面演示使用属性集设置DIV标签内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-content=&quot;阿顺特烦恼&quot; data-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  let content = astfn.dataset.content</span><br><span class="line">  console.log(content) //阿顺特烦恼</span><br><span class="line">  astfn.innerHTML = `&lt;span style=&quot;color:$&#123;astfn.dataset.color&#125;&quot;&gt;$&#123;content&#125;&lt;/span&gt;`</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>多个单词的特征使用驼峰命名方式读取</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;astfn&quot; data-title-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  astfn.innerHTML = `</span><br><span class="line">    &lt;span style=&quot;color:$&#123;astfn.dataset.titleColor&#125;&quot;&gt;$&#123;astfn.innerHTML&#125;&lt;/span&gt;</span><br><span class="line">  `</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>改变dataset值也会影响到页面元素上</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">div class=&quot;astfn&quot; data-title-color=&quot;red&quot;&gt;ashun&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let astfn = document.querySelector(&#x27;.astfn&#x27;)</span><br><span class="line">  astfn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.dataset.titleColor = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;][Math.floor(Math.random() * 3)]</span><br><span class="line">    this.style.color = this.dataset.titleColor</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h4><p>特征和标准属性，是记录元素属性的两个不同场所，<code>大部分更改会进行同步操作</code>。</p>
<ul>
<li>有些情况，通过标准属性更改，不能同步到元素特征，但元素特征的更改，能够同步到标准属性</li>
<li>推荐使用属性特征方法</li>
</ul>
<p>下面使用属性更改了className，会自动同步到了特征集中，反之亦然</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;red&quot;&gt;ASHUNTEFANNAO&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.className = &#x27;astfn&#x27;</span><br><span class="line">  console.log(app.getAttribute(&#x27;class&#x27;)) //astfn</span><br><span class="line">  app.setAttribute(&#x27;class&#x27;, &#x27;blue&#x27;)</span><br><span class="line">  console.log(app.className) //blue</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面对input值使用标准属性设置，<strong>但并没有同步到特征</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;package&quot; value=&quot;Ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const package = document.querySelector(`[name=&#x27;package&#x27;]`)</span><br><span class="line">  package.value = &#x27;阿顺&#x27;</span><br><span class="line">  console.log(package.getAttribute(&#x27;value&#x27;))//Ashuntefannao</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但改变input的特征value会同步到DOM对象的标准属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;package&quot; value=&quot;Ashuntefannao&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const package = document.querySelector(`[name=&#x27;package&#x27;]`)</span><br><span class="line">  package.setAttribute(&#x27;value&#x27;, &#x27;阿顺&#x27;)</span><br><span class="line">  console.log(package.value) //阿顺</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>创建节点的就是构建出DOM对象，然后根据需要添加到其他节点中</p>
<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建文本节点并添加到元素中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let text = document.createTextNode(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.append(text)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>使用createElement方法可以标签节点，下例创建span标签新节点并添加到div#app</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let span = document.createElement(&#x27;span&#x27;)</span><br><span class="line">  span.innerHTML = &#x27;Ashun&#x27;</span><br><span class="line">  app.append(span)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用PROMISE结合节点操作来加载外部JAVASCRIPT文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function js(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let js = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    js.type = &#x27;text/javascript&#x27;</span><br><span class="line">    js.src = file</span><br><span class="line">    js.onload = resolve</span><br><span class="line">    js.onerror = reject</span><br><span class="line">    document.head.appendChild(js)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js(&#x27;11.js&#x27;)</span><br><span class="line">  .then(() =&gt; console.log(&#x27;加载成功&#x27;))</span><br><span class="line">  .catch((error) =&gt; console.log(`$&#123;error.target.src&#125; 加载失败`))</span><br></pre></td></tr></table></figure>

<p>使用同样的逻辑来实现加载CSS文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function css(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let css = document.createElement(&#x27;link&#x27;)</span><br><span class="line">    css.rel = &#x27;stylesheet&#x27;</span><br><span class="line">    css.href = file</span><br><span class="line">    css.onload = resolve</span><br><span class="line">    css.onerror = reject</span><br><span class="line">    document.head.appendChild(css)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">css(&#x27;1.css&#x27;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;加载成功&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="cloneNode-amp-importNode"><a href="#cloneNode-amp-importNode" class="headerlink" title="cloneNode&amp;importNode"></a>cloneNode&amp;importNode</h4><p>使用cloneNode和document.importNode用于复制节点对象操作</p>
<ul>
<li>cloneNode是节点的方法：<code>dom.cloneNode(boolean)</code></li>
<li>cloneNode 参数为true时递归复制子节点即深拷贝</li>
<li>importNode是documet对象方法：<code>document.importNode(elem,boolean)</code></li>
</ul>
<p><code>dom.cloneNode(true)</code>复制div#app节点及其子节点，并添加到body元素中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let newApp = app.cloneNode(true)</span><br><span class="line">  document.body.appendChild(newApp)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>dom.cloneNode(false)</code>只clone目标节点本身,不递归复制子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	const node &#x3D; document.querySelector(&#96;#app&#96;);</span><br><span class="line">	let newNode &#x3D; node.cloneNode(false);</span><br><span class="line">	console.log(newNode);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>document.importNode(elem,boolean)</code>方法是低版本IE浏览器不支持的，也是复制节点对象的方法</p>
<ul>
<li>第一个参数为节点对象</li>
<li>第二个参数为true时递归复制</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;span&gt;阿顺特烦恼&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let newApp = document.importNode(app, true)</span><br><span class="line">  document.body.appendChild(newApp)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="节点内容"><a href="#节点内容" class="headerlink" title="节点内容"></a>节点内容</h3><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>inneHTML用于向标签中添加html内容，同时触发浏览器的解析器<code>重绘DOM</code>。</p>
<p>下例使用innerHTML获取和设置div内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span&gt;阿顺特烦恼&lt;/span&gt;</span><br><span class="line">  &lt;div class=&quot;as&quot;&gt;Ashun&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.innerHTML)</span><br><span class="line"></span><br><span class="line">  app.innerHTML = &#x27;&lt;h1&gt;阿顺&lt;/h1&gt;&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重绘节点</strong></p>
<p>使用innertHTML操作会重绘元素，下面在点击第二次就没有效果了</p>
<ul>
<li>因为对#app内容进行了重绘，即删除原内容然后设置新内容</li>
<li>重绘后产生的button对象<code>也没有了事件</code></li>
<li>重绘后又产生了新img对象，所以在控制台中可看到新图片在加载</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;button&gt;Ashuntefannao&lt;/button&gt;</span><br><span class="line">  &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    alert(this.innerHTML)</span><br><span class="line">    this.parentElement.innerHTML += &#x27;&lt;hr/&gt;阿顺特烦恼&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h4><p>outerHTML与innerHTML的区别是包含父标签</p>
<ul>
<li>outerHTML不会删除原来的旧元素</li>
<li>只是用新内容替换替换旧内容，旧内容（标签元素）依然存在<ul>
<li>设置后，再次打印获取dom或outerHTML还是原来的旧内容，但界面已经发生了更改</li>
</ul>
</li>
</ul>
<p>下面将div#app替换为新内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;as&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.outerHTML = &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用innerHTML内容是被删除然后使用新内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app)</span><br><span class="line">  app.innerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>而使用outerHTML是保留旧内容，页面中使用新内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app,app.outerHTML)</span><br><span class="line">  app.outerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(app,app.outerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="innerText与textContent"><a href="#innerText与textContent" class="headerlink" title="innerText与textContent"></a>innerText与textContent</h4><p>textContent与innerText是访问或添加文本内容到元素中</p>
<ul>
<li>textContent部分IE浏览器版本不支持</li>
<li>innerText部分FireFox浏览器版本不支持</li>
<li>获取时忽略所有标签,只获取文本内容</li>
<li>设置时将内容中的标签当文本对待不进行标签解析</li>
</ul>
<p>获取时忽略内容中的所有标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  console.log(app.textContent)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>设置内容时会将标签当普通文本对待，即转为HTML实体内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.textContent=&quot;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="outerText"><a href="#outerText" class="headerlink" title="outerText"></a>outerText</h4><p>与innerText差别是：outerText会所操作标签本身，innerText操作标签内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Ashuntefannao&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  h1.outerText = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  console.log(document.querySelector(&#x27;h1&#x27;)); //null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentText"><a href="#insertAdjacentText" class="headerlink" title="insertAdjacentText"></a>insertAdjacentText</h4><p><code>insertAdjacentText(position,str)</code></p>
<p>将文本插入到元素指定位置，不会对文本中的标签进行解析，包括以下位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>添加文本内容到div#app前面</p>
<ul>
<li>使用<code>insertAdjacentText</code>方法，只能追加普通文本，不会解析其中的HTML标签</li>
<li>若想要追加包含HTML标签的文本，并希望对其解析，可以使用后续章节<strong>节点管理</strong>中的<code>insertAdjacentHTML</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;hd&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.insertAdjacentText(&#x27;beforebegin&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)  //不会解析HTML标签</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><p>现在我们来讨论下节点元素的管理，包括添加、删除、替换等操作</p>
<h4 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>dom.append(elem/str)</code></td>
<td>节点内尾部添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.prepend(elem/str)</code></td>
<td>节点内开头添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.before(elem/str)</code></td>
<td>节点前面添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.after(elem/str)</code></td>
<td>节点后面添加新节点或字符串</td>
</tr>
<tr>
<td><code>dom.replaceWith(elem/str)</code></td>
<td>将节点替换为新节点或字符串</td>
</tr>
<tr>
<td><code>dom.remove()</code></td>
<td>删除节点</td>
</tr>
</tbody></table>
<p>在标签内容后面添加新内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.append(&#x27;-阿顺特烦恼&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>同时添加多个内容，包括字符串与元素标签</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.append(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.append(&#x27;@&#x27;, h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将标签替换为新内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.append(&#x27;阿顺特烦恼&#x27;)</span><br><span class="line">  app.replaceWith(h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>添加新元素h1到目标元素div#app里面</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  let h1 = document.createElement(&#x27;h1&#x27;)</span><br><span class="line">  h1.innerHTML = &#x27;阿顺特烦恼&#x27;</span><br><span class="line">  app.append(h1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将h2移动到h1之前</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Ashuntefannao&lt;/h2&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let h1 = document.querySelector(&#x27;h1&#x27;)</span><br><span class="line">  let h2 = document.querySelector(&#x27;h2&#x27;)</span><br><span class="line">  h1.before(h2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用remove方法可以删除节点</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  Ashuntefannao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.remove()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentHTML"><a href="#insertAdjacentHTML" class="headerlink" title="insertAdjacentHTML"></a>insertAdjacentHTML</h4><p><code>insertAdjacentHTML(position,str)</code></p>
<p>将html文本插入到元素指定位置，浏览器会对文本进行标签解析，包括以下位置</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>在div#app前添加HTML文本</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;astfn&quot; data=&quot;hd&quot;&gt;Ashuntefannao&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;shun&quot;&gt;SHUN&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.querySelector(&#x27;#app&#x27;)</span><br><span class="line">  app.insertAdjacentHTML(&#x27;beforebegin&#x27;, &#x27;&lt;h1&gt;阿顺特烦恼&lt;/h1&gt;&#x27;)  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="insertAdjacentElement"><a href="#insertAdjacentElement" class="headerlink" title="insertAdjacentElement"></a>insertAdjacentElement</h4><p><code>insertAdjacentElement(position,elem)</code></p>
<p>insertAdjacentElement() 方法将指定元素插入到元素的指定位置，包括以下位置</p>
<ul>
<li>第一个参数是位置</li>
<li>第二个参数为<strong>新元素节点</strong></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforebegin</td>
<td>元素本身前面</td>
</tr>
<tr>
<td>afterend</td>
<td>元素本身后面</td>
</tr>
<tr>
<td>afterbegin</td>
<td>元素内部前面</td>
</tr>
<tr>
<td>beforeend</td>
<td>元素内部后面</td>
</tr>
</tbody></table>
<p>在div#app 标签前插入span标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;astfn&quot;&gt;Ashuntefannao&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;shun&quot;&gt;SHUN&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app &#x3D; document.querySelector(&#39;#app&#39;)</span><br><span class="line">  let span &#x3D; document.createElement(&#39;span&#39;)</span><br><span class="line">  span.innerHTML &#x3D; &#39;阿顺特烦恼&#39;</span><br><span class="line">  app.insertAdjacentElement(&#39;beforebegin&#39;, span)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="古老方法"><a href="#古老方法" class="headerlink" title="古老方法"></a>古老方法</h4><p>下面列表过去使用的操作节点的方法，现在不建议使用了。但在阅读老代码时可来此查看语法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appendChild</td>
<td>添加节点</td>
</tr>
<tr>
<td>insertBefore</td>
<td>用于插入元素到另一个元素的前面</td>
</tr>
<tr>
<td>removeChild</td>
<td>删除节点</td>
</tr>
<tr>
<td>replaceChild</td>
<td>进行节点的替换操作</td>
</tr>
</tbody></table>
<h4 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h4><p>在了解DocumentFragment之前，我们先了解一下页面的呈现、回流、重绘的过程。</p>
<h5 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h5><p>页面呈现、重绘、回流。</p>
<h6 id="界面呈现"><a href="#界面呈现" class="headerlink" title="界面呈现"></a>界面呈现</h6><blockquote>
<p>获取html解析为Dom tree–&gt;获取css样式解析为样式结构体–&gt;Dom tree与样式结构体结合形成render tree</p>
</blockquote>
<ol>
<li><p>```<br>浏览器把获取到的html代码解析成1个Dom树，html中的每个tag都是Dom树中的1个节点，根节点就是我们常用的document对象(<html> tag)。dom树就是我们用开发者工具看到的html结构，里面包含了所有的html tag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;</span><br><span class="line">   浏览器把所有样式(主要包括css和浏览器的样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>dom tree和 样式结构体 结合后构建 呈现树(render tree)<br>render tree有点类似于dom tree，但其实区别有很大，render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，所以就不会包含到render tree中。<br>注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据css2的标准，render tree中的每个节点都称为box，box所有属性：width,height,margin,padding,left,top,border等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;</span><br><span class="line">   一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="界面回流"><a href="#界面回流" class="headerlink" title="界面回流"></a>界面回流</h6><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>影响布局的操作都会产生回流，发生回流(节点重新构建)一定会触发重绘。</p>
<h6 id="界面重绘"><a href="#界面重绘" class="headerlink" title="界面重绘"></a>界面重绘</h6><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
<p>界面重绘不一定存在界面回流。</p>
<hr>
<h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>当对节点进行添加、删除等操作时，都会引起页面回流来重新构建DOM渲染页面,</p>
<p><strong>解决以上问题可以使用以下几种方式</strong></p>
<ol>
<li>可以将DOM写成html字符串，然后使用innerHTML添加到页面中，但这种操作会比较麻烦，且不方便使用节点操作的相关方法。</li>
<li>使用createDocumentFragment来管理节点时，此时节点都在内存中，而不是DOM树中。对节点的操作不会引发页面回流,带来比较好的性能体验。</li>
</ol>
<p><strong>DocumentFragment特点</strong></p>
<ul>
<li>createDocumentFragment父节点为null</li>
<li>继承自node所以可以使用NODE的属性和方法</li>
<li>createDocumentFragment创建的是文档碎片，节点类型nodeType为11。因为不在DOM树中所以只能通过JS进行操作</li>
<li>添加createDocumentFragment添加到DOM后,就不可以再操作createDocumentFragment元素了,这与DOM操作是不同的</li>
<li>将文档DOM添加到createDocumentFragment时,会移除文档中的DOM元素</li>
<li>createDocumentFragment创建的节点添加到其他节点上时，会将子节点一并添加</li>
<li>createDocumentFragment是虚拟节点对象，不直接操作DOM所以性能更好</li>
<li>在排序/移动等大量DOM操作时建议使用createDocumentFragment</li>
</ul>
<h3 id="表单控制"><a href="#表单控制" class="headerlink" title="表单控制"></a>表单控制</h3><p>表单是高频操作的元素，下面来掌握表单项的DOM操作</p>
<h4 id="表单查找"><a href="#表单查找" class="headerlink" title="表单查找"></a>表单查找</h4><p>JS为表单的操作提供了单独的集合控制</p>
<ul>
<li>使用<code>document.forms</code>获取表单集合</li>
<li>使用<code>document.forms.formName</code>获取对应name属性的form表单</li>
<li>使用<code>form.elements.inputName\form.inputName</code>获取form中对应name属性的input表单元素</li>
<li>针对radio/checkbox获取的表单项是一个集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&quot; name&#x3D;&quot;from1&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;form1_input&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const form &#x3D; document.forms.form1</span><br><span class="line">  console.log(form.elements.form1_input)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>通过表单项可以反向查找FORM</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; name=&quot;form1&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;form1_input&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const form = document.forms.form1</span><br><span class="line">  console.log(form.form1_input.form === form) //true</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h3><p>通过DOM修改样式可以通过更改元素的class属性或通过style对象设置行样式来完成。</p>
<ul>
<li>建议使用class控制样式，将任务交给CSS处理，更简单高效</li>
</ul>
<h4 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置"></a>批量设置</h4><ul>
<li>使用<code>className</code>或<code>setAttribute</code>设置calss属性，<strong>会覆盖原来的类名</strong></li>
</ul>
<p>使用JS的className可以批量设置样式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.className = &#x27;astfn&#x27;</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过特征的方式来更改</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.setAttribute(&#x27;class&#x27;, &#x27;astfn&#x27;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h4><p>classList操作的是class属性列表，用于操作单个className，不会影响其它的className。如果对类单独进行控制使用 classList属性操作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>node.classList.add</td>
<td>添加类名</td>
</tr>
<tr>
<td>node.classList.remove</td>
<td>删除类名</td>
</tr>
<tr>
<td>node.classList.toggle</td>
<td>切换类名</td>
</tr>
<tr>
<td>node.classList.contains</td>
<td>类名检测</td>
</tr>
</tbody></table>
<p>在元素的原有class上添加新class</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.classList.add(&quot;ashun&quot;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用classList也可以移除class列表中的某个class</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  </span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">  app.classList.remove(&#x27;container&#x27;)</span><br><span class="line">  console.log(app.getAttribute(&quot;class&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用toggle切换类，即类已经存在时删除，不存在时添加</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    this.classList.toggle(&#x27;astfn&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用contains检查class是否存在</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  console.log(app.classList.contains(&#x27;container&#x27;)) //true</span><br><span class="line">  console.log(app.classList.contains(&#x27;as&#x27;)) //false</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="设置行样式"><a href="#设置行样式" class="headerlink" title="设置行样式"></a>设置行样式</h4><p>通过style对象可以对行内样式属性单独设置，使用cssText可以批量设置行内样式</p>
<blockquote>
<p>直接通过dom.prop能够访问/修改节点的对应属性,那么这个属性就是之前讲到的标准属性.</p>
<p>通过style能够直接访问/修改 节点的样式属性 , 即操作的都是行内样式.</p>
</blockquote>
<p><strong>样式属性设置</strong></p>
<p>使用节点的style对象来设置行样式</p>
<ul>
<li>多个单词的属性使用驼峰进行命名</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line">  app.style.color = &#x27;yellow&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>批量设置行样式</strong></p>
<p>使用 <code>cssText=&quot;...cssStr&quot;</code>属性可以批量设置行样式，<strong>属性名和写CSS一样不需要考虑驼峰命名</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.style.cssText = `background-color:red;color:yellow`</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>setAttribute</code>改变style特征来批量设置样式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; class=&quot;d-flex container&quot;&gt;阿顺特烦恼&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let app = document.getElementById(&#x27;app&#x27;)</span><br><span class="line">  app.setAttribute(&#x27;style&#x27;, `background-color:red;color:yellow;`)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h4><ul>
<li>可通过<code>dom.style.prop</code>或<code>getAttribute</code>获取行内样式</li>
<li>可通过<code>window.getComputedStyle(dom).prop</code>对象获取样式属性，下面进行说明</li>
</ul>
<p><code>style</code>和<code>getAttribute</code>只能获取行样式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">    background-color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id=&quot;app&quot;&gt;阿顺特烦恼&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app = document.getElementById(&quot;app&quot;);</span><br><span class="line"></span><br><span class="line">      function getLineStyle(dom) &#123;</span><br><span class="line">        console.log(`getAttribute---$&#123;dom.getAttribute(&quot;style&quot;)&#125;`);</span><br><span class="line">        console.log(`dom.stype.prop---$&#123;dom.style.backgroundColor&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">        getLineStyle(app);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          app.style.backgroundColor = &quot;yellowgreen&quot;;</span><br><span class="line">          getLineStyle(app);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><strong>getComputedStyle</strong></p>
<p>使用window.getComputedStyle可获取所有应用在元素上的样式属性</p>
<ul>
<li>函数第一个参数为元素</li>
<li>第二个参数为伪类</li>
<li>获取计算后的样式属性，是所有样式复合的结果 , 所以取得的单位和定义时的可能会有不同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">    background-color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app &#x3D; document.getElementById(&quot;app&quot;);</span><br><span class="line">      app.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(window.getComputedStyle(app).backgroundColor);</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          app.style.backgroundColor &#x3D; &quot;yellowgreen&quot;;</span><br><span class="line">          console.log(window.getComputedStyle(app).backgroundColor);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">      &#125;);</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>window.getComputedStyle获取的是计算后的样式属性 , 是所有样式复合的结果</p>
<ul>
<li>由于行内样式优先级别高 , 所以打印的是蓝色对应的rgb值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div &#123;</span><br><span class="line">	background-color: black;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;&lt;div id&#x3D;&quot;app&quot; style&#x3D;&quot;background-color: blue&quot;&gt;阿顺特烦恼&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      let app &#x3D; document.getElementById(&quot;app&quot;);</span><br><span class="line">      console.log(window.getComputedStyle(app).backgroundColor);  &#x2F;&#x2F;rgb(0,0,255)</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
  <entry>
    <title>类</title>
    <url>/2021/05/16/Web%E5%89%8D%E7%AB%AF/%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/JavaScript%E5%A4%A7%E6%80%BB%E7%BB%93/%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>为了和其他语言继承形态一致，JS提供了<code>class</code> 关键词用于模拟传统的<code>class</code> ，但底层实现机制依然是原型继承。</p>
<p><code>class</code> 只是语法糖为了让类的声明与继承更加简洁清晰。</p>
<h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>可以使用类声明和赋值表达式定义类，推荐使用类声明来定义类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//类声明</span><br><span class="line">class User &#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Article());</span><br><span class="line"></span><br><span class="line">//赋值表达式</span><br><span class="line">let Article = class &#123;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(new User());</span><br></pre></td></tr></table></figure>

<p>类方法间不需要逗号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  show() &#123;&#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&quot;get method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = new User();</span><br><span class="line">as.get();</span><br></pre></td></tr></table></figure>



<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>使用 <code>constructor</code> 构造函数传递参数，下例中<code>show</code>为构造函数方法，<code>getName</code>为原型方法。</p>
<ul>
<li><code>constructor</code> 会在 new 时自动执行</li>
<li>在<code>class</code>中<code>constructor</code>就相当于普通构造函数的<code>函数体</code>，当使用<code>new</code>进行时实例化时，就会执行构造函数，为实例分配属性。</li>
<li>在<code>constructor</code>中使用<code>this</code>声明的属性，会被分配到实例本身，在<code>constructor</code>外部定义的<code>方法</code>，相当于添加到<code>class</code>这个构造函数的原型<code>prototype</code>上。（class实际上就是一个函数）</li>
<li>但是在<code>constructor</code>外部定义的<code>属性</code>依旧会被分配到实例上</li>
<li>其实创建一个类的过程，其实就是设置该类的原型对象<code>prototype</code>，默认有<code>constructor</code>属性，还可以在原型上压入其它的属性、方法。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.show = function() &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = new User(&quot;阿顺&quot;);</span><br><span class="line">console.log(as);</span><br><span class="line">console.log(User.prototype);</span><br><span class="line">console.log(as.hasOwnProperty(&quot;getName&quot;));</span><br><span class="line">console.log(as.hasOwnProperty(&quot;name&quot;));</span><br></pre></td></tr></table></figure>

<p>构造函数用于传递对象的初始参数，但不是必须定义的，如果不设置系统会设置如下类型</p>
<ul>
<li>**子构造器中调用完<code>super</code> 后才可以使用 <code>this</code>**。</li>
<li>至于 <code>super</code> 的概念会在后面讲到，（执行父类中的constructor）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(...args) &#123;</span><br><span class="line">  super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>之前也提到过，**<code>class</code>其实就是函数**</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof User); //function</span><br></pre></td></tr></table></figure>

<p>下面是与普通函数的对比，结构是完全一致的。</p>
<img src="类.assets/Class_1.png" alt="Class_1" style="zoom:80%;" />

<ul>
<li><code>constructor</code> 用于定义函构造数体代码</li>
<li><code>constructor </code> 外部定义的<code>方法</code>，会追加到该 类(构造函数) 的原型上。</li>
<li><code>constructor </code> 外部定义的<code>属性</code>，依然会分配到实例上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name &#x3D; &quot;name&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	getName() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;普通构造函数</span><br><span class="line">function Ashun(name) &#123;</span><br><span class="line">	this.name &#x3D; &quot;name&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Ashun.prototype.getName &#x3D; function () &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.dir(User);</span><br><span class="line">console.dir(Ashun);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><p>在calss类中，无论是在<code>constructor </code> 内、外部定义的<code>属性</code>，<strong>都会分配到实例上</strong>。</p>
<ul>
<li><code>constructor </code> 内部定义的<code>属性</code>，使用this声明</li>
<li><code>constructor </code> 外部定义的<code>属性</code>，<strong>不使用</strong>关键字声明。</li>
</ul>
<p>在class类中，在<code>constructor </code> 外部定义的<code>方法</code>，会自动添加到该类的原型上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	site &#x3D; &#96;Ashuntefannao.com&#96;; &#x2F;&#x2F;在constructor外部定义的属性，依然会被分配到实例上</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	show() &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(User.prototype.site);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(User.prototype.show);</span><br><span class="line">let as &#x3D; new User(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.name, as.site);&#x2F;&#x2F;阿顺	Ashuntefannao.com</span><br><span class="line">console.table(as);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="函数差异"><a href="#函数差异" class="headerlink" title="函数差异"></a>函数差异</h4><p>虽然class是函数的语法糖，但是与普通构造函数在使用方面还是有一些区别的，这都是为了更加规范的管理原型。</p>
<ul>
<li>在class中定义的方法即(原型上的方法)，自动设置为不可枚举。</li>
</ul>
<p>我们知道，普通构造函数实例化的对象，通过<code>for/in</code>遍历属性，会访问原型上的属性。但这样可能会在遍历操作过程中，影响原型的属性或方法。所以class自动为原型上的方法设置属性特征<code>enumerable:false</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        class User &#123;</span><br><span class="line">          site &#x3D; &#96;Ashuntefannao.com&#96;;</span><br><span class="line">          constructor(name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">          &#125;</span><br><span class="line">          show() &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let as &#x3D; new User(&quot;阿顺&quot;);</span><br><span class="line">        for (let key in as) &#123;</span><br><span class="line">          console.log(key);		&#x2F;&#x2F;site name</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比普通构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function User(name) &#123;</span><br><span class="line">          this.site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">          this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        User.prototype.show &#x3D; function () &#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">        let as &#x3D; new User(&quot;阿顺&quot;);</span><br><span class="line">        for (let key in as) &#123;</span><br><span class="line">          console.log(key);  &#x2F;&#x2F;site name show</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p><code>class</code> 默认使用<code>use strict</code> 严格模式执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        class User &#123;</span><br><span class="line">          site = `Ashuntefannao.com`;</span><br><span class="line">          constructor(name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">          show() &#123;</span><br><span class="line">            !(function () &#123;</span><br><span class="line">              console.log(this); //默认严格模式，打印undefined</span><br><span class="line">            &#125;)();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let as = new User(&quot;阿顺&quot;);</span><br><span class="line">        as.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比普通构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        function User(name) &#123;</span><br><span class="line">          this.site &#x3D; &quot;Ashuntefannao.com&quot;;</span><br><span class="line">          this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        User.prototype.show &#x3D; function () &#123;</span><br><span class="line">          !(function () &#123;</span><br><span class="line">            console.log(this); &#x2F;&#x2F;非严格模式，this&#x3D;》window</span><br><span class="line">          &#125;)();</span><br><span class="line">        &#125;;</span><br><span class="line">        let as &#x3D; new User(&quot;阿顺&quot;);</span><br><span class="line">        as.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="静态访问"><a href="#静态访问" class="headerlink" title="静态访问"></a>静态访问</h3><p>​    静态属性、方法：意为只能够被 该类本身 访问的属性和方法，使用类名来调用。</p>
<ul>
<li>在class中使用<code>static</code>关键字进行声明</li>
<li>在普通构造函数中，向构造函数本身压入对应的属性和方法。(构造函数本身也是对象)</li>
</ul>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>静态属性即为类设置属性，而不是为实例对象设置，下面是原理实现</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.site = &quot;阿顺特烦恼&quot;;</span><br><span class="line">console.dir(User);</span><br><span class="line"></span><br><span class="line">const as = new User();</span><br><span class="line">console.log(as.site); //undefiend</span><br><span class="line">console.log(User.site); //阿顺特烦恼 </span><br></pre></td></tr></table></figure>

<p>在 <code>class</code> 中为属性添加 <code>static</code> 关键字即声明为静态属性</p>
<ul>
<li>可以把所有实例对象都要使用的值 定义为静态属性</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Request &#123;</span><br><span class="line">  static HOST = &quot;https://www.Ashuntefannao.com&quot;;</span><br><span class="line">  </span><br><span class="line">  query(api) &#123;</span><br><span class="line">    return Request.HOST + &quot;/&quot; + api;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let request = new Request();</span><br></pre></td></tr></table></figure>



<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>指通过类访问不能使用对象访问的方法，比如系统的<code>Math.round()</code>就是静态方法</p>
<ul>
<li>一般来讲方法不需要对象属性参与计算就可以定义为静态方法</li>
</ul>
<p>下面是静态方法实现原理，向构造函数本身压入方法。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;</span><br><span class="line">  this.show = function() &#123;</span><br><span class="line">    return &quot;this is a object function&quot;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">User.show = function() &#123;</span><br><span class="line">  return &quot;welcome to Ashuntefannao&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">const as = new User();</span><br><span class="line">console.dir(as.show()); //this is a object function</span><br><span class="line">console.dir(User.show()); //welcome to Ashuntefannao</span><br></pre></td></tr></table></figure>

<p>在 <code>class</code> 内声明的方法前使用 <code>static</code> 定义的方法即是静态方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  static create(name) &#123;</span><br><span class="line">    return new User(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = User.create(&quot;阿顺&quot;);</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>下面使用静态方法在课程类中的使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const data = [</span><br><span class="line">  &#123; name: &quot;js&quot;, price: 100 &#125;,</span><br><span class="line">  &#123; name: &quot;mysql&quot;, price: 212 &#125;,</span><br><span class="line">  &#123; name: &quot;React&quot;, price: 98 &#125;</span><br><span class="line">];</span><br><span class="line">class Lesson &#123;</span><br><span class="line">  constructor(data) &#123;</span><br><span class="line">    this.model = data;</span><br><span class="line">  &#125;</span><br><span class="line">  get price() &#123;</span><br><span class="line">    return this.model.price;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this.model.name;</span><br><span class="line">  &#125;</span><br><span class="line">  //批量生成对象</span><br><span class="line">  static createBatch(data) &#123;</span><br><span class="line">    return data.map(item =&gt; new Lesson(item));</span><br><span class="line">  &#125;</span><br><span class="line">  //最贵的课程</span><br><span class="line">  static MaxPrice(collection) &#123;</span><br><span class="line">    return collection.reduce((pre, v) =&gt; (pre.price &gt; v.price ? pre : v));</span><br><span class="line">    //  return collection.sort((a, b) =&gt; b.price - a.price)[0];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const lessons = Lesson.createBatch(data);</span><br><span class="line">console.log(lessons);</span><br><span class="line">console.log(Lesson.MaxPrice(lessons).name);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>使用访问器可以对对象的属性进行访问控制，下面是使用访问器对私有属性进行管理。</p>
<h4 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h4><ul>
<li>使用访问器可以管控属性，有效的防止属性随意修改</li>
<li>访问器就是在函数前加上 <code>get/set</code>修饰，操作属性时不需要加函数的扩号，直接用函数名</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.data = &#123; name &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this.data.name;</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    if (value.trim() == &quot;&quot;) throw new Error(&quot;invalid params&quot;);</span><br><span class="line">    this.data.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺&quot;);</span><br><span class="line">as.name = &quot;Ashun&quot;;</span><br><span class="line">console.log(as.name);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>设置对象的私有属性有多种方式，包括后面章节介绍的模块封装。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p><code>public</code> 指不受保护的属性，在类的内部与外部都可以访问到</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  url = &quot;Ashuntefannao.com&quot;;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.name, as.url);</span><br></pre></td></tr></table></figure>

<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>protected是受保护的属性修释，不允许外部直接操作，只能在<code>该类</code>及其<code>子类(继承类)</code>中访问的属性</p>
<h5 id="命名保护"><a href="#命名保护" class="headerlink" title="命名保护"></a>命名保护</h5><p>将属性定义为以 <code>_</code> 开始，来告诉使用者这是一个私有属性，请不要在外部使用。</p>
<ul>
<li>外部修改、访问protected属性时可以使用访问器 <code>setter/getter</code> 操作</li>
<li>但这只是提示，就像吸烟时烟盒上的吸烟有害健康，但还是可以抽的</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Article &#123;</span><br><span class="line">  _host = &quot;https://Ashuntefannao.com&quot;;</span><br><span class="line"></span><br><span class="line">  set host(url) &#123;</span><br><span class="line">    if (!/^https:\/\//i.test(url)) &#123;</span><br><span class="line">      throw new Error(&quot;网址错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this._host = url;</span><br><span class="line">  &#125;</span><br><span class="line">  get host()&#123;</span><br><span class="line">  	return this._host</span><br><span class="line">  &#125;</span><br><span class="line">  lists() &#123;</span><br><span class="line">    return `$&#123;this._host&#125;/article`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let article = new Article();</span><br><span class="line">console.log(article.lists()); //https://Ashuntefannao.com/article</span><br><span class="line">article.host = &quot;https://ASHUN.com&quot;;</span><br><span class="line">console.log(article.lists()); //https://ASHUN.com/article</span><br><span class="line">console.log(article._host);		//实际上是能够被实例访问的，因为_host属性被分配到了实例上</span><br></pre></td></tr></table></figure>

<p>继承时是可以使用的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Common &#123;</span><br><span class="line">  _host = &quot;https://Ashuntefannao.com&quot;;</span><br><span class="line">  set host(url) &#123;</span><br><span class="line">    if (!/^https:\/\//i.test(url)) &#123;</span><br><span class="line">      throw new Error(&quot;网址错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this._host = url;</span><br><span class="line">  &#125;</span><br><span class="line">   get host()&#123;</span><br><span class="line">  	return this._host</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Article extends Common &#123;</span><br><span class="line">  lists() &#123;</span><br><span class="line">    return `$&#123;this._host&#125;/article`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let article = new Article();</span><br><span class="line">console.log(article.lists()); //https://Ashuntefannao.com/article</span><br><span class="line">article.host = &quot;https://ASHUN.com&quot;;</span><br><span class="line">console.log(article.lists()); //https://ASHUN.com/article</span><br></pre></td></tr></table></figure>

<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>下面使用 <code>Symbol</code>定义protected属性，即在外部通过查看对象结构无法获取的属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const protecteds = Symbol();</span><br><span class="line">class Common &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this[protecteds] = &#123;&#125;;</span><br><span class="line">    this[protecteds].host = &quot;https://Ashuntefannao.com&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  set host(url) &#123;</span><br><span class="line">    if (!/^https?:/i.test(url)) &#123;</span><br><span class="line">      throw new Error(&quot;非常网址&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this[protecteds].host = url;</span><br><span class="line">  &#125;</span><br><span class="line">  get host() &#123;</span><br><span class="line">    return this[protecteds].host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User extends Common &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super();//调用父类的constructor</span><br><span class="line">    this[protecteds].name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this[protecteds].name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺&quot;);</span><br><span class="line">as.host = &quot;https://www.ASHUN.com&quot;;</span><br><span class="line">// console.log(as[Symbol()]);</span><br><span class="line">console.log(as.name);</span><br></pre></td></tr></table></figure>

<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p><strong>WeakMap</strong> 是一组键/值对的集，下面利用<code>WeakMap</code>类型特性定义protected属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const _host = new WeakMap();</span><br><span class="line">class Common &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    _host.set(this, &quot;https://Ashuntefannao.com&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  set host(url) &#123;</span><br><span class="line">    if (!/^https:\/\//i.test(url)) &#123;</span><br><span class="line">      throw new Error(&quot;网址错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    _host.set(this, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Article extends Common &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  lists() &#123;</span><br><span class="line">    return `$&#123;_host.get(this)&#125;/article`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let article = new Article();</span><br><span class="line">console.log(article.lists()); //https://Ashuntefannao.com/article</span><br><span class="line">article.host = &quot;https://SHUN.com&quot;;</span><br><span class="line">console.log(article.lists()); //https://SHUN.com/article</span><br></pre></td></tr></table></figure>

<p>也可以统一定义私有属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const protecteds = new WeakMap();</span><br><span class="line">class Common &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    protecteds.set(this, &#123;</span><br><span class="line">      host: &quot;https://Ashuntefannao&quot;,</span><br><span class="line">      port: &quot;80&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  set host(preset) &#123;</span><br><span class="line">    if (!/^https:\/\//i.test(preset.host)) &#123;</span><br><span class="line">      throw new Error(&quot;网址错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protecteds.set(this, &#123; ...protecteds.get(this), ...preset &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Article extends Common &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  lists() &#123;</span><br><span class="line">    return `$&#123;protecteds.get(this).host&#125;:$&#123;protecteds.get(this).port&#125;/article`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let article = new Article();</span><br><span class="line">console.log(article.lists()); //https://Ashuntefannao:80/article</span><br><span class="line">article.host = &#123; host: &quot;https://SHUN&quot;, port: 8083 &#125;;</span><br><span class="line">console.log(article.lists()); //https://SHUN:8083/article</span><br></pre></td></tr></table></figure>



<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p><code>private</code> 指私有属性，只在当前类可以访问到，并且不允许继承使用</p>
<ul>
<li>为属性或方法名前加 <code>#</code> 为声明为私有属性</li>
<li>私有属性<code>只能</code>在声明的类中使用</li>
</ul>
<p>下面声明私有属性 <code>#host</code> 与私有方法 <code>#check</code> 用于检测用户名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  //private</span><br><span class="line">  #host = &quot;https://Ashuntefannao.com&quot;;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name ;</span><br><span class="line">    this.#check(name);</span><br><span class="line">  &#125;</span><br><span class="line">  set host(url) &#123;</span><br><span class="line">    if (!/^https?:/i.test(url)) &#123;</span><br><span class="line">      throw new Error(&quot;非常网址&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.#host = url;</span><br><span class="line">  &#125;</span><br><span class="line">  get host() &#123;</span><br><span class="line">    return this.#host;</span><br><span class="line">  &#125;</span><br><span class="line">  #check = () =&gt; &#123;</span><br><span class="line">    if (this.name.length &lt; 5) &#123;</span><br><span class="line">      throw new Error(&quot;用户名长度不能小于五位&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let as = new User(&quot;阿顺特烦恼&quot;);</span><br><span class="line">as.host = &quot;https://www.SHUN.com&quot;;</span><br><span class="line">console.log(as[&quot;#host&quot;]);//实例中不能访问类的私有属性</span><br><span class="line">console.log(as.host);	//可以通过getter间接访问</span><br></pre></td></tr></table></figure>

<p>对比普通构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">	let privateProp &#x3D; &#123; name &#125;;</span><br><span class="line">	Object.defineProperty(this, &quot;name&quot;, &#123;</span><br><span class="line">			get() &#123;</span><br><span class="line">				return privateProp.name;</span><br><span class="line">			&#125;,</span><br><span class="line">			set(newVal) &#123;</span><br><span class="line">				privateProp.name &#x3D; newVal;</span><br><span class="line">			&#125;,</span><br><span class="line">	&#125;);     </span><br><span class="line">&#125;</span><br><span class="line">let as &#x3D; new User(&quot;Ashun&quot;);</span><br><span class="line">console.log(as.name);</span><br><span class="line">console.log(as.privateProp);	&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="详解继承"><a href="#详解继承" class="headerlink" title="详解继承"></a>详解继承</h3><h4 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h4><p>class实现属性继承的原型如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function Admin(name) &#123;</span><br><span class="line">  User.call(this, name); </span><br><span class="line">&#125;</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>

<p>这就解释了为什么在子类构造函数中要先执行<code>super</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="继承原理"><a href="#继承原理" class="headerlink" title="继承原理"></a>继承原理</h4><p><code>class</code> 使用<code>extends</code>关键字实现原型继承。</p>
<img src="类.assets/Class_2.png" alt="Class_2" style="zoom:70%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;user.show&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  info() &#123;</span><br><span class="line">    this.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as &#x3D; new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.dir(as);</span><br><span class="line">as.info();</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h4><p>原生的继承主要是操作原型链，实现起来比较麻烦，使用 <code>class</code> 就要简单的多了。</p>
<ul>
<li>在子类中使用父类同名方法，需要使用<code>super</code>关键字访问父类的方法，当然，如果子类中没有与父类的同名方法，则直接使用<code>this</code>即可，该类没有使用的方法，会到原型上去查找，但是为了更加准确地调用父类方法，推荐使用<code>super</code></li>
<li>super.show() 执行父类的show方法</li>
</ul>
<p>下面是在子类中使用父类的方法<code>show</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    return `阿顺特烦恼会员: $&#123;this.name&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User extends Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    return &quot;is User show&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    // return this.show();</span><br><span class="line">    return super.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = new User(&quot;ASHUN&quot;);</span><br><span class="line">console.log(as.run());</span><br></pre></td></tr></table></figure>

<p>class中的<code>extends</code>关键字后面可以跟表达式，也就是说可以使用 <code>extends</code> 继承表达式返回的类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function controller() &#123;</span><br><span class="line">  return class &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      console.log(&quot;user.show&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends controller() &#123;</span><br><span class="line">  info() &#123;</span><br><span class="line">    this.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new Admin();</span><br><span class="line">as.show()</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>表示从当前原型中查找方法，</p>
<ul>
<li>super 一直指向当前对象</li>
<li>super只能在<code>类</code>或<code>对象方法</code>中使用，不能在 独立存在的函数 中使用</li>
</ul>
<p>下面是使用 <code>this</code> 模拟<code>super</code>，会有以下问题</p>
<ul>
<li><code>this</code>指向调用该方法的对象，结果并不是 <code>admin</code>的<code>name</code>值</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.__proto__.show();	//this=&gt;user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(admin.show()); //user</span><br></pre></td></tr></table></figure>

<p>为了解决以上问题，需要调用父类方法时改变<code>this</code>指向</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.__proto__.show.call(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(admin.show());//admin</span><br></pre></td></tr></table></figure>

<p>上面看似结果正常，但如果是多层继承时，会出现新的问题</p>
<ul>
<li>我们期望使用<code>common.show</code>，但因为始终传递的是当前对象<code>this</code> ，造成从 <code>this</code> 原型循环调用</li>
<li><code>admin.get</code>调用父级原型上的show，并绑定了admin的this，所以当执行user.show()时，this为admin，又会导致admin调用user.show()，周而复始，产生循环调用。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let common = &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;common.init&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let user = &#123;</span><br><span class="line">  __proto__: common,</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.__proto__.show.call(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  get() &#123;</span><br><span class="line">    return this.__proto__.show.call(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(admin.get());</span><br></pre></td></tr></table></figure>

<p>为了解决以上问题 <code>js</code> 提供了 <code>super</code> 关键字</p>
<ul>
<li>使用 <code>super</code> 调用时，在所有继承中 <code>this</code> 始终为调用对象</li>
<li><code>super</code> 是用来查找当前对象的原型，而不像上面使用 <code>this</code> 查找原型造成死循环</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let common = &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let user = &#123;</span><br><span class="line">  __proto__: common,</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return super.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  get() &#123;</span><br><span class="line">    return super.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(admin.get());</span><br></pre></td></tr></table></figure>

<p>虽然使用<code>super</code>调用父级方法，但<code>this指向当前对象</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let common &#x3D; &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(&quot;common.init&quot;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let user &#x3D; &#123;</span><br><span class="line">  __proto__: common,</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return super.show();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let admin &#x3D; &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  get() &#123;</span><br><span class="line">    return super.show(); &#x2F;&#x2F;虽然使用super调用父级方法，但this指向当前对象</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">admin.get();	&#x2F;&#x2F;common.init admin</span><br></pre></td></tr></table></figure>

<p><code>super</code> <strong>只能在</strong><code>类</code>或<code>对象的方法</code>中使用，而不能在独立存在的函数中使用，下面将产生错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  show() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  name: &quot;admin&quot;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return super.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(admin.get()); //Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p><code>super</code> 指向父类引用，在构造函数<code>constructor</code> 中必须先调用<code>super()</code>，因为这样才能够继承父级原型的属性、方法。</p>
<ul>
<li><code>super()</code> 调用父类的构造函数<code>constructor()</code></li>
<li>必须在 <code>constructor</code> 函数里的<code>this</code> 使用前执行 <code>super()</code></li>
<li>若不手动配置<code>super()</code>,系统会默认执行</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">as.show();</span><br></pre></td></tr></table></figure>

<p><code>constructor</code> 中先调用 <code>super</code> 方法的原理如下</p>
<ul>
<li>利用父级构造函数，初始化实例属性</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Parent(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function User(...args) &#123;</span><br><span class="line">  Parent.apply(this, args);</span><br><span class="line">&#125;</span><br><span class="line">User.prototype = Object.create(User.prototype)</span><br><span class="line">User.prototype.constructor = User;</span><br><span class="line">const as = new User(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.name);</span><br></pre></td></tr></table></figure>

<p>若不手动配置<code>super(...args)</code>,系统会默认执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(this.name, this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(..args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let as &#x3D; new Admin(&quot;阿顺&quot;,18);</span><br><span class="line">as.show();</span><br></pre></td></tr></table></figure>

<p>与下方代码结果相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    console.log(this.name, this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;&#125;</span><br><span class="line">let as &#x3D; new Admin(&quot;阿顺&quot;,18);</span><br><span class="line">as.show();</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="父类方法"><a href="#父类方法" class="headerlink" title="父类方法"></a>父类方法</h4><p>之前已经提到过，使用<code>super</code>指向父级原型引用，所以可以通过<code>super</code>调用父级原型的方法，并且this指向当前对象。</p>
<ul>
<li>不添加方法名是执调用父类构造函数<code>constructor</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.getName());</span><br></pre></td></tr></table></figure>

<p>下面是通过父类方法获取课程总价</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Controller &#123;</span><br><span class="line">  sum() &#123;</span><br><span class="line">    return this.data.reduce((t, c) =&gt; t + c.price, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Lesson extends Controller &#123;</span><br><span class="line">  constructor(lessons) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.data = lessons;</span><br><span class="line">  &#125;</span><br><span class="line">  info() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      totalPrice: super.sum(),</span><br><span class="line">      data: this.data</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let data = [</span><br><span class="line">  &#123; name: &quot;js&quot;, price: 100 &#125;,</span><br><span class="line">  &#123; name: &quot;mysql&quot;, price: 212 &#125;,</span><br><span class="line">  &#123; name: &quot;vue.js&quot;, price: 98 &#125;</span><br><span class="line">];</span><br><span class="line">const as = new Lesson(data);</span><br><span class="line">console.table(as.info());</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h4><p>即在子类中设置与父类同名的方法，这样就会优先调用子类自身的方法，子类自身没有，才会攀爬原型进行查找。</p>
<p>子类存在父类同名方法时使用子类方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;</span><br><span class="line">  say() &#123;</span><br><span class="line">    return &quot;阿顺特烦恼：&quot; + super.say();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const as = new Admin(&quot;阿顺&quot;);</span><br><span class="line">console.log(as.say());</span><br></pre></td></tr></table></figure>

<p>下面是覆盖父类方法，只获取课程名称</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Controller &#123;</span><br><span class="line">  say() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  total() &#123;</span><br><span class="line">    return this.data.reduce((t, c) =&gt; t + c.price, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  getByKey(key) &#123;</span><br><span class="line">    return this.data.filter(item =&gt; item.name.includes(key));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lesson extends Controller &#123;</span><br><span class="line">  constructor(lessons) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.data = lessons;</span><br><span class="line">  &#125;</span><br><span class="line">  getByKey(key) &#123;</span><br><span class="line">    return super.getByKey(key).map(item =&gt; item.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let data = [</span><br><span class="line">  &#123; name: &quot;js&quot;, price: 100 &#125;,</span><br><span class="line">  &#123; name: &quot;mysql&quot;, price: 212 &#125;,</span><br><span class="line">  &#123; name: &quot;vue.js&quot;, price: 98 &#125;</span><br><span class="line">];</span><br><span class="line">const hd = new Lesson(data);</span><br><span class="line">console.log(hd.getByKey(&quot;js&quot;));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="静态继承"><a href="#静态继承" class="headerlink" title="静态继承"></a>静态继承</h4><p>静态的属性和方法也是可以被继承使用的，下面是原理分析</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">User.site = &quot;阿顺特烦恼&quot;;</span><br><span class="line">User.url = function() &#123;</span><br><span class="line">  return &quot;Ashuntefannao.com&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line">Admin.__proto__ = User;</span><br><span class="line">console.dir(Admin);</span><br><span class="line">console.log(Admin.url());</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>class</code> 来演示静态继承</p>
<ul>
<li><code>extends</code>也会继承<strong>静态</strong>属性、方法</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  static site = &quot;阿顺特烦恼&quot;;</span><br><span class="line">  static host() &#123;</span><br><span class="line">    return &quot;Ashuntefannao.com&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">  	console.log(User.site, User.host());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Admin extends User &#123;&#125;</span><br><span class="line">console.log(Admin.site);</span><br><span class="line">let as = new Admin();</span><br><span class="line">as.show();</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原型检测"><a href="#原型检测" class="headerlink" title="原型检测"></a>原型检测</h4><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>使用 <code>instanceof</code> 用于检测 构造函数的<code>prototype</code>是否在某个实例的原型链上，下面是在原型中的分析（已经在原型与继承中讲过）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function User() &#123;&#125;</span><br><span class="line">function Admin() &#123;&#125;</span><br><span class="line">Admin.prototype = Object.create(User.prototype);</span><br><span class="line">let as = new Admin();</span><br><span class="line">console.log(as instanceof Admin); //true</span><br><span class="line">console.log(as instanceof User); //true</span><br><span class="line"></span><br><span class="line">console.log(as.__proto__ == Admin.prototype);</span><br><span class="line">console.log(as.__proto__.__proto__ == User.prototype);</span><br></pre></td></tr></table></figure>

<p>下面是递归检测原型的代码，帮助分析 <code>instanceof</code> 的原理</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function checkPrototype(obj, constructor) &#123;</span><br><span class="line">  if (!obj.__proto__) return false;</span><br><span class="line">  if (obj.__proto__ == constructor.prototype) return true;</span><br><span class="line">  return checkPrototype(obj.__proto__, constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class</code> 内部实现就是基于原型，所以使用<code>instanceof</code> 判断和上面原型是一样的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;&#125;</span><br><span class="line">class Admin extends User &#123;&#125;</span><br><span class="line">let as = new Admin();</span><br><span class="line">console.log(as instanceof Admin);</span><br><span class="line">console.log(as instanceof User);</span><br></pre></td></tr></table></figure>

<h5 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h5><p>使用 <code>isPrototypeOf</code> 判断一个对象是否在另一个对象的原型链中，下面是原理分析</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const a = &#123;&#125;;</span><br><span class="line">const b = &#123;</span><br><span class="line">  __proto__: a</span><br><span class="line">&#125;;</span><br><span class="line">const c = &#123;</span><br><span class="line">  __proto__: b</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a.isPrototypeOf(b)); //true</span><br><span class="line">console.log(a.isPrototypeOf(c)); //true</span><br></pre></td></tr></table></figure>

<p>下面在使用 <code>class</code> 语法中使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class User &#123;&#125;</span><br><span class="line">class Admin extends User &#123;&#125;</span><br><span class="line">let as = new Admin();</span><br><span class="line">console.log(Admin.prototype.isPrototypeOf(as));</span><br><span class="line">console.log(User.prototype.isPrototypeOf(as));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="继承内置类"><a href="#继承内置类" class="headerlink" title="继承内置类"></a>继承内置类</h4><p>使用原型扩展内置类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function Arr(...args) &#123;</span><br><span class="line">  args.forEach(item =&gt; this.push(item));</span><br><span class="line">  this.first = function() &#123;</span><br><span class="line">    return this[0];</span><br><span class="line">  &#125;;</span><br><span class="line">  this.max = function() &#123;</span><br><span class="line">    return this.data.sort((a, b) =&gt; b - a)[0];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arr.prototype = Object.create(Array.prototype);</span><br><span class="line">let arr = new Arr(&quot;阿顺&quot;, &quot;123&quot;, 18);</span><br><span class="line">console.log(arr.first());</span><br><span class="line">console.log(arr.max())</span><br></pre></td></tr></table></figure>

<p>使用 <code>class</code>扩展内置类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Arr extends Array &#123;</span><br><span class="line">        constructor(...args) &#123;</span><br><span class="line">          super(...args);</span><br><span class="line">        &#125;</span><br><span class="line">        add(val) &#123;</span><br><span class="line">          this.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">        remove(val) &#123;</span><br><span class="line">          let index = this.findIndex((v) =&gt; v == val);</span><br><span class="line">          index &amp;&amp; this.splice(index, 1);</span><br><span class="line">          return index;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = new Arr(1, 2, 3);</span><br><span class="line">arr.push(&quot;ASHUNTEFANNAO&quot;);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(arr.remove(3));</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>关于<code>mixin</code> 的使用在原型章节已经讨论过，在<code>class</code> 使用也是相同的原理</p>
<p><code>JS</code>不能实现多继承，如果要使用多个类的方法时可以使用<code>mixin</code>混合模式来完成。</p>
<ul>
<li><code>mixin</code> 类是一个包含许多供其它类使用的方法的类</li>
<li><code>mixin</code> 类不用来继承做为其它类的父类</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const Tool = &#123;</span><br><span class="line">  max(key) &#123;</span><br><span class="line">    return this.data.sort((a, b) =&gt; b[key] - a[key])[0];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Lesson &#123;</span><br><span class="line">  constructor(lessons) &#123;</span><br><span class="line">    this.lessons = lessons;</span><br><span class="line">  &#125;</span><br><span class="line">  get data() &#123;</span><br><span class="line">    return this.lessons;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Lesson.prototype, Tool);</span><br><span class="line">const data = [</span><br><span class="line">  &#123; name: &quot;js&quot;, price: 100 &#125;,</span><br><span class="line">  &#123; name: &quot;mysql&quot;, price: 212 &#125;,</span><br><span class="line">  &#123; name: &quot;vue.js&quot;, price: 98 &#125;</span><br><span class="line">];</span><br><span class="line">let hd = new Lesson(data);</span><br><span class="line">console.log(hd.max(&quot;price&quot;));</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><img src="类.assets/Class_3.gif" alt="Class_3" style="zoom:70%;" />

<ul>
<li>类：Animation、Slide、Panel</li>
<li>Animation:动画效果的实现</li>
<li>Slide：处理事件绑定，通过Panel调用动画，实现逻辑</li>
<li>Panel：用于管理面板的伸缩</li>
<li>只有Panel extends Animation 在Slide中通过选择器遍历实例化panel。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0px;</span><br><span class="line">        padding: 0;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line">      main &#123;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        width: 80%;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      .slide &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      dl &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        height: 90%;</span><br><span class="line">      &#125;</span><br><span class="line">      section &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">      &#125;</span><br><span class="line">      section &gt; dt,</span><br><span class="line">      section &gt; dd &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        color: rgba(255, 255, 255, 0.8);</span><br><span class="line">      &#125;</span><br><span class="line">      section &gt; dt &#123;</span><br><span class="line">        min-height: 30px;</span><br><span class="line">        background-color: #16a085;</span><br><span class="line">      &#125;</span><br><span class="line">      section &gt; dd &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background-color: #f39c12;</span><br><span class="line">        font-size: 24px;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;slide&quot;&gt;</span><br><span class="line">        &lt;dl&gt;</span><br><span class="line">          &lt;section&gt;</span><br><span class="line">            &lt;dt&gt;Ashun&lt;&#x2F;dt&gt;</span><br><span class="line">            &lt;dd&gt;Ashun&lt;&#x2F;dd&gt;</span><br><span class="line">          &lt;&#x2F;section&gt;</span><br><span class="line">          &lt;section&gt;</span><br><span class="line">            &lt;dt&gt;阿顺&lt;&#x2F;dt&gt;</span><br><span class="line">            &lt;dd&gt;阿顺&lt;&#x2F;dd&gt;</span><br><span class="line">          &lt;&#x2F;section&gt;</span><br><span class="line">          &lt;section&gt;</span><br><span class="line">            &lt;dt&gt;ashun&lt;&#x2F;dt&gt;</span><br><span class="line">            &lt;dd&gt;ashun&lt;&#x2F;dd&gt;</span><br><span class="line">          &lt;&#x2F;section&gt;</span><br><span class="line">        &lt;&#x2F;dl&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;main&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> class Animation &#123;</span><br><span class="line">        constructor(el) &#123;</span><br><span class="line">          this.el &#x3D; el;</span><br><span class="line">          this.timeOut &#x3D; 6;</span><br><span class="line">          this.step &#x3D; 3;</span><br><span class="line">          this.isShow &#x3D; false;</span><br><span class="line">          this.defaultHeight &#x3D; this.height;</span><br><span class="line">          this.timer &#x3D; undefined;</span><br><span class="line">        &#125;</span><br><span class="line">        get height() &#123;</span><br><span class="line">          return parseFloat(window.getComputedStyle(this.el).height);</span><br><span class="line">        &#125;</span><br><span class="line">        set height(num) &#123;</span><br><span class="line">          this.el.style.height &#x3D; num + &quot;px&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        show(callback) &#123;</span><br><span class="line">          this.isShow &#x3D; true;</span><br><span class="line">          clearInterval(this.timer);</span><br><span class="line">          this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            if (this.height &gt;&#x3D; this.defaultHeight) &#123;</span><br><span class="line">              clearInterval(this.timer);</span><br><span class="line">              callback &amp;&amp; callback(this);</span><br><span class="line">              return;</span><br><span class="line">            &#125;</span><br><span class="line">            this.height &#x3D; this.height + this.step &gt;&#x3D; this.defaultHeight</span><br><span class="line">                ? this.defaultHeight</span><br><span class="line">                : this.height + this.step;</span><br><span class="line">          &#125;, this.timeOuttimeOut);</span><br><span class="line">        &#125;</span><br><span class="line">        hide(callback) &#123;</span><br><span class="line">          this.isShow &#x3D; false;</span><br><span class="line">          clearInterval(this.timer);</span><br><span class="line">          this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            if (this.height &lt;&#x3D; 0) &#123;</span><br><span class="line">              clearInterval(this.timer);</span><br><span class="line">              callback &amp;&amp; callback(this);</span><br><span class="line">              return;</span><br><span class="line">            &#125;</span><br><span class="line">            this.height &#x3D; this.height - this.step &lt; 0 ? 0 : this.height - this.step;</span><br><span class="line">          &#125;, this.timeOuttimeOut);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      class Slide &#123;</span><br><span class="line">        constructor(el) &#123;</span><br><span class="line">          this.el &#x3D; document.querySelector(el);</span><br><span class="line">          this.links &#x3D; this.el.querySelectorAll(&quot;dt&quot;);</span><br><span class="line">          this.panels &#x3D; [...this.el.querySelectorAll(&quot;dd&quot;)].map(</span><br><span class="line">            (v) &#x3D;&gt; new Panel(v)</span><br><span class="line">          );</span><br><span class="line">          this.init();</span><br><span class="line">          this.buildEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        init() &#123;</span><br><span class="line">          Panel.hidAll(this.panels, 0);</span><br><span class="line">          this.panels[0].action();</span><br><span class="line">        &#125;</span><br><span class="line">        buildEvent() &#123;</span><br><span class="line">          this.links.forEach((link, index) &#x3D;&gt; &#123;</span><br><span class="line">            link.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">              let test &#x3D; Panel.hidAll(this.panels, index);</span><br><span class="line">              this.panels[index].action();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      class Panel extends Animation &#123;</span><br><span class="line">        static num &#x3D; 0;</span><br><span class="line">        constructor(el) &#123;</span><br><span class="line">          super(el);</span><br><span class="line">          this.el &#x3D; el;</span><br><span class="line">        &#125;</span><br><span class="line">        action() &#123;</span><br><span class="line">          this.show();</span><br><span class="line">        &#125;</span><br><span class="line">        static hidAll(panels, index) &#123;</span><br><span class="line">          panels.forEach((v, i) &#x3D;&gt; &#123;</span><br><span class="line">            if (index !&#x3D; i) &#123;</span><br><span class="line">              v.hide();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    new Slide(&quot;.slide&quot;);</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面的版本：每次点击不同的item，会展示当前的item，收缩其它item。在动画结束前可以操作其它item。</p>
<p>下面的版本：动画结束前操作其它item无效果。</p>
<ul>
<li>定义一个静态属性，用于记录收缩选项的个数</li>
<li>如果当前收缩选项的个数大于0，即还有选项没有收缩完毕，则不执行对应的动画。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  class Animation &#123;</span><br><span class="line">    constructor(el) &#123;</span><br><span class="line">      this.el &#x3D; el;</span><br><span class="line">      this.timeOut &#x3D; 6;</span><br><span class="line">      this.step &#x3D; 3;</span><br><span class="line">      this.isShow &#x3D; false;</span><br><span class="line">      this.defaultHeight &#x3D; this.height;</span><br><span class="line">      this.timer &#x3D; undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    get height() &#123;</span><br><span class="line">      return parseFloat(window.getComputedStyle(this.el).height);</span><br><span class="line">    &#125;</span><br><span class="line">    set height(num) &#123;</span><br><span class="line">      this.el.style.height &#x3D; num + &quot;px&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    show(callback) &#123;</span><br><span class="line">      this.isShow &#x3D; true;</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">      this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        if (this.height &gt;&#x3D; this.defaultHeight) &#123;</span><br><span class="line">          clearInterval(this.timer);</span><br><span class="line">          callback &amp;&amp; callback(this);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.height &#x3D; this.height + this.step &gt;&#x3D; this.defaultHeight</span><br><span class="line">            ? this.defaultHeight</span><br><span class="line">            : this.height + this.step;</span><br><span class="line">      &#125;, this.timeOuttimeOut);</span><br><span class="line">    &#125;</span><br><span class="line">    hide(callback) &#123;</span><br><span class="line">      this.isShow &#x3D; false;</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">      this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        if (this.height &lt;&#x3D; 0) &#123;</span><br><span class="line">          clearInterval(this.timer);</span><br><span class="line">          callback &amp;&amp; callback(this);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.height &#x3D; this.height - this.step &lt; 0 ? 0 : this.height - this.step;</span><br><span class="line">      &#125;, this.timeOuttimeOut);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Slide &#123;</span><br><span class="line">    constructor(el) &#123;</span><br><span class="line">      this.el &#x3D; document.querySelector(el);</span><br><span class="line">      this.links &#x3D; this.el.querySelectorAll(&quot;dt&quot;);</span><br><span class="line">      this.panels &#x3D; [...this.el.querySelectorAll(&quot;dd&quot;)].map(</span><br><span class="line">        (v) &#x3D;&gt; new Panel(v)</span><br><span class="line">      );</span><br><span class="line">      this.init();</span><br><span class="line">      this.buildEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">      Panel.hidAll(Panel.others(this.panels, 0), () &#x3D;&gt; &#123;</span><br><span class="line">        this.panels[0].action();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    buildEvent() &#123;</span><br><span class="line">      this.links.forEach((link, index) &#x3D;&gt; &#123;</span><br><span class="line">        link.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">          Panel.hidAll(Panel.others(this.panels, index), () &#x3D;&gt; &#123;</span><br><span class="line">            this.panels[index].action();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Panel extends Animation &#123;</span><br><span class="line">    static num &#x3D; 0;</span><br><span class="line">    constructor(el) &#123;</span><br><span class="line">      super(el);</span><br><span class="line">      this.el &#x3D; el;</span><br><span class="line">    &#125;</span><br><span class="line">    action() &#123;</span><br><span class="line">       this.show();</span><br><span class="line">    &#125;</span><br><span class="line">    static hidAll(others, callback) &#123;</span><br><span class="line">      if (Panel.num &gt; 0) return false;</span><br><span class="line">      others.forEach((v, i) &#x3D;&gt; &#123;</span><br><span class="line">        ++Panel.num;</span><br><span class="line">        v.hide(() &#x3D;&gt; Panel.num--);	&#x2F;&#x2F;当panel的动画执行完毕后,进行--</span><br><span class="line">      &#125;);</span><br><span class="line">      callback &amp;&amp; callback();</span><br><span class="line">    &#125;</span><br><span class="line">    static others(panels, index) &#123;</span><br><span class="line">      return panels.filter((v, i) &#x3D;&gt; i !&#x3D; index);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">new Slide(&quot;.slide&quot;);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Web前端</category>
        <category>JavaScript大总结</category>
      </categories>
  </entry>
</search>
